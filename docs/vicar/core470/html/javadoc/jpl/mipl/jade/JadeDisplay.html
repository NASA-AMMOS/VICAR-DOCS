<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">
<head>

<title>JadeDisplay</title>
<meta name="date" content="2018-06-21">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript">
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":9,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>

<div class="topNav"><a name="navbar.top">

</a>
<div class="skipNav"><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">

</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../jpl/mipl/jade/Jade.html" title="class in jpl.mipl.jade"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../jpl/mipl/jade/JadeFileChooser.html" title="class in jpl.mipl.jade"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?jpl/mipl/jade/JadeDisplay.html" target="_top">Frames</a></li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/JadeDisplay.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript">
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#nested.classes.inherited.from.class.javax.swing.JPanel">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">

</a></div>


<div class="header">
<div class="subTitle">jpl.mipl.jade</div>
<h2 title="Class JadeDisplay" class="title">Class JadeDisplay</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>java.awt.Component</li>
<li>
<ul class="inheritance">
<li>java.awt.Container</li>
<li>
<ul class="inheritance">
<li>javax.swing.JComponent</li>
<li>
<ul class="inheritance">
<li>javax.swing.JPanel</li>
<li>
<ul class="inheritance">
<li>jpl.mipl.jade.JadeDisplay</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.awt.event.HierarchyListener, java.awt.image.ImageObserver, java.awt.MenuContainer, java.beans.PropertyChangeListener, java.io.Serializable, java.util.EventListener, javax.accessibility.Accessible, javax.media.jai.TileComputationListener, <a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">JadeDisplay</span>
extends javax.swing.JPanel
implements javax.media.jai.TileComputationListener, <a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a>, java.beans.PropertyChangeListener, java.awt.event.HierarchyListener</pre>
<div class="block">The primary image display component for JADE.  This class supports
 asynchronous computation of tiles for display, allowing the user to
 scroll and otherwise manipulate the image while it is being computed
 and painted.
 <p>
 JAI 1.1 or later is required to support the asynchronous features.  If fed
 an image that is not a JAI image, it will be wrapped (via
 <code>PlanarImage.wrapRenderedImage()</code>) to make it one.
 <p>
 This is a Swing lightweight component.  It is intended to display the
 entire image; for scrolling, put it in a <code>JScrollPane</code>.
 <p>
 <b>Repaint Policy</b>
 <p>
 The caller can control when the tiles are painted via the
 <code>repaintPolicy</code> property.  The choices are:
 <ul>
 <li><code>REPAINT_IMMEDIATE</code> All tiles are computed and painted
 immediately, with no background processing.  This is the way most
 simple displays work, including the sample widgets provided by JAI.
 It might be necessary to use this mode if one were for example rendering
 into an offscreen buffer, or rendering for printing.
 <li><code>REPAINT_DEFERRED</code> All tiles are deferred, meaning they
 are computed in the background (by JAI worker threads) and displayed
 when they are complete.  This includes cached tiles.
 <li><code>REPAINT_CACHE</code> A combination of the other two.  If the
 tile can be found in the JAI tile cache, it is painted immediately.
 If not, its computation is queued and the painting is deferred.  This is
 the most efficient option in most cases, and is the default.
 </ul>
 <p>
 <b>Image Origin</b>
 <p>
 The <code>imageOrigin</code> property defines the image coordinate that is
 shown in the upper left corner of the component.  Any part of the image
 above and to the left of that coordinate will not be displayed.  Note that
 the logical location of the image is taken into account, so if the image
 starts at (-100,-100) (see <code>RenderedImage.getMinX/Y()</code>), then
 the <code>imageOrigin</code> would also need to be set to (-100,-100) in
 order to display the whole image.  This <code>imageOrigin</code> is a
 hard cropping and should not be confused with a Pan value, which is
 managed entirely by the <code>JScrollPane</code> (or other higher-level
 component).  If <code>imageOrigin</code> is set to <code>null</code>, then
 the origin will automatically be set to the image's <code>minX</code> and
 <code>minY</code> values, and will be reset whenever those change.
 <p>
 <b>Double Buffering</b>
 <p>
 By default, Swing double-buffers its components.  This reduces flicker
 for most components.  However, the entire point of this image display
 is to display things deferred!  This creates flicker, intentionally (you
 see the background before the image gets painted).  This completely
 defeats the purpose of double-buffering.  Since double-buffering actually
 creates extra (unnecessary, here) work, by default <code>JadeDisplay</code>
 turns it off.
 <p>
 With one exception, the component will work fine either way, with double
 buffering on or off.  However, if you use <code>paintNoErase()</code> with
 tiles painted using <code>REPAINT_DEFERRED</code> (or
 <code>REPAINT_CACHE</code> when the tiles aren't in the cache), double
 buffering will create problems with garbage flashing on the screen.  The
 final image will look fine after all repaints are done, but the purpose
 of <code>paintNoErase</code> is to not erase the area being drawn, which
 interacts with double buffering in a bad way.
 <p>
 Although Swing has a <code>setDoubleBuffered</code> call, it is less
 useful than you might think.  In order to disable double buffering, you
 have to turn it off on every component in the hierarchy up to the root.
 This can have the side-effect of turning off double buffering for other
 components in the same window (which may benefit from it being on).
 It turns out that <code>JPanel</code> turns double-buffering on by
 default, so most subtrees beyond the display component will be
 double-buffered.  However, it may be necessary to manually enable
 double buffering for certain components.  Only the top-level component
 of a subtree needs to have double-buffering enabled, although it doesn't
 hurt to enable children.
 <p>
 The <code>disableDoubleBuffering</code> property controls whether or not
 this disabling happens.  <em>Note:</em> this property does <em>not</em>
 directly enable or disable double buffering.  It simply enables or
 disables the <it>process</it> by which <code>JadeDisplay</code> turns
 off double buffering on all of its ancestor components.  If true (the
 default), then all ancestors have double buffering turned off whenever
 a <code>HierarchyEvent</code> is received indicating a change in parents.
 If false, nothing is done on receiving the event (<code>JadeDisplay</code>
 never explicitly turns on double buffering, anywhere).  Practically
 speaking, this means that you should set this flag only in the constructor,
 or at least before you add the component into any container.  Setting the
 flag to false means that any manual settings of double buffering you might
 make are honored; <code>JadeDisplay</code> will not change any of them.
 <p>
 <b>Parallelism</b>
 <p>
 Because of the use of background processing, the Parallelism setting in
 the <code>TileScheduler</code> attached to the image can make quite a
 difference.  This component does not manage the parallelism however; this
 is up to the application (e.g. via
 <code>JAI.getDefaultInstance().getTileScheduler().setParallelism()</code>).
 <p>
 <b>RenderingChangeEvent response</b>
 <p>
 <code>JadeDisplay</code> monitors <code>RenderingChangeEvent</code>s (RCEs)
 generated by the image, and automatically repaints portions of the screen
 affected by that change.  So no manual painting is necessary when e.g.
 JAI operator parameters are modified.
 <p>
 Exactly <em>how</em> that repaint happens, though, is controllable via
 the RCE mode.  The values are:
 <ul>
 <li><code>RCE_REPAINT</code>: The default mode.  The affected areas are
 repainted via a call to <code>repaint()</code>.  The background painter
 is called (usually to erase the background to black) before the image is
 repainted, just as with any normal repaint.
 <li><code>RCE_FULL_NOERASE</code>: This mode uses <code>paintNoErase()</code>
 to do the repainting.  This can eliminate flashing due to repainting the
 background when the image changes, but could also lead to image areas that
 contain garbage while waiting for the tile to be processed.  The garbage
 could possibly be reduced by having a background painter that looks for
 isDeferredTile==true and paints backgrounds for deferred tiles even if
 isNoErase==true.  However, since by definition you have a new tile that
 is not in the cache when an RCE is received (and thus it is virtually
 certain to be deferred), this may be of limited usefulness.
 <li><code>RCE_PARTIAL_NOERASE</code>: Like <code>RCE_FULL_NOERASE</code>,
 but <code>paintNoErase()</code> is used only when the RCE indicates a
 partial-image update is needed.  Full-image updates use
 <code>repaint()</code>.  This may be useful for e.g. a mosaic operator,
 where partial-image updates are common (when input images are changed),
 since wholesale image changes will not leave unpainted debris on the
 screen.
 </ul>
 <p>
 Note that anything that causes the geometry of the image to change
 (size, tiling, data type, etc.) will cause <code>repaint()</code> to
 be used, regardless of the mode setting.  This is often the case for
 JAI operators like Rotate, which change the output size with rotation
 changes.  Also, despite the mode setting, other forms of repainting
 (scrolls, exposes, etc.) will still happen as usual.  This mode affects
 repaints <em>only</em> in response to a <code>RenderingChangeEvent</code>.
 <p>
 Because <code>RenderingChangeEvent</code> delivery is synchronous, it is
 possible for an application to set the RCE mode before making an update,
 make the update which generates the RCE (via
 <code>RenderedOp.setParameterBlock()</code> or similar), then re-set the
 RCE mode afterwards.  Thus the given mode applies only to one operation.
 This could be very useful for cases where it is known a priori that the
 display flashing will be undesirable when certain types of image updates
 are performed.
 <p>
 <b>Miscellaneous</b>
 <p>
 This component owes a lot of heritage to the <code>XvicImage</code>
 X-windows/Motif-based image display widget used in <code>xvd</code>.  If
 not actual code, at least the concepts.
 <p>
 This may or may not still be true (copied from the JAI ImageCanvas source):
 Due to the limitations of BufferedImage, only TYPE_BYTE of band
 1, 2, 3, 4, and TYPE_USHORT of band 1, 2, 3 images can be displayed
 using this component.
 <p>
 The component does not work terribly well if the tile sizes are too small,
 due to the overhead of tile processing.  This is especially apparent with
 certain TIFF files, where tiles are a single line.  The user should reformat
 the image into larger tiles in that case.
 <p>
 TBD: It is unknown if this component will work for printing.  It should,
 in immediate mode, but this has not been tested.
 <p>
 TBD: Should property events be generated when properties are changed?
 None have been needed to date.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Bob Deen, JPL</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../serialized-form.html#jpl.mipl.jade.JadeDisplay">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">

<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">

</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.javax.swing.JPanel">

</a>
<h3>Nested classes/interfaces inherited from class&nbsp;javax.swing.JPanel</h3>
<code>javax.swing.JPanel.AccessibleJPanel</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.javax.swing.JComponent">

</a>
<h3>Nested classes/interfaces inherited from class&nbsp;javax.swing.JComponent</h3>
<code>javax.swing.JComponent.AccessibleJComponent</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.java.awt.Container">

</a>
<h3>Nested classes/interfaces inherited from class&nbsp;java.awt.Container</h3>
<code>java.awt.Container.AccessibleAWTContainer</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.java.awt.Component">

</a>
<h3>Nested classes/interfaces inherited from class&nbsp;java.awt.Component</h3>
<code>java.awt.Component.AccessibleAWTComponent, java.awt.Component.BaselineResizeBehavior, java.awt.Component.BltBufferStrategy, java.awt.Component.FlipBufferStrategy</code></li>
</ul>
</li>
</ul>

<ul class="blockList">
<li class="blockList"><a name="field.summary">

</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_backgroundPainter">_backgroundPainter</a></span></code>
<div class="block">Background painter</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.ArrayList</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_batchOverlayPainters">_batchOverlayPainters</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.awt.image.ColorModel</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_colorModel">_colorModel</a></span></code>
<div class="block">The image's ColorModel or one we supply.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../jpl/mipl/jade/util/RectRegion.html" title="class in jpl.mipl.jade.util">RectRegion</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_damageList">_damageList</a></span></code>
<div class="block">The damage list</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_disableDoubleBuffering">_disableDoubleBuffering</a></span></code>
<div class="block">Whether or not to ensure double buffering is off.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_eraseBeforeRepaint">_eraseBeforeRepaint</a></span></code>
<div class="block">Whether or not to erase before repainting.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected javax.media.jai.PlanarImage</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_im">_im</a></span></code>
<div class="block">The source PlanarImage.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_imageHeight">_imageHeight</a></span></code>
<div class="block">The image size</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.awt.Point</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_imageOrigin">_imageOrigin</a></span></code>
<div class="block">The pixel to display in the UL corner of the component, or null.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_imageScreenHeight">_imageScreenHeight</a></span></code>
<div class="block">The w/h of the image in screen coordinates.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_imageScreenWidth">_imageScreenWidth</a></span></code>
<div class="block">The w/h of the image in screen coordinates.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_imageWidth">_imageWidth</a></span></code>
<div class="block">The image size</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.ArrayList</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_immediateOverlayPainters">_immediateOverlayPainters</a></span></code>
<div class="block">Overlay painters</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.awt.Insets</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_insets">_insets</a></span></code>
<div class="block">Caches insets</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.awt.Rectangle</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_insets_clip">_insets_clip</a></span></code>
<div class="block">Insets as a clipping rectangle</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_maxTileX">_maxTileX</a></span></code>
<div class="block">The image's min/max X and Y tile indices.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_maxTileY">_maxTileY</a></span></code>
<div class="block">The image's min/max X and Y tile indices.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_minTileX">_minTileX</a></span></code>
<div class="block">The image's min/max X and Y tile indices.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_minTileY">_minTileY</a></span></code>
<div class="block">The image's min/max X and Y tile indices.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_minX">_minX</a></span></code>
<div class="block">The minimum X/Y coordinate of the image</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_minY">_minY</a></span></code>
<div class="block">The minimum X/Y coordinate of the image</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_numTileX">_numTileX</a></span></code>
<div class="block">The number of tiles in the X/Y directions</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_numTileY">_numTileY</a></span></code>
<div class="block">The number of tiles in the X/Y directions</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_RCE_mode">_RCE_mode</a></span></code>
<div class="block">RenderingChangeEvent mode.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_repaintPolicy">_repaintPolicy</a></span></code>
<div class="block">Repaint policy.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_scr2imgX">_scr2imgX</a></span></code>
<div class="block">Conversion between screen and image coordinates (img = scr + scr2img)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_scr2imgY">_scr2imgY</a></span></code>
<div class="block">Conversion between screen and image coordinates (img = scr + scr2img)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_tileGridXOffset">_tileGridXOffset</a></span></code>
<div class="block">The image's tile grid X/Y offset.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_tileGridYOffset">_tileGridYOffset</a></span></code>
<div class="block">The image's tile grid X/Y offset.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_tileHeight">_tileHeight</a></span></code>
<div class="block">The image's tile width/height.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../jpl/mipl/jade/util/TilePainter.html" title="class in jpl.mipl.jade.util">TilePainter</a>[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_tilePainters">_tilePainters</a></span></code>
<div class="block">The list of TilePainter objects.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#Z:Z_tileWidth">_tileWidth</a></span></code>
<div class="block">The image's tile width/height.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#RCE_FULL_NOERASE">RCE_FULL_NOERASE</a></span></code>
<div class="block">When a RenderingChangeEvent is received, use
  <code>paintNoErase()</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#RCE_PARTIAL_NOERASE">RCE_PARTIAL_NOERASE</a></span></code>
<div class="block">When a RenderingChangeEvent is received and it is a partial-image
  update, use <code>paintNoErase()</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#RCE_REPAINT">RCE_REPAINT</a></span></code>
<div class="block">When a RenderingChangeEvent is received, use <code>repaint()</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#REPAINT_CACHE">REPAINT_CACHE</a></span></code>
<div class="block">If the tile is in the cache, same as REPAINT_IMMEDIATE.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#REPAINT_DEFERRED">REPAINT_DEFERRED</a></span></code>
<div class="block">Defer tile computation to asynchronous threads in all possible cases.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#REPAINT_IMMEDIATE">REPAINT_IMMEDIATE</a></span></code>
<div class="block">Repaint immediately in all cases.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.javax.swing.JComponent">

</a>
<h3>Fields inherited from class&nbsp;javax.swing.JComponent</h3>
<code>listenerList, TOOL_TIP_TEXT_KEY, ui, UNDEFINED_CONDITION, WHEN_ANCESTOR_OF_FOCUSED_COMPONENT, WHEN_FOCUSED, WHEN_IN_FOCUSED_WINDOW</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.java.awt.Component">

</a>
<h3>Fields inherited from class&nbsp;java.awt.Component</h3>
<code>accessibleContext, BOTTOM_ALIGNMENT, CENTER_ALIGNMENT, LEFT_ALIGNMENT, RIGHT_ALIGNMENT, TOP_ALIGNMENT</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.java.awt.image.ImageObserver">

</a>
<h3>Fields inherited from interface&nbsp;java.awt.image.ImageObserver</h3>
<code>ABORT, ALLBITS, ERROR, FRAMEBITS, HEIGHT, PROPERTIES, SOMEBITS, WIDTH</code></li>
</ul>
</li>
</ul>

<ul class="blockList">
<li class="blockList"><a name="constructor.summary">

</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#JadeDisplay-java.awt.image.RenderedImage-">JadeDisplay</a></span>(java.awt.image.RenderedImage&nbsp;im)</code>
<div class="block">Constructs a JadeDisplay to display a RenderedImage with default
 origin (<code>null</code>), repaint policy (<code>REPAINT_CACHE</code>),
 and double buffer disable flag (<code>false</code>).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#JadeDisplay-java.awt.image.RenderedImage-java.awt.Point-int-">JadeDisplay</a></span>(java.awt.image.RenderedImage&nbsp;im,
           java.awt.Point&nbsp;imageOrigin,
           int&nbsp;repaintPolicy)</code>
<div class="block">Constructs a JadeDisplay to display a RenderedImage with the given
 image origin and repaint policy.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#JadeDisplay-java.awt.image.RenderedImage-java.awt.Point-int-boolean-">JadeDisplay</a></span>(java.awt.image.RenderedImage&nbsp;im,
           java.awt.Point&nbsp;imageOrigin,
           int&nbsp;repaintPolicy,
           boolean&nbsp;disableDoubleBuffering)</code>
<div class="block">Constructs a JadeDisplay to display a RenderedImage with the given
 image origin, repaint policy, and double buffer disable flag.</div>
</td>
</tr>
</table>
</li>
</ul>

<ul class="blockList">
<li class="blockList"><a name="method.summary">

</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#abortQueuedTiles--">abortQueuedTiles</a></span>()</code>
<div class="block">Abort all queued computations.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected java.awt.Rectangle</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#addDamage-java.awt.Rectangle-">addDamage</a></span>(java.awt.Rectangle&nbsp;rect)</code>
<div class="block">Adds a Rectangle to the damage list.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#addOverlayPainter-int-jpl.mipl.jade.OverlayPainter-boolean-">addOverlayPainter</a></span>(int&nbsp;index,
                 <a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter,
                 boolean&nbsp;isImmediate)</code>
<div class="block">Adds an <code>OverlayPainter</code> to this component at the given
 position in the list.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#addOverlayPainter-jpl.mipl.jade.OverlayPainter-">addOverlayPainter</a></span>(<a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter)</code>
<div class="block">Adds an immediate-mode OverlayPainter to the end of the list (i.e.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#addOverlayPainterNRP-int-jpl.mipl.jade.OverlayPainter-boolean-">addOverlayPainterNRP</a></span>(int&nbsp;index,
                    <a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter,
                    boolean&nbsp;isImmediate)</code>
<div class="block">Adds an <code>OverlayPainter</code> to this component.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static javax.swing.JScrollPane</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#createDisplay-java.awt.image.RenderedImage-int-int-boolean-">createDisplay</a></span>(java.awt.image.RenderedImage&nbsp;image,
             int&nbsp;w,
             int&nbsp;h,
             boolean&nbsp;mouseScroller)</code>
<div class="block">Factory function that creates and returns a <code>JScrollPane</code> which
 contains a <code>JadeDisplay</code>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>java.awt.Point</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#getCurrentImageOrigin--">getCurrentImageOrigin</a></span>()</code>
<div class="block">Returns a copy of the current image origin value.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#getDisableDoubleBuffering--">getDisableDoubleBuffering</a></span>()</code>
<div class="block">Gets the current state of the double-buffer disable flag.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>java.awt.Graphics2D</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#getGraphics-java.awt.Rectangle-java.awt.Graphics-">getGraphics</a></span>(java.awt.Rectangle&nbsp;bounds,
           java.awt.Graphics&nbsp;g)</code>
<div class="block">Returns a <code>Graphics2D</code> object that can be used to paint a
 tile in the given rectangular bounds.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>java.awt.image.RenderedImage</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#getImage--">getImage</a></span>()</code>
<div class="block">Returns the image currently being displayed.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>java.awt.Point</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#getImageOrigin--">getImageOrigin</a></span>()</code>
<div class="block">Returns a copy of the image origin value.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#getRCEmode--">getRCEmode</a></span>()</code>
<div class="block">Gets the RenderingChangeEvent repaint mode.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#getRepaintPolicy--">getRepaintPolicy</a></span>()</code>
<div class="block">Gets the repaint policy.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>protected <a href="../../../jpl/mipl/jade/util/TilePainter.html" title="class in jpl.mipl.jade.util">TilePainter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#getTilePainter-int-int-">getTilePainter</a></span>(int&nbsp;tileX,
              int&nbsp;tileY)</code>
<div class="block">Convenience method to retrieve the TilePainter for
 a specific tile coordinate.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#handleResize--">handleResize</a></span>()</code>
<div class="block">Handles the component being resized by resetting all size-dependent
 member variables.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#hierarchyChanged-java.awt.event.HierarchyEvent-">hierarchyChanged</a></span>(java.awt.event.HierarchyEvent&nbsp;e)</code>
<div class="block">We have to monitor hierarchy events for two reasons:
 
 If any parent changed, and we're disabling double buffering,
 then we must disable it all the way to the root component.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#paintBackground-java.awt.Graphics-int-int-int-int-boolean-boolean-boolean-">paintBackground</a></span>(java.awt.Graphics&nbsp;g,
               int&nbsp;x,
               int&nbsp;y,
               int&nbsp;width,
               int&nbsp;height,
               boolean&nbsp;isNoErase,
               boolean&nbsp;isInsideImage,
               boolean&nbsp;isDeferredTile)</code>
<div class="block">Default background painter method.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#paintComponent-java.awt.Graphics-">paintComponent</a></span>(java.awt.Graphics&nbsp;g)</code>
<div class="block">Called by Swing to repaint the component.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#paintNoErase-int-int-int-int-">paintNoErase</a></span>(int&nbsp;x,
            int&nbsp;y,
            int&nbsp;w,
            int&nbsp;h)</code>
<div class="block">Paints a portion of the display without erasing it first.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#paintNoErase-java.awt.Rectangle-">paintNoErase</a></span>(java.awt.Rectangle&nbsp;r)</code>
<div class="block">Exactly like <code>paintNoErase(x,y,w,h)</code> except that the
 area to be repainted is a <code>Rectangle</code>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#paintOneOverlay-jpl.mipl.jade.OverlayPainter-java.awt.Rectangle-">paintOneOverlay</a></span>(<a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter,
               java.awt.Rectangle&nbsp;r)</code>
<div class="block">Special-purpose routine that repaints one overlay object only, without
 repainting the background image or other overlays.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#propertyChange-java.beans.PropertyChangeEvent-">propertyChange</a></span>(java.beans.PropertyChangeEvent&nbsp;evt)</code>
<div class="block">Responds to a PropertyChangeEvent from the image.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#removeOverlayPainter-jpl.mipl.jade.OverlayPainter-">removeOverlayPainter</a></span>(<a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter)</code>
<div class="block">Removes the specified <code>OverlayPainter</code> from this component.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#removeOverlayPainterNRP-jpl.mipl.jade.OverlayPainter-">removeOverlayPainterNRP</a></span>(<a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter)</code>
<div class="block">Removes the specified <code>OverlayPainter</code> from this component.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#repaintOverlay-java.awt.Graphics-">repaintOverlay</a></span>(java.awt.Graphics&nbsp;g)</code>
<div class="block">Called by <code>TilePainter</code> to refresh an area of the overlay.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#setBackgroundPainter-jpl.mipl.jade.BackgroundPainter-">setBackgroundPainter</a></span>(<a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a>&nbsp;bgpaint)</code>
<div class="block">Sets the given object to be the <code>BackgroundPainter</code> for this
 component.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#setDisableDoubleBuffering-boolean-">setDisableDoubleBuffering</a></span>(boolean&nbsp;flag)</code>
<div class="block">Sets the current state of the double-buffer disable flag.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#setImage-java.awt.image.RenderedImage-">setImage</a></span>(java.awt.image.RenderedImage&nbsp;im)</code>
<div class="block">Changes the source image to a new RenderedImage.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#setImage-java.awt.image.RenderedImage-java.awt.Point-">setImage</a></span>(java.awt.image.RenderedImage&nbsp;im,
        java.awt.Point&nbsp;origin)</code>
<div class="block">Changes the source image to a new RenderedImage while simultaneously
 changing the image origin.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#setImageInternal-java.awt.image.RenderedImage-">setImageInternal</a></span>(java.awt.image.RenderedImage&nbsp;im)</code>
<div class="block">Sets up a new image, registering and unregistering Listener's and
 updating any derived values.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#setImageOrigin-java.awt.Point-">setImageOrigin</a></span>(java.awt.Point&nbsp;origin)</code>
<div class="block">Changes the <code>imageOrigin</code> property.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#setRCEmode-int-">setRCEmode</a></span>(int&nbsp;mode)</code>
<div class="block">Sets the RenderingChangeEvent repaint mode.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#setRepaintPolicy-int-">setRepaintPolicy</a></span>(int&nbsp;policy)</code>
<div class="block">Sets the repaint policy.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#sizeComponent--">sizeComponent</a></span>()</code>
<div class="block">Sizes the component based on the image size.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#subtractDamage-java.awt.Rectangle-">subtractDamage</a></span>(java.awt.Rectangle&nbsp;rect)</code>
<div class="block">Subtracts a Rectangle from the damage list.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>protected java.awt.Rectangle</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#subtractDamage2-java.awt.Rectangle-">subtractDamage2</a></span>(java.awt.Rectangle&nbsp;rect)</code>
<div class="block">Subtracts a Rectangle from the damage list.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#tileCancelled-java.lang.Object-javax.media.jai.TileRequest:A-javax.media.jai.PlanarImage-int-int-">tileCancelled</a></span>(java.lang.Object&nbsp;eventSource,
             javax.media.jai.TileRequest[]&nbsp;requests,
             javax.media.jai.PlanarImage&nbsp;image,
             int&nbsp;tileX,
             int&nbsp;tileY)</code>
<div class="block">TileComputationListener functions.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#tileComputationFailure-java.lang.Object-javax.media.jai.TileRequest:A-javax.media.jai.PlanarImage-int-int-java.lang.Throwable-">tileComputationFailure</a></span>(java.lang.Object&nbsp;eventSource,
                      javax.media.jai.TileRequest[]&nbsp;requests,
                      javax.media.jai.PlanarImage&nbsp;image,
                      int&nbsp;tileX,
                      int&nbsp;tileY,
                      java.lang.Throwable&nbsp;situation)</code>
<div class="block">TileComputationListener functions.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../jpl/mipl/jade/JadeDisplay.html#tileComputed-java.lang.Object-javax.media.jai.TileRequest:A-javax.media.jai.PlanarImage-int-int-java.awt.image.Raster-">tileComputed</a></span>(java.lang.Object&nbsp;eventSource,
            javax.media.jai.TileRequest[]&nbsp;requests,
            javax.media.jai.PlanarImage&nbsp;image,
            int&nbsp;tileX,
            int&nbsp;tileY,
            java.awt.image.Raster&nbsp;tile)</code>
<div class="block">TileComputationListener functions.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.javax.swing.JPanel">

</a>
<h3>Methods inherited from class&nbsp;javax.swing.JPanel</h3>
<code>getAccessibleContext, getUI, getUIClassID, paramString, setUI, updateUI</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.javax.swing.JComponent">

</a>
<h3>Methods inherited from class&nbsp;javax.swing.JComponent</h3>
<code>addAncestorListener, addNotify, addVetoableChangeListener, computeVisibleRect, contains, createToolTip, disable, enable, firePropertyChange, firePropertyChange, firePropertyChange, fireVetoableChange, getActionForKeyStroke, getActionMap, getAlignmentX, getAlignmentY, getAncestorListeners, getAutoscrolls, getBaseline, getBaselineResizeBehavior, getBorder, getBounds, getClientProperty, getComponentGraphics, getComponentPopupMenu, getConditionForKeyStroke, getDebugGraphicsOptions, getDefaultLocale, getFontMetrics, getGraphics, getHeight, getInheritsPopupMenu, getInputMap, getInputMap, getInputVerifier, getInsets, getInsets, getListeners, getLocation, getMaximumSize, getMinimumSize, getNextFocusableComponent, getPopupLocation, getPreferredSize, getRegisteredKeyStrokes, getRootPane, getSize, getToolTipLocation, getToolTipText, getToolTipText, getTopLevelAncestor, getTransferHandler, getVerifyInputWhenFocusTarget, getVetoableChangeListeners, getVisibleRect, getWidth, getX, getY, grabFocus, hide, isDoubleBuffered, isLightweightComponent, isManagingFocus, isOpaque, isOptimizedDrawingEnabled, isPaintingForPrint, isPaintingOrigin, isPaintingTile, isRequestFocusEnabled, isValidateRoot, paint, paintBorder, paintChildren, paintImmediately, paintImmediately, print, printAll, printBorder, printChildren, printComponent, processComponentKeyEvent, processKeyBinding, processKeyEvent, processMouseEvent, processMouseMotionEvent, putClientProperty, registerKeyboardAction, registerKeyboardAction, removeAncestorListener, removeNotify, removeVetoableChangeListener, repaint, repaint, requestDefaultFocus, requestFocus, requestFocus, requestFocusInWindow, requestFocusInWindow, resetKeyboardActions, reshape, revalidate, scrollRectToVisible, setActionMap, setAlignmentX, setAlignmentY, setAutoscrolls, setBackground, setBorder, setComponentPopupMenu, setDebugGraphicsOptions, setDefaultLocale, setDoubleBuffered, setEnabled, setFocusTraversalKeys, setFont, setForeground, setInheritsPopupMenu, setInputMap, setInputVerifier, setMaximumSize, setMinimumSize, setNextFocusableComponent, setOpaque, setPreferredSize, setRequestFocusEnabled, setToolTipText, setTransferHandler, setUI, setVerifyInputWhenFocusTarget, setVisible, unregisterKeyboardAction, update</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.awt.Container">

</a>
<h3>Methods inherited from class&nbsp;java.awt.Container</h3>
<code>add, add, add, add, add, addContainerListener, addImpl, addPropertyChangeListener, addPropertyChangeListener, applyComponentOrientation, areFocusTraversalKeysSet, countComponents, deliverEvent, doLayout, findComponentAt, findComponentAt, getComponent, getComponentAt, getComponentAt, getComponentCount, getComponents, getComponentZOrder, getContainerListeners, getFocusTraversalKeys, getFocusTraversalPolicy, getLayout, getMousePosition, insets, invalidate, isAncestorOf, isFocusCycleRoot, isFocusCycleRoot, isFocusTraversalPolicyProvider, isFocusTraversalPolicySet, layout, list, list, locate, minimumSize, paintComponents, preferredSize, printComponents, processContainerEvent, processEvent, remove, remove, removeAll, removeContainerListener, setComponentZOrder, setFocusCycleRoot, setFocusTraversalPolicy, setFocusTraversalPolicyProvider, setLayout, transferFocusDownCycle, validate, validateTree</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.awt.Component">

</a>
<h3>Methods inherited from class&nbsp;java.awt.Component</h3>
<code>action, add, addComponentListener, addFocusListener, addHierarchyBoundsListener, addHierarchyListener, addInputMethodListener, addKeyListener, addMouseListener, addMouseMotionListener, addMouseWheelListener, bounds, checkImage, checkImage, coalesceEvents, contains, createImage, createImage, createVolatileImage, createVolatileImage, disableEvents, dispatchEvent, enable, enableEvents, enableInputMethods, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, getBackground, getBounds, getColorModel, getComponentListeners, getComponentOrientation, getCursor, getDropTarget, getFocusCycleRootAncestor, getFocusListeners, getFocusTraversalKeysEnabled, getFont, getForeground, getGraphicsConfiguration, getHierarchyBoundsListeners, getHierarchyListeners, getIgnoreRepaint, getInputContext, getInputMethodListeners, getInputMethodRequests, getKeyListeners, getLocale, getLocation, getLocationOnScreen, getMouseListeners, getMouseMotionListeners, getMousePosition, getMouseWheelListeners, getName, getParent, getPeer, getPropertyChangeListeners, getPropertyChangeListeners, getSize, getToolkit, getTreeLock, gotFocus, handleEvent, hasFocus, imageUpdate, inside, isBackgroundSet, isCursorSet, isDisplayable, isEnabled, isFocusable, isFocusOwner, isFocusTraversable, isFontSet, isForegroundSet, isLightweight, isMaximumSizeSet, isMinimumSizeSet, isPreferredSizeSet, isShowing, isValid, isVisible, keyDown, keyUp, list, list, list, location, lostFocus, mouseDown, mouseDrag, mouseEnter, mouseExit, mouseMove, mouseUp, move, nextFocus, paintAll, postEvent, prepareImage, prepareImage, processComponentEvent, processFocusEvent, processHierarchyBoundsEvent, processHierarchyEvent, processInputMethodEvent, processMouseWheelEvent, remove, removeComponentListener, removeFocusListener, removeHierarchyBoundsListener, removeHierarchyListener, removeInputMethodListener, removeKeyListener, removeMouseListener, removeMouseMotionListener, removeMouseWheelListener, removePropertyChangeListener, removePropertyChangeListener, repaint, repaint, repaint, resize, resize, setBounds, setBounds, setComponentOrientation, setCursor, setDropTarget, setFocusable, setFocusTraversalKeysEnabled, setIgnoreRepaint, setLocale, setLocation, setLocation, setName, setSize, setSize, show, show, size, toString, transferFocus, transferFocusBackward, transferFocusUpCycle</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">

</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">

<ul class="blockList">
<li class="blockList"><a name="field.detail">

</a>
<h3>Field Detail</h3>
<a name="Z:Z_im">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_im</h4>
<pre>protected&nbsp;javax.media.jai.PlanarImage _im</pre>
<div class="block">The source PlanarImage.</div>
</li>
</ul>
<a name="Z:Z_tilePainters">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_tilePainters</h4>
<pre>protected&nbsp;<a href="../../../jpl/mipl/jade/util/TilePainter.html" title="class in jpl.mipl.jade.util">TilePainter</a>[][] _tilePainters</pre>
<div class="block">The list of TilePainter objects.  Dimensions are [x][y].</div>
</li>
</ul>
<a name="Z:Z_colorModel">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_colorModel</h4>
<pre>protected&nbsp;java.awt.image.ColorModel _colorModel</pre>
<div class="block">The image's ColorModel or one we supply.</div>
</li>
</ul>
<a name="Z:Z_minTileX">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_minTileX</h4>
<pre>protected&nbsp;int _minTileX</pre>
<div class="block">The image's min/max X and Y tile indices.</div>
</li>
</ul>
<a name="Z:Z_maxTileX">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_maxTileX</h4>
<pre>protected&nbsp;int _maxTileX</pre>
<div class="block">The image's min/max X and Y tile indices.</div>
</li>
</ul>
<a name="Z:Z_minTileY">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_minTileY</h4>
<pre>protected&nbsp;int _minTileY</pre>
<div class="block">The image's min/max X and Y tile indices.</div>
</li>
</ul>
<a name="Z:Z_maxTileY">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_maxTileY</h4>
<pre>protected&nbsp;int _maxTileY</pre>
<div class="block">The image's min/max X and Y tile indices.</div>
</li>
</ul>
<a name="Z:Z_tileWidth">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_tileWidth</h4>
<pre>protected&nbsp;int _tileWidth</pre>
<div class="block">The image's tile width/height.</div>
</li>
</ul>
<a name="Z:Z_tileHeight">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_tileHeight</h4>
<pre>protected&nbsp;int _tileHeight</pre>
<div class="block">The image's tile width/height.</div>
</li>
</ul>
<a name="Z:Z_tileGridXOffset">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_tileGridXOffset</h4>
<pre>protected&nbsp;int _tileGridXOffset</pre>
<div class="block">The image's tile grid X/Y offset.</div>
</li>
</ul>
<a name="Z:Z_tileGridYOffset">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_tileGridYOffset</h4>
<pre>protected&nbsp;int _tileGridYOffset</pre>
<div class="block">The image's tile grid X/Y offset.</div>
</li>
</ul>
<a name="Z:Z_numTileX">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_numTileX</h4>
<pre>protected&nbsp;int _numTileX</pre>
<div class="block">The number of tiles in the X/Y directions</div>
</li>
</ul>
<a name="Z:Z_numTileY">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_numTileY</h4>
<pre>protected&nbsp;int _numTileY</pre>
<div class="block">The number of tiles in the X/Y directions</div>
</li>
</ul>
<a name="Z:Z_minX">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_minX</h4>
<pre>protected&nbsp;int _minX</pre>
<div class="block">The minimum X/Y coordinate of the image</div>
</li>
</ul>
<a name="Z:Z_minY">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_minY</h4>
<pre>protected&nbsp;int _minY</pre>
<div class="block">The minimum X/Y coordinate of the image</div>
</li>
</ul>
<a name="Z:Z_imageWidth">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_imageWidth</h4>
<pre>protected&nbsp;int _imageWidth</pre>
<div class="block">The image size</div>
</li>
</ul>
<a name="Z:Z_imageHeight">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_imageHeight</h4>
<pre>protected&nbsp;int _imageHeight</pre>
<div class="block">The image size</div>
</li>
</ul>
<a name="Z:Z_imageScreenWidth">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_imageScreenWidth</h4>
<pre>protected&nbsp;int _imageScreenWidth</pre>
<div class="block">The w/h of the image in screen coordinates.  Used to clip to image
  bounds if the view is bigger than the actual image.</div>
</li>
</ul>
<a name="Z:Z_imageScreenHeight">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_imageScreenHeight</h4>
<pre>protected&nbsp;int _imageScreenHeight</pre>
<div class="block">The w/h of the image in screen coordinates.  Used to clip to image
  bounds if the view is bigger than the actual image.</div>
</li>
</ul>
<a name="Z:Z_imageOrigin">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_imageOrigin</h4>
<pre>protected&nbsp;java.awt.Point _imageOrigin</pre>
<div class="block">The pixel to display in the UL corner of the component, or null.</div>
</li>
</ul>
<a name="Z:Z_repaintPolicy">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_repaintPolicy</h4>
<pre>protected&nbsp;int _repaintPolicy</pre>
<div class="block">Repaint policy.  Determines whether tiles are computed and displayed
  immediately, or deferred.</div>
</li>
</ul>
<a name="Z:Z_RCE_mode">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_RCE_mode</h4>
<pre>protected&nbsp;int _RCE_mode</pre>
<div class="block">RenderingChangeEvent mode.  Determines how tiles are repainted when
  the image changes.  See the class comments.</div>
</li>
</ul>
<a name="Z:Z_disableDoubleBuffering">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_disableDoubleBuffering</h4>
<pre>protected&nbsp;boolean _disableDoubleBuffering</pre>
<div class="block">Whether or not to ensure double buffering is off.</div>
</li>
</ul>
<a name="Z:Z_eraseBeforeRepaint">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_eraseBeforeRepaint</h4>
<pre>protected&nbsp;boolean _eraseBeforeRepaint</pre>
<div class="block">Whether or not to erase before repainting.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#paintNoErase-int-int-int-int-"><code>paintNoErase(int, int, int, int)</code></a></dd>
</dl>
</li>
</ul>
<a name="Z:Z_insets">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_insets</h4>
<pre>protected&nbsp;java.awt.Insets _insets</pre>
<div class="block">Caches insets</div>
</li>
</ul>
<a name="Z:Z_insets_clip">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_insets_clip</h4>
<pre>protected&nbsp;java.awt.Rectangle _insets_clip</pre>
<div class="block">Insets as a clipping rectangle</div>
</li>
</ul>
<a name="Z:Z_scr2imgX">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_scr2imgX</h4>
<pre>protected&nbsp;int _scr2imgX</pre>
<div class="block">Conversion between screen and image coordinates (img = scr + scr2img)</div>
</li>
</ul>
<a name="Z:Z_scr2imgY">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_scr2imgY</h4>
<pre>protected&nbsp;int _scr2imgY</pre>
<div class="block">Conversion between screen and image coordinates (img = scr + scr2img)</div>
</li>
</ul>
<a name="Z:Z_damageList">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_damageList</h4>
<pre>protected&nbsp;<a href="../../../jpl/mipl/jade/util/RectRegion.html" title="class in jpl.mipl.jade.util">RectRegion</a> _damageList</pre>
<div class="block">The damage list</div>
</li>
</ul>
<a name="Z:Z_immediateOverlayPainters">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_immediateOverlayPainters</h4>
<pre>protected&nbsp;java.util.ArrayList _immediateOverlayPainters</pre>
<div class="block">Overlay painters</div>
</li>
</ul>
<a name="Z:Z_batchOverlayPainters">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_batchOverlayPainters</h4>
<pre>protected&nbsp;java.util.ArrayList _batchOverlayPainters</pre>
</li>
</ul>
<a name="Z:Z_backgroundPainter">

</a>
<ul class="blockList">
<li class="blockList">
<h4>_backgroundPainter</h4>
<pre>protected&nbsp;<a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a> _backgroundPainter</pre>
<div class="block">Background painter</div>
</li>
</ul>
<a name="REPAINT_IMMEDIATE">

</a>
<ul class="blockList">
<li class="blockList">
<h4>REPAINT_IMMEDIATE</h4>
<pre>public static final&nbsp;int REPAINT_IMMEDIATE</pre>
<div class="block">Repaint immediately in all cases.  No queueing or background
  processing.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#jpl.mipl.jade.JadeDisplay.REPAINT_IMMEDIATE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="REPAINT_DEFERRED">

</a>
<ul class="blockList">
<li class="blockList">
<h4>REPAINT_DEFERRED</h4>
<pre>public static final&nbsp;int REPAINT_DEFERRED</pre>
<div class="block">Defer tile computation to asynchronous threads in all possible cases.
  Repaints happen when the tile is computed.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#jpl.mipl.jade.JadeDisplay.REPAINT_DEFERRED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="REPAINT_CACHE">

</a>
<ul class="blockList">
<li class="blockList">
<h4>REPAINT_CACHE</h4>
<pre>public static final&nbsp;int REPAINT_CACHE</pre>
<div class="block">If the tile is in the cache, same as REPAINT_IMMEDIATE.  If not,
  same as REPAINT_DEFERRED.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#jpl.mipl.jade.JadeDisplay.REPAINT_CACHE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RCE_REPAINT">

</a>
<ul class="blockList">
<li class="blockList">
<h4>RCE_REPAINT</h4>
<pre>public static final&nbsp;int RCE_REPAINT</pre>
<div class="block">When a RenderingChangeEvent is received, use <code>repaint()</code>.
  This is the default.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#jpl.mipl.jade.JadeDisplay.RCE_REPAINT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RCE_FULL_NOERASE">

</a>
<ul class="blockList">
<li class="blockList">
<h4>RCE_FULL_NOERASE</h4>
<pre>public static final&nbsp;int RCE_FULL_NOERASE</pre>
<div class="block">When a RenderingChangeEvent is received, use
  <code>paintNoErase()</code>.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#jpl.mipl.jade.JadeDisplay.RCE_FULL_NOERASE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RCE_PARTIAL_NOERASE">

</a>
<ul class="blockListLast">
<li class="blockList">
<h4>RCE_PARTIAL_NOERASE</h4>
<pre>public static final&nbsp;int RCE_PARTIAL_NOERASE</pre>
<div class="block">When a RenderingChangeEvent is received and it is a partial-image
  update, use <code>paintNoErase()</code>.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#jpl.mipl.jade.JadeDisplay.RCE_PARTIAL_NOERASE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>

<ul class="blockList">
<li class="blockList"><a name="constructor.detail">

</a>
<h3>Constructor Detail</h3>
<a name="JadeDisplay-java.awt.image.RenderedImage-java.awt.Point-int-boolean-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>JadeDisplay</h4>
<pre>public&nbsp;JadeDisplay(java.awt.image.RenderedImage&nbsp;im,
                   java.awt.Point&nbsp;imageOrigin,
                   int&nbsp;repaintPolicy,
                   boolean&nbsp;disableDoubleBuffering)</pre>
<div class="block">Constructs a JadeDisplay to display a RenderedImage with the given
 image origin, repaint policy, and double buffer disable flag.  A JAI
 <code>PlanarImage</code> is actually required but if the supplied image
 is not one, it will be automatically wrapped.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>im</code> - the RenderedImage to be displayed.</dd>
<dd><code>imageOrigin</code> - a Point specifying the image origin.</dd>
<dd><code>repaintPolicy</code> - the repaint policy.</dd>
<dd><code>disableDoubleBuffering</code> - whether or not to disable double buffering.
 See the class comments for a discussion.</dd>
</dl>
</li>
</ul>
<a name="JadeDisplay-java.awt.image.RenderedImage-java.awt.Point-int-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>JadeDisplay</h4>
<pre>public&nbsp;JadeDisplay(java.awt.image.RenderedImage&nbsp;im,
                   java.awt.Point&nbsp;imageOrigin,
                   int&nbsp;repaintPolicy)</pre>
<div class="block">Constructs a JadeDisplay to display a RenderedImage with the given
 image origin and repaint policy.  A JAI <code>PlanarImage</code> is
 actually required but if the supplied image is not one, it will be
 automatically wrapped.  Double-buffering will be disabled by default.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>im</code> - the RenderedImage to be displayed.</dd>
<dd><code>imageOrigin</code> - a Point specifying the image origin.</dd>
<dd><code>repaintPolicy</code> - the repaint policy.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#JadeDisplay-java.awt.image.RenderedImage-java.awt.Point-int-boolean-"><code>JadeDisplay(RenderedImage, Point, int, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a name="JadeDisplay-java.awt.image.RenderedImage-">

</a>
<ul class="blockListLast">
<li class="blockList">
<h4>JadeDisplay</h4>
<pre>public&nbsp;JadeDisplay(java.awt.image.RenderedImage&nbsp;im)</pre>
<div class="block">Constructs a JadeDisplay to display a RenderedImage with default
 origin (<code>null</code>), repaint policy (<code>REPAINT_CACHE</code>),
 and double buffer disable flag (<code>false</code>).</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#JadeDisplay-java.awt.image.RenderedImage-java.awt.Point-int-boolean-"><code>JadeDisplay(RenderedImage, Point, int, boolean)</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>

<ul class="blockList">
<li class="blockList"><a name="method.detail">

</a>
<h3>Method Detail</h3>
<a name="createDisplay-java.awt.image.RenderedImage-int-int-boolean-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>createDisplay</h4>
<pre>public static&nbsp;javax.swing.JScrollPane&nbsp;createDisplay(java.awt.image.RenderedImage&nbsp;image,
                                                    int&nbsp;w,
                                                    int&nbsp;h,
                                                    boolean&nbsp;mouseScroller)</pre>
<div class="block">Factory function that creates and returns a <code>JScrollPane</code> which
 contains a <code>JadeDisplay</code>.  The returned <code>JScrollPane</code>
 can be added to a <code>JPanel</code> or whatever else is desired.
 <p>
 Any event handlers, such as mouse trackers, should be added to the
 <code>JViewport</code> returned by <code>sp.getViewport())</code>
 (where <code>sp</code> is the component returned by this method).
 The <code>JadeDisplay</code> itself can be retrieved via
 <code>sp.getViewport().getView()</code>.
 <p>
 The size of the viewport is set to the <code>h</code> and <code>v</code>
 parameters.  If either is 0, the actual image's dimension is used instead.
 Be careful doing this with large images!  Also, the process of determining
 the image's dimension may cause it to be rendered (depending on what the
 image is).  Be cautious if you default the display size.
 <p>
 A <code>MouseScroller</code> is attached to the image if the
 <code>mouseScroller</code> parameter is <code>true</code>.  This enables
 simple mouse panning of the image.  If <code>false</code>, no panner is
 added (although the application is free to to so).  If you need to control
 the panner, create it yourself; there is no way to get a handle to the one
 created by this method.
 <p>
 This factory is a convenience function.  The display can be created on
 your own if you want more control.  The guts look like this:
 <p><pre>
     if (w == 0) w = image.getWidth();
     if (h == 0) h = image.getHeight();
     JPanel img_panel = new JadeDisplay(image);
     JScrollPane sp = new JScrollPane(img_panel);
     sp.setViewport(new JViewportImage());
     sp.setViewportView(img_panel);
     if (mouseScroller)
         new MouseScroller(sp.getViewport());
     sp.setPreferredSize(new Dimension(w, h));
     return sp;
 </pre><p>
 Note that a <code>JViewportImage</code> should be used instead of Swing's
 <code>JViewport</code>.  It will give you smoother diagonal scrolling.
 It should <em>work</em> with <code>JViewport</code> but mouse-based
 scrolling will be very distracting to the user.</div>
</li>
</ul>
<a name="getImage--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>getImage</h4>
<pre>public&nbsp;java.awt.image.RenderedImage&nbsp;getImage()</pre>
<div class="block">Returns the image currently being displayed.</div>
</li>
</ul>
<a name="setImage-java.awt.image.RenderedImage-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>setImage</h4>
<pre>public&nbsp;void&nbsp;setImage(java.awt.image.RenderedImage&nbsp;im)</pre>
<div class="block">Changes the source image to a new RenderedImage.
 <p>
 If the supplied image is <code>null</code>, the display will simply
 be cleared to the background color (and remain that way until an image
 is set).  No background or overlay painters are activated.</div>
</li>
</ul>
<a name="setImage-java.awt.image.RenderedImage-java.awt.Point-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>setImage</h4>
<pre>public&nbsp;void&nbsp;setImage(java.awt.image.RenderedImage&nbsp;im,
                     java.awt.Point&nbsp;origin)</pre>
<div class="block">Changes the source image to a new RenderedImage while simultaneously
 changing the image origin.  Useful if the new image has a different
 minX/Y value to prevent multiple updates.
 <p>
 If the supplied image is <code>null</code>, the display will simply
 be cleared to the background color (and remain that way until an image
 is set).  No background or overlay painters are activated.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#setImageOrigin-java.awt.Point-"><code>setImageOrigin(Point)</code></a></dd>
</dl>
</li>
</ul>
<a name="setImageInternal-java.awt.image.RenderedImage-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>setImageInternal</h4>
<pre>protected&nbsp;void&nbsp;setImageInternal(java.awt.image.RenderedImage&nbsp;im)</pre>
<div class="block">Sets up a new image, registering and unregistering Listener's and
 updating any derived values.  For internal use only.</div>
</li>
</ul>
<a name="addOverlayPainter-int-jpl.mipl.jade.OverlayPainter-boolean-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>addOverlayPainter</h4>
<pre>public&nbsp;void&nbsp;addOverlayPainter(int&nbsp;index,
                              <a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter,
                              boolean&nbsp;isImmediate)</pre>
<div class="block">Adds an <code>OverlayPainter</code> to this component at the given
 position in the list.  If the supplied index is bigger than the
 size of the list, the painter is simply added to the end of the list.
 (the end of the list is painted last, and is thus on top).
 <p>
 If <code>isImmediate</code> is true, the painter is added in immediate
 mode, meaning it is called for each and every screen update.  If it is
 false, it is added in batch mode, meaning it is called when the damage
 list is empty for a much larger area (often the whole window).
 <p>
 This method is safe to call from any thread.
 <p>
 <em>Note:</em>  Batch mode is not yet implemented.  Attempting to use
 it will cause an UnsupportedOperationException.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - index at which the specified element is to be inserted.</dd>
<dd><code>painter</code> - the <code>OverlayPainter</code> being registered.</dd>
<dd><code>isImmediate</code> - flag indicating immediate or batch mode.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the index is < 0.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>List.add(int, Object)</code></dd>
</dl>
</li>
</ul>
<a name="addOverlayPainter-jpl.mipl.jade.OverlayPainter-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>addOverlayPainter</h4>
<pre>public&nbsp;void&nbsp;addOverlayPainter(<a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter)</pre>
<div class="block">Adds an immediate-mode OverlayPainter to the end of the list (i.e.
 on top of everything else.
 <p>
 This method is safe to call from any thread.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#addOverlayPainter-int-jpl.mipl.jade.OverlayPainter-boolean-"><code>addOverlayPainter(int, OverlayPainter, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a name="addOverlayPainterNRP-int-jpl.mipl.jade.OverlayPainter-boolean-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>addOverlayPainterNRP</h4>
<pre>public&nbsp;void&nbsp;addOverlayPainterNRP(int&nbsp;index,
                                 <a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter,
                                 boolean&nbsp;isImmediate)</pre>
<div class="block">Adds an <code>OverlayPainter</code> to this component.  This is exactly
 like <code>addOverlayPainter()</code> except that <code>repaint()</code>
 is <em>not</em> called to refresh the display.  It is <em>imperative</em>
 that the caller immediately call a variant of <code>repaint()</code> to
 repaint the affected area.
 <p>
 The intent of this variant is to support <code>OverlayPainter</code>s with
 limited bounding boxes.  Instead of requiring the entire image be redrawn,
 only the area affected by the painter needs to be redrawn.
 <p>
 This method is safe to call from any thread.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#addOverlayPainter-int-jpl.mipl.jade.OverlayPainter-boolean-"><code>addOverlayPainter(int, OverlayPainter, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a name="removeOverlayPainter-jpl.mipl.jade.OverlayPainter-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>removeOverlayPainter</h4>
<pre>public&nbsp;void&nbsp;removeOverlayPainter(<a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter)</pre>
<div class="block">Removes the specified <code>OverlayPainter</code> from this component.
 If the painter is not found, nothing happens and no error is generated.
 If the painter happens to be in the list twice, only the first one found
 will be removed (batch painters are removed first).
 <p>
 This method is safe to call from any thread.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>painter</code> - the <code>OverlayPainter</code> to remove.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#addOverlayPainter-int-jpl.mipl.jade.OverlayPainter-boolean-"><code>addOverlayPainter(int, jpl.mipl.jade.OverlayPainter, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a name="removeOverlayPainterNRP-jpl.mipl.jade.OverlayPainter-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>removeOverlayPainterNRP</h4>
<pre>public&nbsp;void&nbsp;removeOverlayPainterNRP(<a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter)</pre>
<div class="block">Removes the specified <code>OverlayPainter</code> from this component.
 This is exactly like <code>removeOverlayPainter()</code> except that
 <code>repaint()</code> is <em>not</em> called to refresh the display.
 It is <em>imperative</em> that the caller immediately call a variant
 of <code>repaint()</code> to repaint the affected area.
 <p>
 The intent of this variant is to support <code>OverlayPainter</code>s with
 limited bounding boxes.  Instead of requiring the entire image be redrawn,
 only the area affected by the painter needs to be redrawn.
 <p>
 This method is safe to call from any thread.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#removeOverlayPainter-jpl.mipl.jade.OverlayPainter-"><code>removeOverlayPainter(OverlayPainter)</code></a></dd>
</dl>
</li>
</ul>
<a name="setBackgroundPainter-jpl.mipl.jade.BackgroundPainter-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>setBackgroundPainter</h4>
<pre>public&nbsp;<a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a>&nbsp;setBackgroundPainter(<a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a>&nbsp;bgpaint)</pre>
<div class="block">Sets the given object to be the <code>BackgroundPainter</code> for this
 component.  This replaces any old <code>BackgroundPainter</code>s (there
 is only one).  The previous <code>BackgroundPainter</code> is returned
 (which could be <code>null</code> if it's the default).
 <p>
 If <code>null</code> is passed in, the default background painting
 behavior will be restored (which simply erases the background).  See
 <code>BackgroundPainter</code> for the actual code.
 <p>
 This method is safe to call from any thread.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bgpaint</code> - the <code>BackgroundPainter</code> being registered.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the previous <code>BackgroundPainter</code> or <code>null</code>
 if it's the default method.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade"><code>BackgroundPainter</code></a></dd>
</dl>
</li>
</ul>
<a name="paintBackground-java.awt.Graphics-int-int-int-int-boolean-boolean-boolean-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>paintBackground</h4>
<pre>public&nbsp;void&nbsp;paintBackground(java.awt.Graphics&nbsp;g,
                            int&nbsp;x,
                            int&nbsp;y,
                            int&nbsp;width,
                            int&nbsp;height,
                            boolean&nbsp;isNoErase,
                            boolean&nbsp;isInsideImage,
                            boolean&nbsp;isDeferredTile)</pre>
<div class="block">Default background painter method.  Implemented as follows:
 <pre>
  private void paintBackground(Graphics g,
                              int x, int y, int width, int height,
                              boolean isNoErase, boolean isInsideImage,
                              boolean isDeferredTile)
  {
      if (isDeferredTile || isNoErase)
          return;
       g.setColor(this.getBackground());
      g.fillRect(x, y, width, height);
  }
 </pre>
 <p>
 This method is public only because it implements the
 <code>BackgroundPainter<</code> interface.  It should not be referenced
 from outside.  In order to use this default, call
 <code>setBackgroundPainter(null)</code>.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../jpl/mipl/jade/BackgroundPainter.html#paintBackground-java.awt.Graphics-int-int-int-int-boolean-boolean-boolean-">paintBackground</a></code>&nbsp;in interface&nbsp;<code><a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade">BackgroundPainter</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>g</code> - The <code>Graphics</code> into which to paint.  This is most
 likely a <code>Graphics2D</code> instance, but that is not guaranteed
 by <code>JadeDisplay</code>.  It is usually whatever was passed in to
 <code>paint(g)</code>, translated and clipped appropriately.</dd>
<dd><code>x</code> - The X coordinate of the rectangle to be painted</dd>
<dd><code>y</code> - The Y coordinate of the rectangle to be painted</dd>
<dd><code>width</code> - The width of the rectangle to be painted</dd>
<dd><code>height</code> - The height of the rectangle to be painted</dd>
<dd><code>isNoErase</code> - True if called from <code>paintNoErase()</code></dd>
<dd><code>isInsideImage</code> - True if rectangle is inside the image bounds</dd>
<dd><code>isDeferredTile</code> - True if tile is deferred (this is the second call)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/BackgroundPainter.html" title="interface in jpl.mipl.jade"><code>BackgroundPainter</code></a>, 
<a href="../../../jpl/mipl/jade/JadeDisplay.html#setBackgroundPainter-jpl.mipl.jade.BackgroundPainter-"><code>setBackgroundPainter(jpl.mipl.jade.BackgroundPainter)</code></a></dd>
</dl>
</li>
</ul>
<a name="handleResize--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>handleResize</h4>
<pre>protected&nbsp;void&nbsp;handleResize()</pre>
<div class="block">Handles the component being resized by resetting all size-dependent
 member variables.</div>
</li>
</ul>
<a name="sizeComponent--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>sizeComponent</h4>
<pre>protected&nbsp;void&nbsp;sizeComponent()</pre>
<div class="block">Sizes the component based on the image size.</div>
</li>
</ul>
<a name="setImageOrigin-java.awt.Point-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>setImageOrigin</h4>
<pre>public&nbsp;void&nbsp;setImageOrigin(java.awt.Point&nbsp;origin)</pre>
<div class="block">Changes the <code>imageOrigin</code> property.  This property defines
 the image coordinate that is shown in the upper left corner of the
 component.  Any part of the image above and to the left of that
 coordinate will not be displayed.  Note that the logical location of
 the image is taken into account, so if the image starts at (-100,-100)
 (see <code>RenderedImage.getMinX/Y()</code>), then the
 <code>imageOrigin</code> would also need to be set to (-100,-100) in
 order to display the whole image.  This <code>imageOrigin</code> is a
 hard cropping and should not be confused with a Pan value, which is
 managed entirely by the <code>JScrollPane</code> (or other higher-level
 component).
 <p>
 If the origin is set to <code>null</code>, the origin will automatically
 be set to the image's <code>minX</code> and <code>minY</code> values, and
 will be reset whenever those change.  This means that the origin is pinned
 to the actual corner of the image.</div>
</li>
</ul>
<a name="getImageOrigin--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>getImageOrigin</h4>
<pre>public&nbsp;java.awt.Point&nbsp;getImageOrigin()</pre>
<div class="block">Returns a copy of the image origin value.  Will return <code>null</code>
 if that's the way the user set it (in which case the image's
 <code>getMinX()</code> and <code>getMinY()</code> will need to be called
 by the user to get the values).</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#setImageOrigin-java.awt.Point-"><code>setImageOrigin(java.awt.Point)</code></a>, 
<a href="../../../jpl/mipl/jade/JadeDisplay.html#getCurrentImageOrigin--"><code>getCurrentImageOrigin()</code></a></dd>
</dl>
</li>
</ul>
<a name="getCurrentImageOrigin--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>getCurrentImageOrigin</h4>
<pre>public&nbsp;java.awt.Point&nbsp;getCurrentImageOrigin()</pre>
<div class="block">Returns a copy of the current image origin value.  This differs from
 <code>getImageOrigin()</code> because it will never return <code>null</code>.
 If the origin has not been set, the image's <code>getMinX/Y()</code> will
 be called as a convenience, and returned.  Note that this value can
 change if the image min does, so it should be used immediately and not
 stored.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#setImageOrigin-java.awt.Point-"><code>setImageOrigin(java.awt.Point)</code></a>, 
<a href="../../../jpl/mipl/jade/JadeDisplay.html#getImageOrigin--"><code>getImageOrigin()</code></a></dd>
</dl>
</li>
</ul>
<a name="setRepaintPolicy-int-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>setRepaintPolicy</h4>
<pre>public&nbsp;void&nbsp;setRepaintPolicy(int&nbsp;policy)</pre>
<div class="block">Sets the repaint policy.  See the field definitions and class comments
 for details.</div>
</li>
</ul>
<a name="getRepaintPolicy--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>getRepaintPolicy</h4>
<pre>public&nbsp;int&nbsp;getRepaintPolicy()</pre>
<div class="block">Gets the repaint policy.  See the field definitions and class comments
 for details.</div>
</li>
</ul>
<a name="setRCEmode-int-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>setRCEmode</h4>
<pre>public&nbsp;void&nbsp;setRCEmode(int&nbsp;mode)</pre>
<div class="block">Sets the RenderingChangeEvent repaint mode.  See the field definitions
 and class comments for details.</div>
</li>
</ul>
<a name="getRCEmode--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>getRCEmode</h4>
<pre>public&nbsp;int&nbsp;getRCEmode()</pre>
<div class="block">Gets the RenderingChangeEvent repaint mode.  See the field definitions
 and class comments for details.</div>
</li>
</ul>
<a name="setDisableDoubleBuffering-boolean-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>setDisableDoubleBuffering</h4>
<pre>public&nbsp;void&nbsp;setDisableDoubleBuffering(boolean&nbsp;flag)</pre>
<div class="block">Sets the current state of the double-buffer disable flag.  Note that
 this does not change the double-buffer status of any actual components;
 that happens when a <code>HierarchyChanged</code> event is received.
 For that matter, it is recommended that this function be called before
 adding the component to a container... or better yet, set the flag in the
 constructor.  See the class comments for a discussion.</div>
</li>
</ul>
<a name="getDisableDoubleBuffering--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>getDisableDoubleBuffering</h4>
<pre>public&nbsp;boolean&nbsp;getDisableDoubleBuffering()</pre>
<div class="block">Gets the current state of the double-buffer disable flag.  See the
 class comments for a discussion.</div>
</li>
</ul>
<a name="addDamage-java.awt.Rectangle-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>addDamage</h4>
<pre>protected&nbsp;java.awt.Rectangle&nbsp;addDamage(java.awt.Rectangle&nbsp;rect)</pre>
<div class="block">Adds a Rectangle to the damage list.  Normally called by
 <code>paintComponent()</code> with the current clip area.
 Also returns the bounding rectangle of the damage list after
 the new piece is added (this is done here solely to avoid another
 synchronize).</div>
</li>
</ul>
<a name="subtractDamage-java.awt.Rectangle-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>subtractDamage</h4>
<pre>public&nbsp;void&nbsp;subtractDamage(java.awt.Rectangle&nbsp;rect)</pre>
<div class="block">Subtracts a Rectangle from the damage list.  Normally called when
 a tile has been successfully painted.
 <p>
 <em>Warning!</em>  This routine is only intended to be called by
 <code>TilePainter</code>.  Do not call it from application code.</div>
</li>
</ul>
<a name="subtractDamage2-java.awt.Rectangle-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>subtractDamage2</h4>
<pre>protected&nbsp;java.awt.Rectangle&nbsp;subtractDamage2(java.awt.Rectangle&nbsp;rect)</pre>
<div class="block">Subtracts a Rectangle from the damage list.  Normally called when
 graphics outside the image have been successfully painted.  Also returns
 the bounding rectangle of the damage list after the new piece is
 subtracted (this is done here solely to avoid another synchronize).</div>
</li>
</ul>
<a name="paintNoErase-int-int-int-int-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>paintNoErase</h4>
<pre>public&nbsp;void&nbsp;paintNoErase(int&nbsp;x,
                         int&nbsp;y,
                         int&nbsp;w,
                         int&nbsp;h)</pre>
<div class="block">Paints a portion of the display without erasing it first.  This also
 causes the painting to happen immediately, without waiting for
 <code>repaint</code> to batch up requests.  This is intended for use
 with and by graphics overlays.  If the background image didn't change,
 and only the overlay did, then erasing the background first causes
 undesirable flashing.  Calling this routine instead of <code>repaint</code>
 should eliminate most of that flashing.
 <p>
 We don't paint everything this way because it is very distracting while
 scrolling.  The image to paint changes when you scroll, but that could
 take some time.  In the meantime, you see leftover garbage, which is
 objectionable.  Erasing first gives the user some clue as to how much
 is left to repaint.
 <p>
 <em>Note:</em>  This routine does not work very well if Swing double
 buffering is enabled.  You can get undesirable flashing, which is what
 the routine is supposed to eliminate in the first place.  Double buffering
 is disabled by default, though.  See the discussion on double buffering
 in the class comments.
 <p>
 <em>Important!</em>  As with all other paint-related calls, the coordinates
 here are <em>Viewport</em> coordinates, which are not necessarily the same
 as <em>Image</em> coordinates!!  There is an offset if the image origin
 does not start at zero.  <code>getCurrentImageOrigin()</code> can be
 used to get this offset.  This may cause confusion because
 <code>OverlayPainter</code>s are called using <em>Image</em> coordinates.
 <p>
 <em>Note:</em>  Unlike <code>repaint()</code>, this method must be
 called from the Swing/AWT Event thread.  No check is made, and the
 behavior is undefined if the wrong thread is used.
 <code>SwingUtilities.invokeLater()</code> can be used if you're on the
 wrong thread.
 <p>
 We used to override <code>paintImmediately()</code> for this function,
 but <code>paintImmediately</code> is called other places in the viewport
 framework, and suppressing erases caused really objectionable flashing.
 This routine calls <code>paintImmediately</code> (after setting a flag)
 so any restrictions with that routine apply here as well.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>JComponent.repaint(long, int, int, int, int)</code>, 
<a href="../../../jpl/mipl/jade/JadeDisplay.html#addOverlayPainter-int-jpl.mipl.jade.OverlayPainter-boolean-"><code>addOverlayPainter(int, jpl.mipl.jade.OverlayPainter, boolean)</code></a>, 
<code>JComponent.paintImmediately(int,int,int,int)</code>, 
<code>SwingUtilities.invokeLater(java.lang.Runnable)</code></dd>
</dl>
</li>
</ul>
<a name="paintNoErase-java.awt.Rectangle-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>paintNoErase</h4>
<pre>public&nbsp;void&nbsp;paintNoErase(java.awt.Rectangle&nbsp;r)</pre>
<div class="block">Exactly like <code>paintNoErase(x,y,w,h)</code> except that the
 area to be repainted is a <code>Rectangle</code>.  See that routine
 for details.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#paintNoErase-int-int-int-int-"><code>paintNoErase(int,int,int,int)</code></a></dd>
</dl>
</li>
</ul>
<a name="paintOneOverlay-jpl.mipl.jade.OverlayPainter-java.awt.Rectangle-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>paintOneOverlay</h4>
<pre>public&nbsp;void&nbsp;paintOneOverlay(<a href="../../../jpl/mipl/jade/OverlayPainter.html" title="interface in jpl.mipl.jade">OverlayPainter</a>&nbsp;painter,
                            java.awt.Rectangle&nbsp;r)</pre>
<div class="block">Special-purpose routine that repaints one overlay object only, without
 repainting the background image or other overlays.
 <p>
 <em>WARNING!</em>  This routine is dangerous.  It should ONLY be called
 to <em>exactly</em> overpaint an existing graphic, such as for color
 cycling.  The exact shape of the existing overlay must be repainted, or
 expanded.  The graphic cannot shrink, since the underlying image is not
 refreshed and thus the old graphic cannot be erased.  Also, the overlays
 "on top" of this one are NOT repainted, so they may be overwritten
 (stacking order is not preserved with this routine).  In addition, any
 kind of translucency or blending effect that other overlays may try to
 do will not work with this routine.
 <p>
 So, users of this routine must be aware of the global overlay environment,
 and must only repaint (e.g. changing colors) or expand the graphics painted
 by the overlay.
 <p>
 Note that if the region being requested is not completely drawn, the
 call will be converted into a call to <code>repaint(r)</code>, which
 will cause ALL overlays in the area to be redrawn, not just this one
 (thus it may no longer be on top).
 <p>
 It is legal to call this routine with an <code>OverlayPainter</code> that
 is not registered as a painter (via <code>addOverlayPainter</code>
 <it>et al</it>.  This can be used to advantage to paint special overlays
 (color cycling, etc).  However, in this case the specified painter
 <em>WILL NOT</em> be called on expose events, or if the call to this
 routine is converted into a call to <code>repaint</code>, as described
 above.  Thus this feature must be used with extreme caution.
 <p>
 <em>Important!</em>  As with all other paint-related calls, the coordinates
 of <code>r</code> are <em>Viewport</em> coordinates, which are not
 necessarily the same as <em>Image</em> coordinates!!  There is an offset if
 the image origin does not start at zero.
 <code>getCurrentImageOrigin()</code> can be used to get this offset.  This
 may cause confusion because <code>OverlayPainter</code>s are called using
 <em>Image</em> coordinates.
 <p>
 This routine must be called from the Swing/AWT event thread.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>painter</code> - Specifies which <code>OverlayPainter</code> object should
 do the painting.  May not be called if the area is not completely drawn
 (see class comments).  Only immediate-mode <code>OverlayPainter</code>s
 are supported.</dd>
<dd><code>r</code> - The area to redraw.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if <code>index</code> is out of range.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../jpl/mipl/jade/JadeDisplay.html#addOverlayPainter-int-jpl.mipl.jade.OverlayPainter-boolean-"><code>addOverlayPainter(int, OverlayPainter, boolean)</code></a>, 
<code>JComponent.repaint(Rectangle)</code></dd>
</dl>
</li>
</ul>
<a name="paintComponent-java.awt.Graphics-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>paintComponent</h4>
<pre>public&nbsp;void&nbsp;paintComponent(java.awt.Graphics&nbsp;g)</pre>
<div class="block">Called by Swing to repaint the component.  Goes through each tile and
 tells any TilePainters that intersect the new damaged area to do their
 thing.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>paintComponent</code>&nbsp;in class&nbsp;<code>javax.swing.JComponent</code></dd>
</dl>
</li>
</ul>
<a name="abortQueuedTiles--">

</a>
<ul class="blockList">
<li class="blockList">
<h4>abortQueuedTiles</h4>
<pre>protected&nbsp;void&nbsp;abortQueuedTiles()</pre>
<div class="block">Abort all queued computations.  This is called by the hierarchy
 listener when it determines the component is no longer showing, or
 when we get a RenderingChangeEvent.
 <p>
 <em>Warning:</em> Calling this routine when the component is showing
 may result in unpainted holes.</div>
</li>
</ul>
<a name="tileComputationFailure-java.lang.Object-javax.media.jai.TileRequest:A-javax.media.jai.PlanarImage-int-int-java.lang.Throwable-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>tileComputationFailure</h4>
<pre>public&nbsp;void&nbsp;tileComputationFailure(java.lang.Object&nbsp;eventSource,
                                   javax.media.jai.TileRequest[]&nbsp;requests,
                                   javax.media.jai.PlanarImage&nbsp;image,
                                   int&nbsp;tileX,
                                   int&nbsp;tileY,
                                   java.lang.Throwable&nbsp;situation)</pre>
<div class="block">TileComputationListener functions.  This function is a "broker", or
 central switching yard, which passes the failure on to the appropriate
 TilePainter to handle.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>tileComputationFailure</code>&nbsp;in interface&nbsp;<code>javax.media.jai.TileComputationListener</code></dd>
</dl>
</li>
</ul>
<a name="tileComputed-java.lang.Object-javax.media.jai.TileRequest:A-javax.media.jai.PlanarImage-int-int-java.awt.image.Raster-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>tileComputed</h4>
<pre>public&nbsp;void&nbsp;tileComputed(java.lang.Object&nbsp;eventSource,
                         javax.media.jai.TileRequest[]&nbsp;requests,
                         javax.media.jai.PlanarImage&nbsp;image,
                         int&nbsp;tileX,
                         int&nbsp;tileY,
                         java.awt.image.Raster&nbsp;tile)</pre>
<div class="block">TileComputationListener functions.  This function is a "broker", or
 central switching yard, which gets notifications for each tile that is
 completed, and routes that notification to the appropriate TilePainter.
 This must be done here rather than in TilePainter directly for efficiency
 reasons.  If JAI adds a per-tile notification mechanism, this can be
 dispensed with (and this class would no longer need to implement
 TileComputationListener).</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>tileComputed</code>&nbsp;in interface&nbsp;<code>javax.media.jai.TileComputationListener</code></dd>
</dl>
</li>
</ul>
<a name="tileCancelled-java.lang.Object-javax.media.jai.TileRequest:A-javax.media.jai.PlanarImage-int-int-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>tileCancelled</h4>
<pre>public&nbsp;void&nbsp;tileCancelled(java.lang.Object&nbsp;eventSource,
                          javax.media.jai.TileRequest[]&nbsp;requests,
                          javax.media.jai.PlanarImage&nbsp;image,
                          int&nbsp;tileX,
                          int&nbsp;tileY)</pre>
<div class="block">TileComputationListener functions.  This function is a "broker", or
 central switching yard, which gets notifications for each tile that is
 cancelled, and routes that notification to the appropriate TilePainter.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>tileCancelled</code>&nbsp;in interface&nbsp;<code>javax.media.jai.TileComputationListener</code></dd>
</dl>
</li>
</ul>
<a name="getTilePainter-int-int-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>getTilePainter</h4>
<pre>protected&nbsp;<a href="../../../jpl/mipl/jade/util/TilePainter.html" title="class in jpl.mipl.jade.util">TilePainter</a>&nbsp;getTilePainter(int&nbsp;tileX,
                                     int&nbsp;tileY)</pre>
<div class="block">Convenience method to retrieve the TilePainter for
 a specific tile coordinate.  This method gracefully
 handlers when the indices are out of range, in which
 case, null would be returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tileX</code> - Tile's x index</dd>
<dd><code>tileY</code> - Tile's y index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>TilePainter at tile index, or null.</dd>
</dl>
</li>
</ul>
<a name="getGraphics-java.awt.Rectangle-java.awt.Graphics-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphics</h4>
<pre>public&nbsp;java.awt.Graphics2D&nbsp;getGraphics(java.awt.Rectangle&nbsp;bounds,
                                       java.awt.Graphics&nbsp;g)</pre>
<div class="block">Returns a <code>Graphics2D</code> object that can be used to paint a
 tile in the given rectangular bounds.  The clip region of the returned
 <code>Graphics2D</code> will be set to the intersection of the damage
 list, the visible area, and the supplied bounds.  In addition, the
 <code>Graphics2D</code> object will be translated appropriately to be
 able to draw the tile directly in image coords, so that coordinate (0,0)
 is at the upper left corner of the image.
 <p>
 The supplied <code>Graphics</code> object is used as a basis if it
 exists (the clip area and translation is set), or if it doesn't exist,
 a <code>Graphics</code> object is obtained from
 <code>JComponent.getGraphics()</code>.
 <p>
 It is recommended (not not required) to call <code>Graphics.dispose()</code>
 when you are done with the returned Graphics object.  A new one is created
 even if <code>g</code> is passed in.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bounds</code> - The bounding rectangle of the tile</dd>
<dd><code>g</code> - The graphics object to use, or null to get a fresh one</dd>
</dl>
</li>
</ul>
<a name="repaintOverlay-java.awt.Graphics-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>repaintOverlay</h4>
<pre>public&nbsp;void&nbsp;repaintOverlay(java.awt.Graphics&nbsp;g)</pre>
<div class="block">Called by <code>TilePainter</code> to refresh an area of the overlay.
 If there are any immediate-mode overlay painters, they are called
 immediately.  If there are any batch mode painters, the area is added
 to the overlay damage list for later painting.  The area to paint is
 the <code>clipRect</code> of the supplied <code>Graphics</code> object.
 <p>
 <em>User code should not call this routine!</em></div>
</li>
</ul>
<a name="propertyChange-java.beans.PropertyChangeEvent-">

</a>
<ul class="blockList">
<li class="blockList">
<h4>propertyChange</h4>
<pre>public&nbsp;void&nbsp;propertyChange(java.beans.PropertyChangeEvent&nbsp;evt)</pre>
<div class="block">Responds to a PropertyChangeEvent from the image.  We look for
 RenderingChangeEvents and use them to update the display.  Other
 properties are ignored.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>propertyChange</code>&nbsp;in interface&nbsp;<code>java.beans.PropertyChangeListener</code></dd>
</dl>
</li>
</ul>
<a name="hierarchyChanged-java.awt.event.HierarchyEvent-">

</a>
<ul class="blockListLast">
<li class="blockList">
<h4>hierarchyChanged</h4>
<pre>public&nbsp;void&nbsp;hierarchyChanged(java.awt.event.HierarchyEvent&nbsp;e)</pre>
<div class="block">We have to monitor hierarchy events for two reasons:
 <ul>
 <li>If any parent changed, and we're disabling double buffering,
 then we must disable it all the way to the root component.
 Hopefully other sibling components will have DB turned on and
 will thus be buffered (JPanel has DB turned on by default).
 See the class comments for a discussion.

 <li>If we are no longer showing, then we should abort all queued
 repaints.  This is an efficiency measure; getGraphics() will return
 null if we're no longer showing, but there's no point in computing the
 tiles then.  This commonly occurs when the image is in a JTabbedPane
 and the user clicks a different tab before the repaints are done.
 </ul></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>hierarchyChanged</code>&nbsp;in interface&nbsp;<code>java.awt.event.HierarchyListener</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div class="bottomNav"><a name="navbar.bottom">

</a>
<div class="skipNav"><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">

</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../jpl/mipl/jade/Jade.html" title="class in jpl.mipl.jade"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../jpl/mipl/jade/JadeFileChooser.html" title="class in jpl.mipl.jade"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?jpl/mipl/jade/JadeDisplay.html" target="_top">Frames</a></li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/JadeDisplay.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript">
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#nested.classes.inherited.from.class.javax.swing.JPanel">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="/VICAR-DOCS/vicar/core470/html/javadoc/jpl/mipl/jade/#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">

</a></div>

</body>
</html>

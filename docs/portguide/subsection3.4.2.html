<HEAD>
<TITLE>Data Types</TITLE>
</HEAD>
<BODY><P>
 <A NAME=350 HREF=subsection3.4.1.html><IMG SRC="/icons/previous.png"></A> <A NAME=352 HREF=section3.4.html><IMG SRC="/icons/up.png"></A>  <A NAME=348 HREF=subsection3.4.3.html><IMG SRC="/icons/next.png"></A>  <b>Previous:</b> <A NAME=351 HREF=subsection3.4.1.html>Variable Arguments</A>  <b>Up:</b> <A NAME=353 HREF=section3.4.html>Portability Constraints</A>  <b>Next:</b> <A NAME=349 HREF=subsection3.4.3.html>Language Differences</A> <P>
 <H2>Data Types</H2>
<P>
Different machines have different ways of representing data.  The VAX
represents integers in a 2's complement format with the low-order byte
first (``little endian'').  Most Unix machines represent integers in a
2's complement format with the high-order byte first (``big endian'').
In addition, most Unix machines use IEEE floating-point format, while
the VAX uses its own floating-point format.  The DECstation uses IEEE
format with the bytes reversed.
<P>
All these data representation differences add up to major porting
headaches.  How does an application read a file that was written on a
different machine?  How does an application convert between data types?
Fortunately, most data format conversions during I/O are handled
automatically by the RTL.  However, there are several areas to watch
out for in application programs.  See Section <A HREF=section3.7.html#datatypes><IMG SRC="/icons/cross-ref.png"></A>, Data Types
and Host Representations, for details.  The use of EQUIVALENCE statements
in Fortran code for type conversion is a particular problem; see
Section <A HREF=subsection3.9.3.html#ftnequivtype><IMG SRC="/icons/cross-ref.png"></A>, No EQUIVALENCE for Type Conversion, for details.
<P>

</BODY>
<P><ADDRESS>
<I>rgd059@ipl.jpl.nasa.gov</I>
</ADDRESS>
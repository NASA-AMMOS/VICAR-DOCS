<HEAD>
<TITLE><b> x</b>/<b>  zmove</b></TITLE>
</HEAD>
<BODY><P>
 <A NAME=650 HREF=paragraph3.6.2.3.1.html><IMG SRC="/VICAR-DOCS/icons/previous.png"></A> <A NAME=652 HREF=subsubsection3.6.2.3.html><IMG SRC="/VICAR-DOCS/icons/up.png"></A>  <A NAME=648 HREF=paragraph3.6.2.3.3.html><IMG SRC="/VICAR-DOCS/icons/next.png"></A>  <b>Previous:</b> <A NAME=651 HREF=paragraph3.6.2.3.1.html><b> x</b>/<b>  zlpinfo</b></A>  <b>Up:</b> <A NAME=653 HREF=subsubsection3.6.2.3.html>Miscellaneous Routines</A>  <b>Next:</b> <A NAME=649 HREF=paragraph3.6.2.3.3.html><b> x</b>/<b>  zvcmdout</b></A> <P>
 <H4><b> x</b>/<b>  zmove</b></H4>
<P>
<PRE><TT>
call xmove(from, to, len)
zmove(from, to, len);
</TT></PRE>
<P>
Move bytes from one buffer to another.  Overlapping moves are handled
correctly, unlike the C routine <tt> memcpy()</tt>.
<P>
<b> Arguments:</b>
<UL>
<P>
<LI> FROM: pixel-array, input
<P>
FROM is the buffer to move the bytes from (the source).  It may <em> not</em> be
a Fortran CHARACTER*n variable.
<P>
<LI> TO: pixel-array, input
<P>
TO is the buffer to move the bytes to (the destination).  It may <em> not</em> be
a Fortran CHARACTER*n variable.
<P>
<LI> LEN: integer, input
<P>
The number of bytes to move.  There is no restriction on how many bytes can
be moved, except of course available memory.  Note that LEN is measured in
<em> bytes</em>, not <em> pixels</em>.
<P>
</UL>
<P>

</BODY>
<P><ADDRESS>
<I>rgd059@ipl.jpl.nasa.gov</I>
</ADDRESS>
{\rtf1\mac\ansicpg10000\uc1 \deff0\deflang1033\deflangfe1033{\upr{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fnil\fcharset256\fprq2{\*\panose 020b0604020202020204}Arial;}{\f2\fmodern\fcharset77\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}Symbol;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f5\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica;}{\f6\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Courier;}{\f7\fswiss\fcharset77\fprq2{\*\panose 02000500000000000000}Geneva;}{\f8\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset77\fprq2{\*\panose 00000000000000000000}MS Serif;}{\f11\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset77\fprq2{\*\panose 02000500000000000000}New York;}{\f13\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}System;}{\f14\fnil\fcharset2\fprq2{\*\panose 05020102010804080708}Wingdings;}{\f15\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Roman font face;}{\f16\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Modern font face;}{\f17\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Roman font face;}{\f18\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Modern font face;}{\f19\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Century;}}{\*\ud{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fnil\fcharset256\fprq2{\*\panose 020b0604020202020204}Arial;}{\f2\fmodern\fcharset77\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}Symbol;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f5\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica;}{\f6\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Courier;}{\f7\fswiss\fcharset77\fprq2{\*\panose 02000500000000000000}Geneva;}{\f8\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset77\fprq2{\*\panose 00000000000000000000}MS Serif;}{\f11\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset77\fprq2{\*\panose 02000500000000000000}New York;}{\f13\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}System;}{\f14\fnil\fcharset2\fprq2{\*\panose 05020102010804080708}Wingdings;}{\f15\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Roman font face;}{\f16\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Modern font face;}{\f17\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Roman font face;}{\f18\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Modern font face;}{\f19\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Century;}}}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid \snext0 Normal;}{\s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\adjustright \b\f4\fs36\cgrid \sbasedon0 \snext0 heading 1;}{\s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel0\adjustright \b\f4\fs28\cgrid \sbasedon1 \snext0 heading 2;}{\s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel1\adjustright \b\f4\fs28\cgrid \sbasedon2 \snext0 heading 3;}{\s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel2\adjustright \b\f4\fs28\cgrid \sbasedon3 \snext0 heading 4;}{\s5\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl4\outlinelevel3\adjustright \b\f4\fs28\cgrid \sbasedon4 \snext0 heading 5;}{\s6\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl5\outlinelevel4\adjustright \b\f4\fs28\cgrid \sbasedon5 \snext0 heading 6;}{\s7\li360\sb240\sa60\nowidctlpar\ls1\ilvl6\adjustright \f5\fs20\cgrid \sbasedon0 \snext0 heading 7;}{\s8\li360\sb240\sa60\nowidctlpar\ls1\ilvl7\adjustright \i\f5\fs20\cgrid \sbasedon0 \snext0 heading 8;}{\s9\li360\sb240\sa60\nowidctlpar\ls1\ilvl8\adjustright \i\f5\fs18\cgrid \sbasedon0 \snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\s15\fi360\sa120\nowidctlpar\tx360\tx1728\tx3600\tx4320\tx7200\tx10700\adjustright \f4\fs20\cgrid \sbasedon65 \snext15 dir;}{\s16\fi360\li360\sa120\nowidctlpar\tx720\tx1728\tx3960\tx4320\tx7560\tx10700\adjustright \f4\fs20\cgrid \sbasedon15 \snext16 dir 1;}{\*\cs17 \additive \i \sbasedon10 CITE;}{\*\cs18 \additive \f6\fs20 \sbasedon10 CODE;}{\s19\fi-360\li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext19 Definition Compact;}{\s20\fi-720\li720\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext20 Definition List;}{\*\cs21 \additive \f4\fs24 \sbasedon10 Definition Term;}{\*\cs22 \additive \i\fs24 \sbasedon10 Definition;}{\s23\li360\sb120\sa120\nowidctlpar\tx2880\tx5760\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 Directory;}{\*\cs24 \additive \i \sbasedon10 Emphasis;}{\s25\li360\sb120\sa120\sl-20\slmult0\nowidctlpar\box\brdrsh\brdrs\brdrw15\brdrcf15 \adjustright \shading10000\cfpat8\cbpat8 \f4\fs20\cgrid \sbasedon0 \snext0 Horizontal Rule;}{\*\cs26 \additive \ul\cf2 \sbasedon10 Hypertext;}{\*\cs27 \additive \f6\fs20\ulnone \sbasedon10 Keyboard;}{\s28\fi-360\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlblt\ilvl10\ls2047\pnrnot0\pnf6\pnstart1\pnindent360\pnhang{\pntxtb _}}\ls2047\ilvl10\adjustright \f4\cgrid \sbasedon0 \snext28 List Bullet;}{\*\cs29 \additive \f4 Page Ref;}{\*\cs30 \additive \f6 \sbasedon10 Sample;}{\*\cs31 \additive \strike \sbasedon10 Strikethrough;}{\*\cs32 \additive \b \sbasedon10 Strong;}{\*\cs33 \additive \f6\fs20 \sbasedon10 Typewriter;}{\*\cs34 \additive \i\f4\fs24 \sbasedon10 Variable;}{\s35\fi360\li720\sa120\nowidctlpar\tx1080\tx1728\tx4320\tx7920\tx10700\adjustright \f4\fs20\cgrid \sbasedon16 \snext35 dir 2;}{\s36\fi360\li1080\sa120\nowidctlpar\tx1440\tx1728\tx4680\tx8280\tx10700\adjustright \f4\fs20\cgrid \sbasedon35 \snext36 dir 3;}{\s37\fi360\li1440\sa120\nowidctlpar\tx1728\tx1800\tx5040\tx8640\tx10700\adjustright \f4\fs20\cgrid \sbasedon36 \snext37 dir 4;}{\s38\fi432\li360\sb60\sa120\nowidctlpar\adjustright \f4\fs20\cgrid \sbasedon39 \snext38 Normal Indent Special;}{\s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext39 Normal Indent;}{\s40\qc\li360\sb120\sa360\nowidctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 caption;}{\s41\li360\sb60\sa120\nowidctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext41 Normal Spaced;}{\s42\li360\sb120\sa120\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext42 header;}{\s43\li360\nowidctlpar\brdrt\brdrs\brdrw15 \tx2700\tqc\tx4320\tqr\tx9720\adjustright \b\f4\fs20\cgrid \sbasedon0 \snext43 footer;}{\*\cs44 \additive \sbasedon10 page number;}{\s45\sb120\sa60\nowidctlpar\tqr\tx8640\adjustright \b\f4\fs20\cgrid \sbasedon0 \snext0 toc 1;}{\s46\li245\sa60\nowidctlpar\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 2;}{\s47\li475\sa60\nowidctlpar\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 3;}{\s48\li720\nowidctlpar\tqr\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 4;}{\s49\li960\nowidctlpar\tqr\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 5;}{\s50\li1200\nowidctlpar\tqr\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 6;}{\s51\li1440\nowidctlpar\tqr\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 7;}{\s52\li1680\nowidctlpar\tqr\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 8;}{\s53\li1920\nowidctlpar\tqr\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 9;}{\s54\li360\nowidctlpar\adjustright \i\f4\fs20\cgrid \sbasedon0 \snext54 address;}{\s55\li360\nowidctlpar\adjustright \v\f4\fs40\super\cgrid \sbasedon0 \snext55 anchor;}{\s56\li1440\ri1440\nowidctlpar\adjustright \i\f4\fs20\cgrid \sbasedon0 \snext56 blockquote;}{\s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl10\ls2047\pnrnot0\pnf5\pnstart1\pnindent180\pnhang{\pntxtb _}}\ls2047\ilvl10\adjustright \f4\fs20\cgrid \sbasedon79 \snext57 bullet list;}{\s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl10\ls2047\pnrnot0\pnf5\pnstart1\pnindent360\pnhang{\pntxtb _}}\ls2047\ilvl10\adjustright \f4\fs20\cgrid \sbasedon80 \snext58 bullet list 1;}{\s59\fi-180\li1260\nowidctlpar\tx1260\adjustright \f4\fs20\cgrid \sbasedon81 \snext59 bullet list 2;}{\s60\fi-180\li1620\nowidctlpar\tx1620\adjustright \f4\fs20\cgrid \sbasedon82 \snext60 bullet list 3;}{\s61\fi-180\li1980\nowidctlpar\tx1980\adjustright \f4\fs20\cgrid \sbasedon83 \snext61 bullet list 4;}{\s62\fi-180\li2340\nowidctlpar\tx2340\adjustright \f4\fs20\cgrid \sbasedon84 \snext62 bullet list 5;}{\s63\fi360\li1800\sa120\nowidctlpar\tx1728\tx2160\tx5400\tx10700\adjustright \f4\fs20\cgrid \sbasedon37 \snext63 dir 5;}{\s64\li360\nowidctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext64 footnote text;}{\s65\fi-2520\li2880\sb120\sa120\nowidctlpar\tx1728\adjustright \f4\fs20\cgrid \sbasedon85 \snext65 glossary;}{\s66\fi-2520\li4680\sb120\sa120\nowidctlpar\tx1728\tx4680\adjustright \f4\fs20\cgrid \sbasedon65 \snext66 glossary 1;}{\s67\fi-2520\li5040\sb120\sa120\nowidctlpar\tx1728\tx5040\adjustright \f4\fs20\cgrid \sbasedon66 \snext67 glossary 2;}{\s68\fi-2520\li5400\sb120\sa120\nowidctlpar\tx1728\tx5400\adjustright \f4\fs20\cgrid \sbasedon67 \snext68 glossary 3;}{\s69\fi-2520\li5760\sb120\sa120\nowidctlpar\tx1728\tx5760\adjustright \f4\fs20\cgrid \sbasedon68 \snext69 glossary 4;}{\s70\fi-2520\li6120\sb120\sa120\nowidctlpar\tx1728\tx6120\adjustright \f4\fs20\cgrid \sbasedon69 \snext70 glossary 5;}{\s71\li360\sb120\sa120\nowidctlpar\brdrb\brdrs\brdrw30 \adjustright \f4\fs20\cgrid \sbasedon0 \snext0 hr;}{\s72\li360\nowidctlpar\adjustright \f6\fs20\cgrid \sbasedon0 \snext72 HTML;}{\s73\fi-720\li1080\nowidctlpar\tx1440\adjustright \f4\fs20\cgrid \sbasedon85 \snext73 menu;}{\s74\fi-720\li1440\nowidctlpar\tx1440\adjustright \f4\fs20\cgrid \sbasedon86 \snext74 menu 1;}{\s75\fi-720\li1800\nowidctlpar\tx1800\adjustright \f4\fs20\cgrid \sbasedon87 \snext75 menu 2;}{\s76\fi-900\li2340\nowidctlpar\tx2340\adjustright \f4\fs20\cgrid \sbasedon88 \snext76 menu 3;}{\s77\fi-1080\li2880\nowidctlpar\tx2880\adjustright \f4\fs20\cgrid \sbasedon89 \snext77 menu 4;}{\s78\fi-1260\li3420\nowidctlpar\tx3420\adjustright \f4\fs20\cgrid \sbasedon90 \snext78 menu 5;}{\s79\fi-720\li1080\sb120\sa120\nowidctlpar\tx1440{\*\pn \pnlvlbody\ilvl11\ls2047\pnrnot0\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}\ls2047\ilvl11\adjustright \f4\fs20\cgrid \sbasedon85 \snext79 numbered list;}{\s80\fi-720\li1440\sb120\sa120\nowidctlpar\tx1440\adjustright \f4\fs20\cgrid \sbasedon86 \snext80 numbered list 1;}{\s81\fi-720\li1800\sb120\sa120\nowidctlpar\tx1800\adjustright \f4\fs20\cgrid \sbasedon87 \snext81 numbered list 2;}{\s82\fi-900\li2340\sb120\sa120\nowidctlpar\tx2340\adjustright \f4\fs20\cgrid \sbasedon88 \snext82 numbered list 3;}{\s83\fi-1080\li2880\sb120\sa120\nowidctlpar\tx2880\adjustright \f4\fs20\cgrid \sbasedon89 \snext83 numbered list 4;}{\s84\fi-1260\li3420\sb120\sa120\nowidctlpar\tx3420\adjustright \f4\fs20\cgrid \sbasedon90 \snext84 numbered list 5;}{\s85\fi-720\li1080\sb120\sa120\nowidctlpar\tx1440\adjustright \f4\fs20\cgrid \sbasedon0 \snext85 ol;}{\s86\fi-720\li1440\sb120\sa120\nowidctlpar\tx1440\adjustright \f4\fs20\cgrid \sbasedon85 \snext86 ol 1;}{\s87\fi-720\li1800\sb120\sa120\nowidctlpar\tx1800\adjustright \f4\fs20\cgrid \sbasedon86 \snext87 ol 2;}{\s88\fi-900\li2340\sb120\sa120\nowidctlpar\tx2340\adjustright \f4\fs20\cgrid \sbasedon87 \snext88 ol 3;}{\s89\fi-1080\li2880\sb120\sa120\nowidctlpar\tx2880\adjustright \f4\fs20\cgrid \sbasedon88 \snext89 ol 4;}{\s90\fi-1260\li3420\sb120\sa120\nowidctlpar\tx3420\adjustright \f4\fs20\cgrid \sbasedon89 \snext90 ol 5;}{\*\cs91 \additive \ulnone\nosupersub Plain;}{\s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid \sbasedon0 \snext92 pre;}{\*\cs93 \additive \cf6 Reference;}{\s94\fi-720\li1080\sb120\sa120\nowidctlpar\tx1440{\*\pn \pnlvlbody\ilvl11\ls2047\pnrnot0\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}\ls2047\ilvl11\adjustright \f4\fs20\cgrid \sbasedon79 \snext94 small gloss;}{\s95\fi-720\li1440\sb120\sa120\nowidctlpar\tx1440\adjustright \f4\fs20\cgrid \sbasedon80 \snext95 small gloss 1;}{\s96\fi-720\li1800\sb120\sa120\nowidctlpar\tx1800\adjustright \f4\fs20\cgrid \sbasedon81 \snext96 small gloss 2;}{\s97\fi-900\li2340\sb120\sa120\nowidctlpar\tx2340\adjustright \f4\fs20\cgrid \sbasedon82 \snext97 small gloss 3;}{\s98\fi-1080\li2880\sb120\sa120\nowidctlpar\tx2880\adjustright \f4\fs20\cgrid \sbasedon83 \snext98 small gloss 4;}{\s99\fi-1260\li3420\sb120\sa120\nowidctlpar\tx3420\adjustright \f4\fs20\cgrid \sbasedon84 \snext99 small gloss 5;}{\s100\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl10\ls2047\pnrnot0\pnf5\pnstart1\pnindent180\pnhang{\pntxtb _}}\ls2047\ilvl10\adjustright \f4\fs20\cgrid \sbasedon57 \snext100 ul;}{\s101\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl10\ls2047\pnrnot0\pnf5\pnstart1\pnindent360\pnhang{\pntxtb _}}\ls2047\ilvl10\adjustright \f4\fs20\cgrid \sbasedon58 \snext101 ul 1;}{\s102\fi-180\li1260\nowidctlpar\tx1260\adjustright \f4\fs20\cgrid \sbasedon59 \snext102 ul 2;}{\s103\fi-180\li1620\nowidctlpar\tx1620\adjustright \f4\fs20\cgrid \sbasedon60 \snext103 ul 3;}{\s104\fi-180\li1980\nowidctlpar\tx1980\adjustright \f4\fs20\cgrid \sbasedon61 \snext104 ul 4;}{\s105\fi-1260\li3420\sb120\sa120\nowidctlpar\tx3420\adjustright \f4\fs20\cgrid \sbasedon0 \snext105 ul 5;}{\*\cs106 \additive \f4\fs18\up6 \sbasedon10 footnote reference;}{\s107\fi-400\li400\sb120\sa120\nowidctlpar\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 table of figures;}{\*\cs109 \additive \sbasedon10 Discard;}{\*\cs110 \additive \ul\cf2 \sbasedon26 HTMLRef;}}{\*\listtable{\list\listtemplateid-1{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\s1}{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'03\'00.\'01;}{\levelnumbers\'01\'03;}\s2}{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'05\'00.\'01.\'02;}{\levelnumbers\'01\'03\'05;}\s3}{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'07\'00.\'01.\'02.\'03;}{\levelnumbers\'01\'03\'05\'07;}\s4}{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'09\'00.\'01.\'02.\'03.\'04;}{\levelnumbers\'01\'03\'05\'07\'09;}\s5}{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'0b\'00.\'01.\'02.\'03.\'04.\'05;}{\levelnumbers\'01\'03\'05\'07\'09\'0b;}\s6}{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'0d\'00.\'01.\'02.\'03.\'04.\'05.\'06;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\s7}{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'0f\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\s8}{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace144\levelindent0{\leveltext\'11\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\s9}{\listname ;}\listid-5}{\list\listtemplateid-1\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01*;}{\levelnumbers;}}{\listname ;}\listid-2}}{\*\listoverridetable{\listoverride\listid-5\listoverridecount0\ls1}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent180{\leveltext\'01\u-3913 _;}{\levelnumbers;}\f3\fbias0 \fi-180\li540 }}\ls2}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent360{\leveltext\'01\u-3913 _;}{\levelnumbers;}\f3\fbias0 \fi-360\li1080 }}\ls3}}{\*\revtbl {Unknown;}}{\info{\title Introduction}{\author Larry Bolef}{\operator Larry Bolef}{\creatim\yr1999\mo6\dy5\hr7\min21}{\revtim\yr1999\mo6\dy5\hr7\min21}{\printim\yr1998\mo8\dy25\hr16\min28}{\version2}{\edmins1}{\nofpages160}{\nofwords56483}{\nofchars321955}{\nofcharsws395383}{\vern99}}\margl1080\margr1080\margt2160\margb2160\gutter1440 \facingp\widowctrl\ftnbj\aenddoc\margmirror\hyphcaps0\formshade\viewkind4\viewscale125\pgbrdrhead\pgbrdrfoot \fet0\sectd \linex0\headery1440\footery706\colsx709\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s42\li360\sb120\sa120\nowidctlpar\brdrb\brdrs\brdrw15 \tqr\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst {\cs44  PAGE }}{\fldrslt {\cs44\lang1024 18}}}{\cs44 \tab }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1"\\n \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 1}}}{\cs44     }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 Introduction}}}{\par }}{\headerr \pard\plain \s42\li360\sb120\sa120\nowidctlpar\brdrb\brdrs\brdrw15 \tqr\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst {\cs44  STYLEREF \\n"Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 1}}}{\cs44    }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 Introduction}}}{\cs44 \tab }{\field{\*\fldinst {\cs44  PAGE }}{\fldrslt {\cs44\lang1024 19}}}{\par }}{\*\pnseclvl1\pndec\pnprev1\pnstart1\pnindent360\pnhang{\pntxta .}}{\*\pnseclvl2\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl5\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl6\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl7\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl8\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl9\pndec\pnprev1\pnstart1\pnindent720\pnhang{\pntxta .}}\pard\plain \li360\sb1080\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b\f5\fs32 {\*\bkmkstart Heading1}{\*\bkmkstart _Ref393792705}Multimission Image Processing Laboratory\par }{\b\f5\fs48 VICAR Run-Time Library Reference Manual}{\b\f5\fs32 \par R. Deen\line L. Bolef\par }{\b\f5 Jet Propulsion Laboratory\line }{\f5 California Institute of Technology\line Pasadena, California\par }\pard \li360\sb120\sa120\nowidctlpar\adjustright {\f5 JPL D-4311 Rev B\par }{\b Copyright \u169\'a9 1998, California Institute of Technology. All rights reserved. U.S. Government sponsorship under NASA Contract NAS7-1270 is acknowledged.\par Contact:}{Robert Deen, Robert.G.Deen@jpl.nasa.gov.\par }\trowd \trgaph108\trleft-108 \clvertalt\cltxlrtb \cellx6660\clvertalt\cltxlrtb \cellx8748\pard \sb240\sa120\nowidctlpar\intbl\adjustright {\b\f5 {\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0\picw76\pich64\picwgoal1520\pichgoal1280\macpict\bliptag-731180531\blipupi72{\*\blipuid d46b120d034b7222d3a2f3bded5e7674}fe00000000000040004c001102ff0c00fffe00000048000000480000000000000040004c00000000001a00001d1d7b7b0001000a000000000040004c0081000a000000000000000000a00082001a0000000000000098804c000000000040004c0000000000000000004800000048000000000008000100080000000002a1e0d4000000000000f3b78000006e0000ffffffffffff000100002a2d8c8c0002000028d67a7a000300003ab972720004000031338c8c00050000313294940006000038c27a7a00070000393984840008101039398484000900003a3c8c8c000a000044946262000b00003b3c9494000c0000469f6a6a000d000047b47a7a000e373629296363000f000046478c8c001000004d946a6a001100004e9f72720012bcbc000000000013000046489c9c001400004faa7a7a001500004d4d8484001600004a4b94940017c6c600000000001800004b4c9c9c0019cece00000000001a000049d7a4a4001b000051a97a7a001c403e31317b7b001d00005a5b8484001e17ec49c2729e001f000054548c8c0020d6d6000000000021dede00000000002238ee38ef8bd6002320f049dd8bbc0024acc20ffa53dd002500005b5b9c9c0026e6e6000029fa0027c6c614130000002810105d5d94940029cece08085755002afefd00010001002b42424d4d8484002c9bc820f47ad2002dd6d61d1c0000002e30f159e593d3002f59e449e97adb00305a5952528c8c0031498e5ab1bd7800325a5a666794940033424275759c9c00345a5a6f6f9c9c003583fe6aff93ff003659ff86ffa4ff00379c356ad17af10038bdbd6562393900396b6b8687b5b5003a83827b7ba5a5003bdeb972d5385d003c8bfc940ea534003da5348bfc940e003eb5508bf0a52a003f93fc9c10b54c004083ddb045bd630041deab9c007aad0042e7b893c293c20043adadadada5a500449c02bd56bd560045adadb5b5bdbd0046e7e7a5a5b0af0047c656b524bd3b0048bdbdbdbdb5b50049e7e7b5b5bdbc004aad0cce6ece6e004bc6c6c6c6c6c6004ca5a5d9d9e7e7004dc6c6cececece004ececececedede004fefefc5c4bdbd0050efb7c5fdce210051e7e7cecebdbd0052d6d6d6d6cece0053d634d634e7880054e7e7d6d5bdbd0055d6d6deded6d60056d6d6dededede0057efb0d634ce0c0058dedededed6d60059e792de69ce22005aefa7d61dde49005be77bde49de49005ce77bde49e77b005dd61defa7e77b005eefb0e788ce0c005fe77be77bde490060e7e7e7e7efef0061efefe7e7e7e70062efeff7f7efef0063f7c5e750de0f0064e7e7efefe7e70065f7f7e7e7efef0066f7d3efa6cdf10067f7c5ef8bde0f0068f7f7efefe7e70069f7f7f7f7e7e7006afffff7b8dddd006bfffff7f7efef006cf7f7ffffefef006d00001ce27a7a006e000000000000000000000040004c000000000040004c000006ca62005ded6202b56202b56213e2620459513c3423fe0705062e343f545ee26215e56204593a230916fa0f07130f160f0f083c58e5621ae862045843230f16f90f013a09fe0f070909160f0f084855e86216ea62025e3f09f50f042e090f0f18fa0f02074558ea621feb62015408fd0f0009fc0f011316fb0f02131639fe0f0013fe0f010759eb6221ec620035f80f0009fe0f013362fa0f016c07fe0f06160f0f160f3d58ef620151602dee6202542316fd0f0009fc0f1123050f09340f0f09310f4068625b33181616fe0f03130f0b54f26203612d19622def62015409f80f05130f0f0b452efe0f13130f47070f0962090f130f0f130f0f13090f165ff462045519195a622af062015109fc0f0013fb0f06130f0923390f6cfb0f0439090f0f13fb0f0216160ff56205381919275f6230f1620259160ffd13010f13fe0f011609fe0f0065fe0f0009fe0f010909fc0f0013f90f011f0ff8620058fd190246626227f262015809f80f07396c626c4a080f09fb0f012340fa0f0013f80f011654fb62014320fd19fe6231f362015807fb0f0b13130f623f040909084d6239fd0f05090f0f070f13f80f0809090f180916160955fe620058fb19fd6230f362003afa0f05090f47340909fd0f03093f622efb0f06133409130f1313fd0f0009fb0f04163e626238fb19003bfd622ff462015716f90f0309650909fd0f08340f0f0456560f1309fe0f0347091609f70f05130f0f090d41fa19011765fd6233f4620007fd0f0016fd0f082e450f3939090f0536fd0f0334620f09fe0f02160916fe0f0013fd0f0009fe0f02090d20f819fb6229f56202451616fe0f01130ffe1301343ffd0f042347623f13fe0f010865ef0f020d2617f8190061fb6235f562160f16160f13130f0f130f0f343f0f1309620f09340f1616fe0f093a620f0f160f130f1313fe0f06130f0f090d2617f719f96229f662003ff90f0e130f0f31450f1313090f09050f1609fd0f012e62fb0f0013fd0f02091d2af519f8622bf66204040f160f13fe0f0013fe0f01075cfb0f0013f90f052b620f090f13fd0f020d1f20f519012468f8622df762063a0f0f090f0f09fa0f016805fd0f03090f0f13f90f0662230f0f07031cf819012130fe19022f1134f7622af7620004f40f034d2e0f13f90f0013fe0f07130f07620b1d2427f91902212f2ffe19041e0d160f58f8622df762fe0f0013fd0f0a13130f0f1313314b0f1313f40f030d226217f9190c212b0d2419192110230f0f165ff8623cf8620045fe0f10130f0f13130f0f130f130f0968090f1313fe0f03130f0f13fe0f050d0e21193862fb190a271e0d0c271919270d160ffe160066f8623cf86203320f0f09fc0f0009fe0ffe090f4b340f090905070404050f0909232417fe190a175741193b17240d0d0934fe1902370909fe0f02161634f8623df8620004fd0f0f5c6268626c0b0f0565624508610f0f09fe62046668392f27fd1907496868626b686208fe0f0d2817191950684d16090f0f16160ff8623df8620009fd0f010768fe620b40160f3962160968230f1334fe62016862fc190f6565624124036262090f0d1c17191969fe680216160ffe1601255ff9623df862fe0f17130f0968676762620f0f39670f0f344e0f0d4d5762686268fc190f6562680d0f16324d090d241919176267fe620704160f0f16161f58f9623ff96206670f0f130f0f09fd6216683c16366216090d6c271762296c6662623b1919212f68fe62153416166c02211919246b4d6b6267624a16160f16161ff8623df962015e16fd0f0c09623f626268620936621f2421fe190a6217426862625a24110d16fd621067625c28621919281d620834626b62621ffd16001ff8623af9620f5816130f130f07620f62626762473e62fc19043b62271965fe620509160f0f4768fd620e29194f291b1f32680f166867626201fc16f8623ef962005efe0f0c130f0968133a686668623b6817fd191050572f116262676234160f16163f626862fe190c2969161663620f16626267673ffd16000ff8623cf9620b67160f0f130f09681c2c6568fe6215681719212c1f62626c6b6262676262160f16160f0935fe19086262344a1668686b68fd620068fc16f8623cf862fe0f12230d0d6217193868686268651f100d09046868fe62096862676216130f0f0d21fe190662686216621668fe3f05406262676207fd16f8623df86206150f111f191968fe19fc621e090f0f0939623962160f62686862160f0f62211919245562685e183c586218fe16096c6267624a160f161f58f9623df862190328271919176219220c2362626868230f0f0762621862391662fe68053f0d24171917fd620a5b161609626809160f1669fd6203391f161ff8623df862012d17fe190c65635a2e090f434745453f070ffe3902340f62fc3a1232191917243f62674007160909015b6d010f0ffe0406070505040f0f2ef8623bfa62014b17fe19032b1e0909fd0f0016fc0f02160f40fe0f052e68070f0d0dfe19010f0ffe09fe0f05160f0f233f09fd0f010716fd0f011651f86239fc62016417fe19042b0c0d0f09f40f013909fe0f093f6207231717240d090ffe09020f0f16fe0f0e16620f620f180f2e130f16180f0f67f86232fd6209381719192d6505090f16ed0f064e2d19190f0909fd0f151616130f160f6c2e62090f041609624a28090f161f58f86236fd62fe19075a6262340f0f1609fe0f0009f90f0013fd0f090d1521191739160f1f09f80f0e622340010f620f0f4d2b1a0f0f1634f76235f762006bfd0f005afe0f02096209fb0f0b34230d221919211e3f685609fb0f08130f0f402e0f3f1834fd0f06041f620f161f5ef7622ff6620034fa0f010945f90f0c0d241917240d0f0f45684a0f09fb0f1016230709620340160f0f16450f450f1634f66230f562011313fc0f0031fd0f0009fe0f0014fe1901220dfd0f014d01fd0f0013f90f0b09392e3416182e16160f1668f66235f56202340f09fe0f01054efe0f0b132e0f091c1919260c091616fc0f0013fd0f0009fd0f0d230f0f39040f0440160f4518163af5622cf462020f0f13fd0f0b5c3f1323310d2419190e0d09fd0f0009f50f0d323f160f6213163462390f3f1816f46237f762186062624b0f130f130f0945340f0f0d1719191e0d160f0f2e39fb0f0333230f16fe0f0013fe0f06393f130f04620ffe160063f4622ef362013409fa0f051e1219170a09fd0f05394e160f1313fc0f09094b452e0509074a4b18fe0f04620f160f39f36230f2620009fc0f01091ffe19010d09fd0f0013fe0f013334fe0f0009fe130f160930536261221613130f160f0f161ff26227f1620013fe0f0509231919240dfd0f012339fd0f0309050f13f60ffe180613130f090f166af2623106626b6269626269f7620e0f0f092319192f0c160f0f3f0f233cfe0f044e090f0f09fc0f011309fa0f04130f130f16f06227f0620652092f19192309fd0f015309fc0f003ffc0f08130f0f130f09311618fc0f02161816ef622bef620e3b19191f090f0f094c6c626c4d0913fb0f0013fb0f01072bfe0f06130f130f160f66fc620069f56226f0620b3717192f160f0f130f130f62fa0f0009fc0f0409130f0f13fe0f05131316131616ed6232fb620069fe6202696965fe62083719195a6244090f13fe0f0045fe0f0013fe0f03090f0f13fb0f0313130f18fd0f0045ec6228006bfe620069f7620341191957fd6203050f0f13fd0f0009fe0f0013fa0f0009fa0f0218096beb6226076b626269626c626cfa620327195765fb620005f80f0413160f0f13f90f041316165b69ea6227006bfd62006cf762004ff7620708130f0f130f0f13fe0f03180f1616fe0f0518131804626ce8621e016269f9620269626bf262026c4e08fa0f09161818160f160f09456ce562280262626bfe620069fe62026b626cfe620069f0620a39230409050501343f6b6cfe620269626ce86223fe62076c6c62626c626269fd6202696269f6620069f162006bfe620069fc62006cee620e066962626c62626bfe620069c06200a0008300ff}\cell }\pard \sb480\nowidctlpar\intbl\adjustright {\b\fs56 {\pict{\*\picprop\shplid1026{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0\picw81\pich28\picwgoal1620\pichgoal560\macpict\bliptag1078551245\blipupi72{\*\blipuid 404962cda7be7c58ade2e6944a20fb91}fe0000000000001c0051001102ff0c00fffe0000004800000048000000000000001c005100000000001affffffffffff0001000a00000000001c00510081000a000000000000000000a00082001a0000000000000098805200000000001c00510000000000000000004800000048000000000008000100080000000002a1e2d0000000000000fa7f800000020000ffffffffffff0001fefd00010001000200000000000000000000001c005100000000001c0051000002af000ef100f901fe00ea01fa00f901f0000ef100f901fe00e801fc00f901f0000ef100f901fe00e701fd00f901f0000ef100f901fe00e601fe00f901f0000ef100f901fe00e601fe00f901f0000ff100f901fe00e501010000f901f0000ff100f901fe00e501010000f901f00013f100f901fe00fa01f400f901010000f901f00012f100f901fe00fa01f300f9010000f901f00012f100f901fe00fa01f300f9010000f901f00012f100f901fe00fa01f300f9010000f901f00012f100f901fe00fa01f300f9010000f901f00013f100f901fe00fa01f400f901010000f901f0000ff100f901fe00e501010000f901f00013f100f901fe00fa010000ed01010000f901f00012f100f901fe00fa010000ee01fe00f901f00013f100f901fe00fa01010000ef01fe00f901f00013f100f901fe00fa01010000f001fd00f901f00012f100f901fe00fa01fe00f201fc00f901f00012f100f901fe00fa01fe00f401fa00f901f0000efd00ed01fe00fa01ea00ec01fd000efd00ed01fe00fa01ea00ec01fd000efe00ec01fe00fa01ea00eb01fe000efe00ec01fe00fa01e900ec01fe0010010000eb01fe00fa01e900eb0101000010010000ec01fd00fa01e800ec010100000e0000ec01fc00fa01e700ec01000000a0008300ff}}{\b\f5 \cell }\pard \widctlpar\intbl\adjustright {\b\f5 \row }\pard\plain \s45\sb120\sa60\nowidctlpar\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\page }{\field\fldedit{\*\fldinst { TOC \\o "1-3" }}{\fldrslt {\lang1024 \par }\pard \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright {\lang1024 1.\tab Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201370 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370030000000}}}{\fldrslt {\lang1024 6}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 1.1\tab Document Organization\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201371 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370031000000}}}{\fldrslt {\lang1024 6}}}{\lang1024 \par 1.2\tab Acronym List\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201372 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370032000000}}}{\fldrslt {\lang1024 7}}}{\lang1024 \par 1.3\tab Data Types and Host Representations\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201373 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370033000000}}}{\fldrslt {\lang1024 9}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 1.3.1\tab VICAR File Representations\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201374 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370034000000}}}{\fldrslt {\lang1024 9}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 1.4\tab Data Type Labels\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201375 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370035000000}}}{\fldrslt {\lang1024 10}}}{\lang1024 \par 1.5\tab Pixel Type Declarations\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201376 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370036000000}}}{\fldrslt {\lang1024 13}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 1.5.1\tab Pixel Sizes\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201377 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370037000000}}}{\fldrslt {\lang1024 13}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 1.6\tab Converting Data Types & Hosts\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201378 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370038000000}}}{\fldrslt {\lang1024 14}}}{\lang1024 \par 1.7\tab Using Binary Labels\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201379 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300370039000000}}}{\fldrslt {\lang1024 16}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 1.7.1\tab Separate Host Types\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201380 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380030000000}}}{\fldrslt {\lang1024 17}}}{\lang1024 \par 1.7.2\tab Programming and Binary Labels\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201381 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380031000000}}}{\fldrslt {\lang1024 17}}}{\lang1024 \par 1.7.3\tab Binary Label Types\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201382 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380032000000}}}{\fldrslt {\lang1024 19}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 2.\tab Programming Practice\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201383 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380033000000}}}{\fldrslt {\lang1024 20}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.1\tab General VICAR conventions\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201384 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380034000000}}}{\fldrslt {\lang1024 20}}}{\lang1024 \par 2.2\tab ANSI C\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201385 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380035000000}}}{\fldrslt {\lang1024 22}}}{\lang1024 \par 2.3\tab C Calling Sequence\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201386 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380036000000}}}{\fldrslt {\lang1024 24}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.3.1\tab C Data Types\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201387 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380037000000}}}{\fldrslt {\lang1024 24}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.4\tab FORTRAN Calling Sequence\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201388 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380038000000}}}{\fldrslt {\lang1024 25}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.4.1\tab Character Strings\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201389 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300380039000000}}}{\fldrslt {\lang1024 25}}}{\lang1024 \par 2.4.2\tab FORTRAN Data Types\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201390 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390030000000}}}{\fldrslt {\lang1024 25}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.5\tab Include Files\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201391 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390031000000}}}{\fldrslt {\lang1024 26}}}{\lang1024 \par 2.6\tab Mixing FORTRAN and C\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201392 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390032000000}}}{\fldrslt {\lang1024 28}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.6.1\tab Bridge Routines\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201393 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390033000000}}}{\fldrslt {\lang1024 28}}}{\lang1024 \par 2.6.2\tab Naming Subroutines\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201394 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390034000000}}}{\fldrslt {\lang1024 28}}}{\lang1024 \par 2.6.3\tab Passing Numeric Arguments\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201395 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390035000000}}}{\fldrslt {\lang1024 29}}}{\lang1024 \par 2.6.4\tab Passing Strings\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201396 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390036000000}}}{\fldrslt {\lang1024 30}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.7\tab Writing Portable FORTRAN\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201397 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390037000000}}}{\fldrslt {\lang1024 35}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.7.1\tab RTL Issues\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201398 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390038000000}}}{\fldrslt {\lang1024 36}}}{\lang1024 \par 2.7.2\tab No EQUIVALENCE for Type Conversion\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201399 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003300390039000000}}}{\fldrslt {\lang1024 36}}}{\lang1024 \par 2.7.3\tab CHARACTER*n for Strings\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201400 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300030000000}}}{\fldrslt {\lang1024 36}}}{\lang1024 \par 2.7.4\tab READ & WRITE to Strings\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201401 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300031000000}}}{\fldrslt {\lang1024 37}}}{\lang1024 \par 2.7.5\tab VMS FORTRAN Extensions\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201402 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300032000000}}}{\fldrslt {\lang1024 38}}}{\lang1024 \par 2.7.6\tab VMS-Specific Code\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201403 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300033000000}}}{\fldrslt {\lang1024 39}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 2.8\tab Portable TAE Command Language (TCL)\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201404 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300034000000}}}{\fldrslt {\lang1024 42}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 3.\tab Image I/O\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201405 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300035000000}}}{\fldrslt {\lang1024 44}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 3.1\tab Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201406 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300036000000}}}{\fldrslt {\lang1024 44}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 3.1.1\tab Unix filename expansion\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201407 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300037000000}}}{\fldrslt {\lang1024 44}}}{\lang1024 \par 3.1.2\tab Temporary files\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201408 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300038000000}}}{\fldrslt {\lang1024 44}}}{\lang1024 \par 3.1.3\tab Filename Expansions\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201409 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400300039000000}}}{\fldrslt {\lang1024 45}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 3.2\tab Image I/O API\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201410 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310030000000}}}{\fldrslt {\lang1024 45}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 3.2.1\tab x/zvadd\emdash Add information to control block\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201411 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310031000000}}}{\fldrslt {\lang1024 46}}}{\lang1024 \par 3.2.2\tab x/zvclose\emdash Close a file\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201412 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310032000000}}}{\fldrslt {\lang1024 53}}}{\lang1024 \par 3.2.3\tab x/zveaction\emdash Set the default error handling action\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201413 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310033000000}}}{\fldrslt {\lang1024 54}}}{\lang1024 \par 3.2.4\tab x/zvget\emdash Retrieve control block information\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201414 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310034000000}}}{\fldrslt {\lang1024 54}}}{\lang1024 \par 3.2.5\tab x/zvopen\emdash Open a file\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201415 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310035000000}}}{\fldrslt {\lang1024 59}}}{\lang1024 \par 3.2.6\tab x/zvread\emdash Read a line\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201416 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310036000000}}}{\fldrslt {\lang1024 67}}}{\lang1024 \par 3.2.7\tab x/zvsignal\emdash Signal an error\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201417 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310037000000}}}{\fldrslt {\lang1024 69}}}{\lang1024 \par 3.2.8\tab x/zvunit\emdash Assign a unit number to a file\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201418 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310038000000}}}{\fldrslt {\lang1024 69}}}{\lang1024 \par 3.2.9\tab x/zvwrit\emdash Write an image line\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201419 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400310039000000}}}{\fldrslt {\lang1024 70}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 4.\tab Label I/O\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201420 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320030000000}}}{\fldrslt {\lang1024 71}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 4.1\tab Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201421 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320031000000}}}{\fldrslt {\lang1024 71}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 4.1.1\tab A Label Model\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201422 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320032000000}}}{\fldrslt {\lang1024 71}}}{\lang1024 \par 4.1.2\tab Property Labels\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201423 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320033000000}}}{\fldrslt {\lang1024 73}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 4.2\tab Image Label Access API\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201424 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320034000000}}}{\fldrslt {\lang1024 75}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 4.2.1\tab x/zladd\emdash Add information to an existing label item\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201425 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320035000000}}}{\fldrslt {\lang1024 75}}}{\lang1024 \par 4.2.2\tab x/zldel\emdash Remove a label item\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201426 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320036000000}}}{\fldrslt {\lang1024 78}}}{\lang1024 \par 4.2.3\tab x/zlget\emdash Return the value of a label item\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201427 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320037000000}}}{\fldrslt {\lang1024 80}}}{\lang1024 \par 4.2.4\tab x/zlhinfo\emdash Return history label information\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201428 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320038000000}}}{\fldrslt {\lang1024 82}}}{\lang1024 \par 4.2.5\tab x/zlinfo\emdash Return information about a single label item\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201429 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400320039000000}}}{\fldrslt {\lang1024 84}}}{\lang1024 \par 4.2.6\tab x/zlninfo\emdash Return name of next key\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201430 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330030000000}}}{\fldrslt {\lang1024 86}}}{\lang1024 \par 4.2.7\tab x/zlpinfo\emdash Returns the names of property subsets in the given file\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201431 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330031000000}}}{\fldrslt {\lang1024 87}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 5.\tab Parameter I/O\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201432 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330032000000}}}{\fldrslt {\lang1024 89}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 5.1\tab Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201433 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330033000000}}}{\fldrslt {\lang1024 89}}}{\lang1024 \par 5.2\tab Parameter I/O API\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201434 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330034000000}}}{\fldrslt {\lang1024 89}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 5.2.1\tab x/zvintract\emdash Prompt user for interactive command\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201435 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330035000000}}}{\fldrslt {\lang1024 89}}}{\lang1024 \par 5.2.2\tab x/zviparm\emdash Return interactive parameter values\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201436 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330036000000}}}{\fldrslt {\lang1024 90}}}{\lang1024 \par 5.2.3\tab x/zvip\emdash Interactive version of x/zvp; abbreviated version of x/zviparm\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201437 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330037000000}}}{\fldrslt {\lang1024 91}}}{\lang1024 \par 5.2.4\tab x/zviparmd\emdash Interactive version of x/zvparmd\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201438 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330038000000}}}{\fldrslt {\lang1024 92}}}{\lang1024 \par 5.2.5\tab x/zvipcnt\emdash Return the count of a parameter.\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201439 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400330039000000}}}{\fldrslt {\lang1024 93}}}{\lang1024 \par 5.2.6\tab x/zvipone\emdash Interactive version of x/zvpone\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201440 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340030000000}}}{\fldrslt {\lang1024 93}}}{\lang1024 \par 5.2.7\tab x/zvipstat\emdash Interactive version of x/zvpstat\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201441 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340031000000}}}{\fldrslt {\lang1024 94}}}{\lang1024 \par 5.2.8\tab x/zviptst\emdash Interactive version of x/zvptst\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201442 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340032000000}}}{\fldrslt {\lang1024 95}}}{\lang1024 \par 5.2.9\tab x/zvp\emdash Abbreviated version of x/zvparm\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201443 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340033000000}}}{\fldrslt {\lang1024 95}}}{\lang1024 \par 5.2.10\tab x/zvparm\emdash Return a parameter value\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201444 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340034000000}}}{\fldrslt {\lang1024 96}}}{\lang1024 \par 5.2.11\tab x/zvparmd\emdash Double-precision version of x/zvparm\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201445 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340035000000}}}{\fldrslt {\lang1024 98}}}{\lang1024 \par 5.2.12\tab x/zvpcnt\emdash Return the count of a parameter.\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201446 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340036000000}}}{\fldrslt {\lang1024 99}}}{\lang1024 \par 5.2.13\tab x/zvpone\emdash Single value from a multivalued parameter\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201447 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340037000000}}}{\fldrslt {\lang1024 99}}}{\lang1024 \par 5.2.14\tab x/zvpstat\emdash Information about a parameter\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201448 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340038000000}}}{\fldrslt {\lang1024 100}}}{\lang1024 \par 5.2.15\tab x/zvptst Indicate whether key word was specified\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201449 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400340039000000}}}{\fldrslt {\lang1024 100}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 5.3\tab Examples\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201450 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350030000000}}}{\fldrslt {\lang1024 101}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 6.\tab Translation Routines\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201451 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350031000000}}}{\fldrslt {\lang1024 102}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 6.1\tab Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201452 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350032000000}}}{\fldrslt {\lang1024 102}}}{\lang1024 \par 6.2\tab Translation API\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201453 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350033000000}}}{\fldrslt {\lang1024 102}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 6.2.1\tab x/zvhost\emdash Integer and real data representations of a host given the host type name\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201454 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350034000000}}}{\fldrslt {\lang1024 102}}}{\lang1024 \par 6.2.2\tab x/zvpixsize\emdash Size of a pixel in bytes given the data type and host representation\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201455 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350035000000}}}{\fldrslt {\lang1024 104}}}{\lang1024 \par 6.2.3\tab x/zvpixsizeb\emdash Size of a binary label value in bytes from a file\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201456 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350036000000}}}{\fldrslt {\lang1024 104}}}{\lang1024 \par 6.2.4\tab x/zvpixsizeu\emdash Size of a pixel in bytes from a file\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201457 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350037000000}}}{\fldrslt {\lang1024 105}}}{\lang1024 \par 6.2.5\tab x/zvtrans\emdash Translate pixels from one format to another\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201458 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350038000000}}}{\fldrslt {\lang1024 105}}}{\lang1024 \par 6.2.6\tab x/zvtrans_in\emdash Create translation buffer for input\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201459 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400350039000000}}}{\fldrslt {\lang1024 106}}}{\lang1024 \par 6.2.7\tab x/zvtrans_inb\emdash Create translation buffer for input from binary labels of a file\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201460 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360030000000}}}{\fldrslt {\lang1024 107}}}{\lang1024 \par 6.2.8\tab x/zvtrans_inu\emdash Create translation buffer for input from a file\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201461 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360031000000}}}{\fldrslt {\lang1024 108}}}{\lang1024 \par 6.2.9\tab x/zvtrans_out\emdash Create translation buffer for output\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201462 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360032000000}}}{\fldrslt {\lang1024 109}}}{\lang1024 \par 6.2.10\tab x/zvtrans_set\emdash Create translation buffer for data types only\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201463 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360033000000}}}{\fldrslt {\lang1024 110}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 7.\tab FORTRAN String Conversion Routines\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201464 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360034000000}}}{\fldrslt {\lang1024 111}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 7.1\tab Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201465 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360035000000}}}{\fldrslt {\lang1024 111}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 7.1.1\tab Common Features: Rules and arguments common to all string routines\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201466 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360036000000}}}{\fldrslt {\lang1024 111}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 7.2\tab String Conversion API\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201467 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360037000000}}}{\fldrslt {\lang1024 113}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 7.2.1\tab sc2for\emdash C null-terminated string to an output FORTRAN string\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201468 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360038000000}}}{\fldrslt {\lang1024 114}}}{\lang1024 \par 7.2.2\tab sc2for_array\emdash C null-terminated array of strings to FORTRAN string array\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201469 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400360039000000}}}{\fldrslt {\lang1024 114}}}{\lang1024 \par 7.2.3\tab sfor2c\emdash FORTRAN input string to a standard C null-terminated string\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201470 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370030000000}}}{\fldrslt {\lang1024 115}}}{\lang1024 \par 7.2.4\tab sfor2c_array\emdash FORTRAN string array to C null-terminated array of strings\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201471 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370031000000}}}{\fldrslt {\lang1024 115}}}{\lang1024 \par 7.2.5\tab sfor2len\emdash Length of a FORTRAN string\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201472 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370032000000}}}{\fldrslt {\lang1024 116}}}{\lang1024 \par 7.2.6\tab sfor2ptr\emdash Pointer to actual characters in FORTRAN string\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201473 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370033000000}}}{\fldrslt {\lang1024 117}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 8.\tab Utility Routines\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201474 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370034000000}}}{\fldrslt {\lang1024 117}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 8.1\tab Introduction\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201475 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370035000000}}}{\fldrslt {\lang1024 117}}}{\lang1024 \par 8.2\tab Utility API\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201476 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370036000000}}}{\fldrslt {\lang1024 117}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 8.2.1\tab abend/zabend\emdash Terminate processing abnormally\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201477 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370037000000}}}{\fldrslt {\lang1024 118}}}{\lang1024 \par 8.2.2\tab x/zmove\emdash Move bytes from one buffer to another\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201478 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370038000000}}}{\fldrslt {\lang1024 118}}}{\lang1024 \par 8.2.3\tab x/zvbands\emdash Return band usage information\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201479 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400370039000000}}}{\fldrslt {\lang1024 118}}}{\lang1024 \par 8.2.4\tab x/zvcmdout\emdash Sends a command string to TAE to be executed\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201480 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380030000000}}}{\fldrslt {\lang1024 119}}}{\lang1024 \par 8.2.5\tab x/zvcommand\emdash Execute a VICAR command string\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201481 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380031000000}}}{\fldrslt {\lang1024 119}}}{\lang1024 \par 8.2.6\tab x/zvfilename\emdash Returns a filename suitable for use with a system open() call\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201482 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380032000000}}}{\fldrslt {\lang1024 120}}}{\lang1024 \par 8.2.7\tab x/zvfilpos\emdash Return the current tape position\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201483 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380033000000}}}{\fldrslt {\lang1024 121}}}{\lang1024 \par 8.2.8\tab x/zvmessage\emdash Log a user message\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201484 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380034000000}}}{\fldrslt {\lang1024 121}}}{\lang1024 \par 8.2.9\tab x/zvselpi\emdash Selects the file to use as the primary input\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201485 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380035000000}}}{\fldrslt {\lang1024 122}}}{\lang1024 \par 8.2.10\tab x/zvselpiu\emdash Selects the file to use as primary input\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201486 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380036000000}}}{\fldrslt {\lang1024 122}}}{\lang1024 \par 8.2.11\tab x/zvsize\emdash Return image size values\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201487 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380037000000}}}{\fldrslt {\lang1024 123}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx475\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 9.\tab Appendix A: Summary of Calling Sequences\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201488 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380038000000}}}{\fldrslt {\lang1024 124}}}{\lang1024 \par }\pard \s45\sb120\sa60\nowidctlpar\tx720\tqr\tx8640\adjustright {\lang1024 10.\tab Appendix B: Error Messages\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201489 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400380039000000}}}{\fldrslt {\lang1024 139}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 10.1\tab Error message format\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201490 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390030000000}}}{\fldrslt {\lang1024 139}}}{\lang1024 \par 10.2\tab Messages by key\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201491 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390031000000}}}{\fldrslt {\lang1024 139}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx720\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 11.\tab Appendix C: Deprecated and Obsolete Subroutines\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201492 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390032000000}}}{\fldrslt {\lang1024 150}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 11.1\tab qprint/zqprint\emdash (Obsolete) Print a message to the terminal\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201493 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390033000000}}}{\fldrslt {\lang1024 151}}}{\lang1024 \par 11.2\tab vic1lab\emdash (Obsolete) Return IBM VICAR72 byte labels in a\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201494 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390034000000}}}{\fldrslt {\lang1024 151}}}{\lang1024 \par 11.2\tab buffer x/zvpblk\emdash Return the address of the parameter block. FOR SPECIAL APPLICATIONS ONLY.\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201495 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390035000000}}}{\fldrslt {\lang1024 152}}}{\lang1024 \par 11.3\tab x/zlgetlabel\emdash (Obsolete) Read labels into local memory\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201496 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390036000000}}}{\fldrslt {\lang1024 152}}}{\lang1024 \par 11.4\tab x/zvend\emdash (Do Not Use) Terminate processing\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201497 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390037000000}}}{\fldrslt {\lang1024 153}}}{\lang1024 \par 11.5\tab x/zvpclose\emdash Close parameter data set NOT RECOMMENDED\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201498 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390038000000}}}{\fldrslt {\lang1024 153}}}{\lang1024 \par 11.6\tab x/zvpopen\emdash Open a parameter data set for output. NOT RECOMMENDED\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201499 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003400390039000000}}}{\fldrslt {\lang1024 154}}}{\lang1024 \par 11.7\tab x/zvpout\emdash Write parameter to parameter file. NOT RECOMMENDED.\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201500 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300030000000}}}{\fldrslt {\lang1024 154}}}{\lang1024 \par 11.8\tab x/zvsfile\emdash Skip files on a tape. USE x/zvadd INSTEAD.\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201501 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300031000000}}}{\fldrslt {\lang1024 155}}}{\lang1024 \par 11.9\tab x/zvsptr\emdash String parameter processing subroutine.\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201502 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300032000000}}}{\fldrslt {\lang1024 156}}}{\lang1024 \par }\pard \s46\li245\sa60\nowidctlpar\tx1200\tqr\tldot\tx8640\adjustright {\lang1024 11.10\tab x/zvtpinfo\emdash Return tape drive information\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201503 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300033000000}}}{\fldrslt {\lang1024 156}}}{\lang1024 \par 11.11\tab x/zvtpmode\emdash Indicate whether an image file is on tape\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201504 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300034000000}}}{\fldrslt {\lang1024 157}}}{\lang1024 \par 11.12\tab x/zvtpset\emdash Set tape drive position globals\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201505 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300035000000}}}{\fldrslt {\lang1024 157}}}{\lang1024 \par }\pard\plain \s45\sb120\sa60\nowidctlpar\tx720\tqr\tx8640\adjustright \b\f4\fs20\cgrid {\lang1024 12.\tab Apprendix D: Unavailable Optional Arguments\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201506 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300036000000}}}{\fldrslt {\lang1024 158}}}{\lang1024 \par 13.\tab Appendix E: About This Document\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201507 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300037000000}}}{\fldrslt {\lang1024 159}}}{\lang1024 \par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 13.1\tab Document Source\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201508 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300038000000}}}{\fldrslt {\lang1024 159}}}{\lang1024 \par 13.2\tab Generating HTML Version\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201509 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500300039000000}}}{\fldrslt {\lang1024 159}}}{\lang1024 \par 13.3\tab Changing or Adding to this Document\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201510 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500310030000000}}}{\fldrslt {\lang1024 159}}}{\lang1024 \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\lang1024 13.3.1\tab Styles used in this Document\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201511 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500310031000000}}}{\fldrslt {\lang1024 159}}}{\lang1024 \par 13.3.2\tab Formatting Hints and Kinks\tab }{\field{\*\fldinst {\lang1024  PAGEREF _Toc453201512 \\h }{\lang1024 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400350033003200300031003500310032000000}}}{\fldrslt {\lang1024 160}}}{\lang1024 \par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid }}\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\sect }\sectd \linex0\headery1440\footery706\colsx709\endnhere\sectdefaultcl {\*\bkmkstart Heading14}{\*\bkmkstart _Toc425047479}{\*\bkmkstart _Toc425048034}{\*\bkmkstart _Toc425750558}{\*\bkmkstart _Toc453201370}{\*\bkmkend Heading1}{\*\bkmkend _Ref393792705}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 1.\tab}\pard\plain \s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Introduction{\*\bkmkend _Toc425047479}{\*\bkmkend _Toc425048034}{\*\bkmkend _Toc425750558}{\*\bkmkend _Toc453201370} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This manual is an introduction to writing software using the VICAR image processing executive and a reference manual for the experienced VICAR programmer. Coding examples are in FORTRAN and C; a knowledge of at least one of these languages is assumed. This manual should be used with \ldblquote The VICAR User's Guide\rdblquote :}{\cs26\ul\cf2  http://www\_mipl.jpl.nasa.gov/PAG/public/vug/vugfinal.html}{ and the \ldblquote VICAR Addendum to the TAE User's Reference Manual\rdblquote . \par {\*\bkmkstart Heading2}{\*\bkmkstart _Toc425047480}{\*\bkmkstart _Toc425048035}{\*\bkmkstart _Toc425750559}Before changing or editing this manual, please see }{\field{\*\fldinst { REF _Ref428698875 \\n  \\* MERGEFORMAT }}{\fldrslt {13}}}{ }{\field{\*\fldinst { REF _Ref428698880 \\* MERGEFORMAT }}{\fldrslt {Appendix E: About This Document}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref428698881 }}{\fldrslt {\cs109\lang1024 160}}}{\cs109 )}{.\par {\*\bkmkstart _Toc453201371}{\*\bkmkend Heading2}{\*\bkmkend _Toc425047480}{\*\bkmkend _Toc425048035}{\*\bkmkend _Toc425750559}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.1\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Document Organization{\*\bkmkend _Toc453201371} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The VICAR RTL (Run-Time Library) is a collection of subroutines for writing image processing software. We divide these subroutines into six packages, each of which is described in its own section: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid { }{\field{\*\fldinst { REF _Ref396007946 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f005200650066003300390036003000300037003900340036000000}}}{\fldrslt {I{\*\bkmkstart _Hlt453167810}m{\*\bkmkstart _Hlt453168305}{\*\bkmkend _Hlt453167810}a{\*\bkmkend _Hlt453168305}ge I/O}}}{\b :}{ A set of subroutines to allow the input and output of image data to image files}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref396008052 }}{\fldrslt {\cs109\lang1024 45}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright { }{\field{\*\fldinst { REF _Ref452624269 \\h }}{\fldrslt {Label I/O}}}{: A set of subroutines allowing access to information stored in the \ldblquote VICAR label\rdblquote . The VICAR label contains both information about the file and user supplied information}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref452624305  \\* MERGEFORMAT }}{\fldrslt {\cs109\lang1024 72}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright { }{\field{\*\fldinst { REF _Ref425588639 \\h }}{\fldrslt {Parameter I/O}}}{\b :}{ A set of subroutines which allow access to user supplied parameters, from both the command line and from files}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref396008129 \\* MERGEFORMAT }}{\fldrslt {\cs109\lang1024 90}}}{\cs109 )}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright { }{\field{\*\fldinst { REF _Ref394140865  \\h }}{\fldrslt {Translation Routines}}}{\b :}{ Subroutines to translate pixel formats}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref394140865 }{ \\* MERGEFORMAT}{\cs109  }{\cs109 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f005200650066003300390034003100340030003800360035000000}}}{\fldrslt {\cs109\lang1024 103}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright { }{\field{\*\fldinst { REF _Ref396018425 \\h }}{\fldrslt {FORTRAN String Conversion Routines}}}{\b :}{ Subroutines to convert from and to differing string representations}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref396018463 }}{\fldrslt {\cs109\lang1024 112}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright { }{\field{\*\fldinst { REF _Ref396017873 \\h }}{\fldrslt {Utility Routines}}}{\b :}{ Miscellaneous subroutines for terminal I/O, program termination, etc.}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref396017955 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 ).}{ \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {VICAR data formats are first discussed in detail to provide the basic knowledge needed. Next is an introduction to programming under VICAR. This includes general information, argument passing conventions and how to write your first program under VICAR. \par Succeeding sections cover the six subroutine packages listed above, describing each subroutine call in detail. Subroutine descriptions are followed by notes on using the VICAR run-time library and examples of use. An appendix contains detailed descriptions of all the error messages and status codes from run-time library calls. \par The VICAR Virtual Raster Display Interface (VRDI) provides device independent access to display devices. Use of the VRDI is deprecated and should not be used for new code It is described in a separate manual: \ldblquote MIPL Virtual Raster Display Interface User's Reference Guide, JPL D-5100\rdblquote , available in TeX dvi form:\~}{\cs26\ul\cf2 http://www\_mipl.jpl.nasa.gov/vrdi/vrdi.dvi}{. \par {\*\bkmkstart Heading4}{\*\bkmkstart _Toc425047482}{\*\bkmkstart _Toc425048037}{\*\bkmkstart _Toc425750561}{\*\bkmkstart _Toc453201372}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.2\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Acronym List{\*\bkmkend Heading4}{\*\bkmkend _Toc425047482}{\*\bkmkend _Toc425048037}{\*\bkmkend _Toc425750561}{\*\bkmkend _Toc453201372} \par }\pard\plain \s65\fi-2520\li2880\sb120\sa120\nowidctlpar\tx1728\adjustright \f4\fs20\cgrid {ANSI\tab American National Standards Institute \par API\tab Application Programming Interface \par ASCII\tab American Standard Code for Information Interchange \par AST\tab Asynchronous System Trap \par BIL\tab Band Interleaved by Line \par BIP\tab Band Interleaved by Pixel \par BSQ\tab Band SeQuential \par CMS\tab Code Management System \par DEC\tab Digital Equipment Corporation \par FEI\tab File Exchange Interface \par FITS\tab Flexible Image Transport System \par FORTRAN \tab FORmula TRANslator \par FPS\tab Floating Point Systems \par GUI\tab Graphical User Interface \par HP\tab Hewlett-Packard \par HRSC\tab High Resolution Stereo Camera \par HTML\tab HyperText Markup Language \par HW\tab HRSC/WAOSS \par IBIS\tab Image Based Information System \par IBM\tab International Business Machines \par IEEE\tab Institute for Electrical and Electronic Engineers \par I/O\tab  Input/Output \par JPEG\tab Joint Photographic Experts Group \par JPL\tab Jet Propulsion Laboratory \par K&R\tab Kernighan and Ritchie \par MDMS\tab Multimission Data Management Subsystem \par MIDR\tab Mosaicked Image Data Record \par MIPL\tab Multimission Image Processing Laboratory \par MIPS\tab Multimission Image Processing Subsystem \par MSTP\tab Multimission Software Transition Project \par NBB\tab Number of Bytes of Binary (prefix) \par NFS\tab Network File System \par NIMS\tab Near Infrared Mapping Spectrometer \par NLB\tab Number of Lines of binary (header) \par PCA\tab Performance and Coverage Analyzer \par PDS\tab Planetary Data System \par PVM\tab Parallel Virtual Machine \par QIO\tab Queue Input/Output \par RDM\tab Report Display Manager \par RISC\tab Reduced Instruction Set Computer \par RMS\tab Record Management Services \par RPC\tab Remote Procedure Call \par RTL\tab Run-Time Library (specific to VICAR in this document) \par SAGE\tab Science Analysis Graphical Environment\par SPARC\tab Scaleable Processor ARChitecture. Informally, a RISC microprocessor chip.\par SPICE\tab Spacecraft, Planet, Instrument, C-matric, Events, a navigation tool, see:\~}{\cs26\ul\cf2 http://pds.jpl.nasa.gov/naif.html}{\par SUBLIB\tab SUBroutine LIBrary (of VICAR) \par TAE\tab Transportable Applications Environment \par TBD\tab To Be Determined \par TCL\tab TAE Command Language \par VAX/VMS\tab Virtual Address eXtension/Virtual Memory System, a minicomputer operating system. \par VFC\tab Vector Function Chainer \par VICAR\tab Video Information Communication And Retrieval \par VIDS\tab VICAR Interactive Display Subsystem \par VRDI\tab Virtual Raster Display Interface \par WAOSS\tab Wide Angle Optoelectronic Stereo Scanner \par WWW\tab World-Wide Web \par {\*\bkmkstart Heading5}{\*\bkmkstart _Toc425047483}{\*\bkmkstart _Toc425048038}{\*\bkmkstart _Toc425750562}{\*\bkmkstart _Toc453201373}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.3\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Data Types and Host Representations{\*\bkmkend Heading5}{\*\bkmkend _Toc425047483}{\*\bkmkend _Toc425048038}{\*\bkmkend _Toc425750562}{\*\bkmkend _Toc453201373} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Different host computers have different ways of representing data internally. Some machines are \ldblquote big-endian\rdblquote , meaning the high-order byte of an integer is stored first in memory, while others are \ldblquote little-endian\rdblquote , meaning the low-order byte is stored first .\par Data that are to be transferred between these machines must be byte-swapped. Most machines use the IEEE floating point standard, but DIGITAL VAXes and Alphas running the VMS operating system have their own standard. Some of the IEEE-format machines are byte-swapped relative to each other. Data transferred between these machines must be converted as well. \par {\*\bkmkstart Heading6}{\*\bkmkstart _Toc425047484}{\*\bkmkstart _Toc425048039}{\*\bkmkstart _Toc425329671}{\*\bkmkstart _Toc425750563}{\*\bkmkstart _Toc453201374}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.3.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {VICAR File Representations{\*\bkmkend Heading6}{\*\bkmkend _Toc425047484}{\*\bkmkend _Toc425048039}{\*\bkmkend _Toc425329671}{\*\bkmkend _Toc425750563}{\*\bkmkend _Toc453201374} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Conversion among hosts would be greatly simplified if all data were stored in ASCII instead of binary. However, that is inefficient in both time and space for image data. Image data must be stored in a binary representation. The question is, which one?\par A standard, canonical representation could be chosen, such as Sun format: big-endian, IEEE floating point. That would simplify the file format, but would lead to inefficient operation on other machines with different formats. Doing processing locally on a VAX, every pixel would be converted to Sun format every time it got read in or written out for every processing step. There wouldn't be enough coffee in the world to keep you awake while waiting. Due to the huge quantity of existing images written in VAX format, the canonical representation would have to be VAX format, which is not desirable in the long run. \par Since most processing is done locally on one machine, and transfers between machine architectures are comparatively less frequent, the solution is to use the native format of whatever machine you are running on, and to identify that machine in the image label. That way, local operations are done efficiently, and conversion is done only when switching machines. \par Applications }{\i must}{ be able to do data format translations automatically. In order to ease the burden, the following conventions have been adopted:\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {Applications shall be able to read files from any host representation. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Applications shall normally write files in the native host representation of the machine on which they are currently running. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Placing the burden only on reading greatly simplifies the writing, while still insuring that the translations will take place in all cases. Some special-purpose applications may choose to write in a non-native format on occasion; however, }{\i all applications must be able to read all formats, without exception}{. \par The Run-Time Library relieves most of this burden. When the standard I/O routines are called (}{\b x/zvread}{ and }{\b x/zvwrit}{), the translations as stated above are performed automatically for the image data. The application merely calls }{\b x/zvread}{ and it receives the data in the native format, ready for processing. It calls }{\b x/zvwrit}{, and the data is written out in the native format (which is what the buffer is in). \par There are three cases where applications will have to do their own conversion:\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {Binary labels: both headers and prefixes must be converted. See }{\field{\*\fldinst { REF Heading10 \\* MERGEFORMAT }}{\fldrslt {Using Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading10 }}{\fldrslt {\cs109\lang1024 16}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Array I/O: Any program using Array I/O will get the data as it exists in the file, without any translation. Applications using Array I/O are responsible for doing their own data format translations on the data they read.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Convert OFF: It is possible for an application to turn off the RTL's automatic conversion. This should not normally be done, but is available for special cases. If this option is selected, the application must do its own translation. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The }{\b x/zvtrans}{ family of RTL routines are used to translate. Do }{\i not}{ attempt to write your own data format conversion routines, even if you think it's only byte-swapping. Although at the present time byte-swapping is the only integer conversion, this may not always be the case. Other integer representations exist, such as one's-complement and sign-magnitude, that can not be translated by a simple byte swap. By having only one set of conversion routines, porting to a new platform with a different data format is easier. }{\b x/zvtrans}{ translations are standardized, and thoroughly debugged. They are coded to be efficient, especially for simple byte-swapping. \par {\*\bkmkstart Heading7}{\*\bkmkstart _Toc425047485}{\*\bkmkstart _Toc425048040}{\*\bkmkstart _Toc425750564}{\*\bkmkstart _Toc453201375}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.4\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Data Type Labels{\*\bkmkend Heading7}{\*\bkmkend _Toc425047485}{\*\bkmkend _Toc425048040}{\*\bkmkend _Toc425750564}{\*\bkmkend _Toc453201375} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {VICAR uses system label items to keep track of the machine type the file (both image and binary label) was written on. These label items are summarized below. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b HOST, string}{: The type of computer used to generate the image. It is used only for documentation; the RTL uses the INTFMT and REALFMT label items to determine the presentation of the pixels in the file. Nevertheless, HOST should be kept consistent with INTFMT and REALFMT. \line See }{\field{\*\fldinst { REF _Ref393618344 \\* MERGEFORMAT }}{\fldrslt {Table 1: Valid VICAR HOST Labels and Machine Types}}}{ for a list of the currently valid host labels and the machine types they represent. New values for HOST will appear every time the RTL is ported to a new machine, so the table is not necessarily a complete list. Programs should not be surprised by values other than those in }{\field{\*\fldinst { REF _Ref393618344 \\* MERGEFORMAT }}{\fldrslt {Table 1: Valid VICAR HOST Labels and Machine Types}}}{ appearing in the label.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid { \par }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\b\f6 HOST label \cell Description of host machine \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\b\f6 \row }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 ALLIANT * \cell Alliant FX series computer \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 AXP-LINUX *\cell DIGITAL Alpha running Linux\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 AXP-UNIX *\cell DIGITAL Alpha running Unix (OSF/1)\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 AXP-VMS \cell DIGITAL Alpha running VMS \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 CRAY * \cell Cray (port is incomplete) \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 DECSTATN * \cell DECstation (any DEC MIPS-based RISC machine) running Ultrix \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 HP-700 \cell HP 9000 Series 700 workstation \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 MAC-AUX * \cell Macintosh running A/UX \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 MAC-MPW * \cell Macintosh running native mode with Mac Programmers Workbench \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 SGI \cell Silicon Graphics workstation \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 SUN-SOLR \cell Sun SPARC machine running Solaris 2 \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 SUN-3 * \cell Sun 3, any model \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 SUN-4 \u8224\'a0\cell Sun 4, SPARCstation, or Sun clone running SunOS \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 TEK * \cell Tektronix workstation \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 VAX-VMS \u8224\'a0\cell DIGITAL VAX running VMS \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 X86-LINUX\cell Intel x86 machine running Linux\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keep\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 X86-SOLR * \cell Intel x86 machine running Solaris 2 \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard \li360\sb120\sa120\keepn\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 * Host machine is not officially supported\line \u8224\'a0 No longer officially supported}{\par }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {{\*\bkmkstart _Ref393618344}Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 1}}}{: Valid VICAR HOST Labels and Machine Types{\*\bkmkend _Ref393618344} \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b INTFMT, string}{: The format used to represent integers in the file. INTFMT, REALFMT, and HOST should all match. If you change one change all three. \line The valid values of INTFMT may change as the RTL is ported to new machines. However, the currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\b\f6 INTFMT label\cell Description\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\b\f6 \row }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 LOW \cell Low byte first, \ldblquote little endian\rdblquote . Used for hosts VAX-VMS, AXP-VMS, X86-SOLR, DECSTATN, AXP-UNIX, AXP-LINUX, X86-LINUX.\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 HIGH \cell High byte first, \ldblquote big endian\rdblquote . Used for all other hosts (except for CRAY, which has not been implemented). \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {{\*\bkmkstart _Ref393618329}Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 2}}}{: Valid VICAR Integer Formats{\*\bkmkend _Ref393618329} \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b REALFMT, string}{: The format used to represent floating point numbers in the file. INTFMT, REALFMT, and HOST should all match, so if you change one please change all three. Note: Compaq\rquote s Alpha supports three floating point formats: D, G, and IEEE. D is used for compatibility with VAX, though G is the default. IEEE is used for Alphas running Unix, but not  for VMS.\line The valid values of REALFMT may change as the RTL is ported to new machines. However, the currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618311 \\* MERGEFORMAT }}{\fldrslt {Table 3: Valid VICAR Real Number Formats}}}{. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keep\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\b\f6 REALFMT label}{\b \cell }{\cs33\b\f6 Description}{\b \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\b \row }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keep\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 VAX}{\cell }{\cs33\f6 VAX format. Single precision is VAX F format, double precision is VAX D format. Used on hosts VAX-VMS, AXP-VMS, X86-SOLR, DECSTATN, AXP-UNIX, AXP-LINUX, X86-LINUX.}{\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\row }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keep\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 RIEEE}{\cell }{\cs33\f6 Reverse IEEE format}{\cs33\caps\f6 . j}{\cs33\f6 ust like IEEE, except the bytes are reversed,with the exponent last. Used on hosts DECSTATN and X86-SOLR only }{\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\row }\trowd \trgaph100\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2340\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx10180\pard \li360\sb60\sa60\keep\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 IEEE}{\cell }{\cs33\f6 IEEE 754 format, with the high-order bytes (containing the exponent) first. Used for all other hosts (except for the CRAY, which has not been implemented)}{ \cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\row }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {{\*\bkmkstart _Ref393618311}Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 3}}}{: Valid VICAR Real Number Formats{\*\bkmkend _Ref393618311} \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BHOST, string}{ :The type of computer used to generate the binary label. It is used only for documentation; the RTL uses the BINTFMT and INTFMT label items to determine the representation of the binary labels in the file. Nevertheless, it should be kept consistent with BINTFMT and BREALFMT. \line The valid values of INTFMT are exactly the same as for the HOST label item. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BINTFMT, string}{: The format used to represent integers in the binary label. BINTFMT, INTFMT, and INTFMT should all match, so if you change one please change all three.\line The valid values of BINTFMT are exactly the same as for the INTFMT item above. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BREALFMT, string}{: The format used to represent floating point numbers in the binary label. BINTFMT, INTFMT, and INTFMT should all match, so if you change one please change all three.\line The valid values of BREALFMT are exactly the same as for the REALFMT label item above. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BLTYPE, string:}{ The type of the binary label.}{\b  }{This is not type in the sense of data type, but a string identifying the kind of binary label in the file. The RTL does not do any interpretation or checking of BLTYPE. It is intended for documentation, so people looking at the image will know what kind of binary label is present. It may also be used by application programs to make sure they can process the given type of binary label, or to make sure it is processed correctly.\line Valid BLTYPE values are maintained in a name registry, so that all possible kinds of binary labels can be documented in one place. Only names that are registered should be used in BLTYPE. See }{\field{\*\fldinst { REF Heading12 \\n  \\* MERGEFORMAT }}{\fldrslt {1.7.2}}}{ }{\field{\*\fldinst { REF Heading12 \\* MERGEFORMAT }}{\fldrslt {Programming and Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading12 }}{\fldrslt {\cs109\lang1024 17}}}{\cs109 )}{ for more details. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORMAT}{, string}{\b : }{The data type of the pixels in the file: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900\tx1890{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b BYTE}{:}{\cs29  }{Single byte, unsigned integer pixel type. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900\tx1890{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b HALF}{:}{\cs29  }{Signed short integer pixel type (often 2 bytes). \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900\tx1890{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b FULL}{:}{\cs29  }{Standard size signed integer pixel type (often 4 bytes). \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900\tx1890{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b REAL}{:}{\cs29  }{Single precision floating-point pixel type. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900\tx1890{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b DOUB}{:}{\cs29  }{Double precision floating-point pixel type. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900\tx1890{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b COMP}{:}{\cs29  }{Two single precision floating-point numbers representing a complex pixel type, in the order (real, imaginary). \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The label item }{\b FORMAT}{ is used to specify the data type. It is unfortunate that the name FORMAT is used for the data }{\i type}{, rather than for the host representation (which would better be called }{\i format}{), but the names cannot be changed for historical reasons. \par {\*\bkmkstart Heading8}{\*\bkmkstart _Toc425047486}{\*\bkmkstart _Toc425048041}{\*\bkmkstart _Toc425750565}{\*\bkmkstart _Toc453201376}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.5\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Pixel Type Declarations{\*\bkmkend Heading8}{\*\bkmkend _Toc425047486}{\*\bkmkend _Toc425048041}{\*\bkmkend _Toc425750565}{\*\bkmkend _Toc453201376} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {All pixel buffers in an application must be declared using the standard pixel type declarations. See }{\field{\*\fldinst { REF _Ref393695027 \\* MERGEFORMAT }}{\fldrslt {Table 6: FORTRAN declarations for pixel types}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393695036 }}{\fldrslt {\cs109\lang1024 26}}}{\cs109 ) }{for the standard FORTRAN declarations, and See }{\field{\*\fldinst { REF _Ref393619567 \\* MERGEFORMAT }}{\fldrslt {Table 4: C Declarations for Pixel Types}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393619567 }}{\fldrslt {\cs109\lang1024 24}}}{\cs109 )}{ for the standard C declarations. \par {\*\bkmkstart _Toc425047487}{\*\bkmkstart _Toc425048042}{\*\bkmkstart _Toc425329672}{\*\bkmkstart _Toc425750566}{\*\bkmkstart _Toc453201377}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.5.1\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Pixel Sizes{\*\bkmkend _Toc425047487}{\*\bkmkend _Toc425048042}{\*\bkmkend _Toc425329672}{\*\bkmkend _Toc425750566}{\*\bkmkend _Toc453201377} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Don\rquote t assume that FULL (integer) is 4 bytes, DOUB is 8 bytes, HALF is 2 bytes, etc.. A given machine may have data types of different sizes, such as 64-bit (8 byte) integers.\par Pixel sizes must be determined both for files and internal program buffers (arrays). A file could be written on a machine with pixel sizes different from the machine it will be read on. Use one of the RTL pixel size routines, }{\b x/zvpixsize}{, }{\b x/zvpixsizeu}{, or }{\b x/zvpixsizeb}{ to determine the size as written. These routines return the size of a pixel in bytes, given the data type and machine formats. }{\b x/zvpixsizeu}{ and }{\b x/zvpixsizeb}{ retrieve the machine formats from an image label. \par Buffers used within a program must also be sized correctly. Since internal buffers are almost always in native format for the machine you are running on, you can use the C function }{\cs33\f6 sizeof()}{ to get the size of an element in bytes. Use the proper data type for the pixel. See }{\field{\*\fldinst { REF _Ref393619567 \\* MERGEFORMAT }}{\fldrslt {Table 4: C Declarations for Pixel Types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393619567 }}{\fldrslt {\cs109\lang1024 24}}}{\cs109 )}{. FORTRAN has no }{\cs33\f6 sizeof()}{ operator or equivalent; use }{\b x/zvpixsize}{ with machine formats of \ldblquote NATIVE\rdblquote  or \ldblquote LOCAL\rdblquote  instead. \par {\*\bkmkstart Heading9}{\*\bkmkstart _Toc425047488}{\*\bkmkstart _Toc425048043}{\*\bkmkstart _Toc425750567}{\*\bkmkstart _Toc453201378}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.6\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Converting Data Types & Hosts{\*\bkmkend Heading9}{\*\bkmkend _Toc425047488}{\*\bkmkend _Toc425048043}{\*\bkmkend _Toc425750567}{\*\bkmkend _Toc453201378} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This section describes how to convert data between different data types and hosts, when the RTL does not do it for you. Most of the time, the RTL will take care of any data type and host conversions automatically. There are times, however, when you will need to do your own conversions. \par The translation routines have two parts: the setup routines, and the actual translation routine. The setup routines must be called first, to create a user-supplied buffer that describes the translation. The translation routine may then be called as many times as necessary to do the actual translation. \par It is important to have as many translation buffers active at the same time as needed. They can be created first, then used when needed in the program. This is illustrated in the example below. \par There is only one setup routine internally, which requires the data type, integer format, and real format for both the source and the destination. Since it is unwieldy to specify all six parameters every time something needs translating, there are five setup routines that provide part of the information for you. They are all simply syntactic sugar for the internal setup routine. These five are }{\b x/zvtrans_set}{, }{\b x/zvtrans_in}{, }{\b x/zvtrans_inu}{, }{\b x/zvtrans_inb}{, and }{\b x/zvtrans_out}{. See }{\field{\*\fldinst { REF _Ref394140865 \\* MERGEFORMAT }}{\fldrslt {Translation Routines}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref394140865 }}{\fldrslt {\cs109\lang1024 103}}}{\cs109 )}{.\par Where do these six parameters come from? Either the source or the destination will be in the native host representation, so only the foreign machine need be specified. For }{\b x/ztvtrans_set}{, both source and destination are the local machine. The information for the foreign machine will usually come from the label of the file being read. This is made easier by the }{\b x/zvtrans_inu}{ routine. For binary labels (which may be from a different host type than the image),}{\b  x/zvtrans_inb}{ can be used to get the binary label host information.\par You may make use of the }{\b x/zvhost}{ routine to get the INTFMT and REALFMT for a machine, given the type of machine. This allows the user to specify that the file be written in a foreign format. Although this is not the usual mode of operation for VICAR, it is allowed. An example should help to clarify things. A file is being read which contains a structure of mixed data type. The structure needs to be converted to native format so it can be processed. The structure could come from the binary label of the file, or it could be the data in an old-style IBIS file. It doesn't even have to be a VICAR file  the translation routines don't care. The code below is partially C code and partially pseudocode:\par }\pard\plain \s92\ri-1440\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {/* Structure format:  An int followed by two reals and an array of 8 shorts */\line \line struct \{\line    int type;\line    float coord[2];\line    short int values[8];\line \} data;\line unsigned char *old_ptr;\line static int short_conv[12], int_conv[12], real_conv[12]; /* Translation bufs */\line static int short_size, int_size, real_size;    /* Pixel sizes for each type */\line \line \{    /* Begin here */\line \line    char intfmt[20], realfmt[20];\line    unsigned char input_buf[100];\line \line    zveaction("sa", "");                        /* abort on error */\line \line    /*** Determine INTFMT and REALFMT, possibly via zvhost. ***/\line    /*** For a VICAR file, zvtrans_inu may be used instead. ***/\line    /*** For binary labels, zvtrans_inb may be used.        ***/\line \line /* Now set up the translation buffers. */\line \line    zvtrans_in(short_conv, "HALF", "HALF", intfmt, realfmt);\line    zvtrans_in(int_conv,   "FULL", "FULL", intfmt, realfmt);\line    zvtrans_in(real_conv,  "REAL", "REAL", intfmt, realfmt);\line \line /* Get pixel sizes in the input file for each type */\line \line    zvpixsize(&short_size, "HALF", intfmt, realfmt);\line    zvpixsize(&int_size,   "FULL", intfmt, realfmt);\line    zvpixsize(&real_size,  "REAL", intfmt, realfmt);\line \line /* The following could be in a read loop if desired. */\line \line    /*** Now the buffers are set up.  Read the data into input_buf. ***/\line \line    old_ptr = input_buf;\line \line    zvtrans(int_conv, old_ptr, &data.type, 1);           /* One integer */\line    old_ptr += int_size;\line    zvtrans(real_conv, old_ptr, data.coord, 2);          /* Two reals */\line    old_ptr += real_size*2;\line    zvtrans(short_conv, old_ptr, data.values, 8);        /* 8 shorts */\line    old_ptr += short_size*8;\line \line \}    /* That's all!  The data has been translated. */\par {\*\bkmkstart Heading10}{\*\bkmkstart _Toc425047489}{\*\bkmkstart _Toc425048044}{\*\bkmkstart _Toc425750568}{\*\bkmkstart _Toc453201379}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.7\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Using Binary Labels{\*\bkmkend Heading10}{\*\bkmkend _Toc425047489}{\*\bkmkend _Toc425048044}{\*\bkmkend _Toc425750568}{\*\bkmkend _Toc453201379} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The use of binary labels are not portable across computer architectures. Property labels should be used instead. They serve the same function as binary headers, though possibly not binary prefixes. Binary labels are allowed, but before creating a new format, stop to consider if property labels might be a better approach. See }{\field{\*\fldinst { REF Heading70 \\r \\* MERGEFORMAT }}{\fldrslt {4.1.2.1}}}{ }{\field{\*\fldinst { REF _Ref424721848 \\* MERGEFORMAT }}{\fldrslt {Using Property Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading70 }}{\fldrslt {\cs109\lang1024 74}}}{\cs109 )}{, for details. \par Binary labels are application-defined extensions to a VICAR image used to store information about the image. They have two parts: binary headers: extra records at the beginning of the image, and binary prefixes: extra bytes at the beginning of each image record. Binary labels are not part of image data. An application will never see the binary label data unless it specifically asks for it via a COND BINARY optional to }{\b x/zvopen}{. \par Binary headers are extra records that appear at the beginning of the file, between the standard label and the image. The number of records is specified by the NLB (Number of Lines of Binary) system label item. Binary headers are often thought of as extra \ldblquote lines\rdblquote  of data, but depending on the file organization they can actually be extra lines, samples, or bands. The size of each binary header record is exactly the same as the size of each image record. The headers specified by NLB occur exactly once in the file, not once per band (BSQ organization) or once per line (BIL or BIP organization). \par Binary prefixes are extra bytes that appear at the beginning of each image record. The number of bytes is specified by the NBB (Number of Bytes of Binary) system label item. The image record consists of NBB bytes of binary prefix data, followed by the samples that make up one line (for BSQ organization). Other file organizations label the units differently: a record for BIL is NBB plus the samples that make up one band, while a record for BIP is NBB plus the bands that make up one sample. NBB is specified in terms of bytes, }{\i not}{ in terms of pixels, even if the pixels are larger than one byte. \par Binary labels (both headers and prefixes) pose a problem: the data stored in them is application-defined. The RTL can\rquote t  determine what types of data are stored in a binary label, and therefore cannot automatically convert the data to the native host format as it does for image data. The application program has sole responsibility for converting binary data to the native host format when it is read. \par Few application programs understand any given kind of binary label. For example, the Voyager project has a definition for what goes in the binary label of its images. The Voyager-specific processing programs know how to interpret these labels and make use of them. The Galileo project also has a definition for its binary labels. Galileo-specific programs can interpret the Galileo binary labels}{\caps . h}{owever, the two kinds of binary labels are different, and programs written for one cannot make use of the other. The Magellan project has its own binary labels in yet another format. \par The variety of binary labels poses a problem for a general-purpose application. They could certainly be ignored, but then the information would be lost. Therefore, many general-purpose programs copy the binary labels from the input to the output, thereby preserving the information. As long as the information is only copied, not used, the application need not know any details. \par But what happens when you mix machine types? A file with binary labels was written on a VAX. You want to run COPY on the file from a Sun. COPY reads the input image, and writes the output image. The RTL automatically converts the image data from VAX to Sun format on input, and so the file gets written in Sun format. The system labels also say it is in Sun format. COPY also reads the binary labels, and writes them to the output file. The binary labels cannot be converted, as neither the RTL nor the COPY program know what data types are in the binary labels. Therefore, the binary labels get written out in the only way possible: in VAX format. \par The problem is that the system labels say the file is in Sun format, but the binary labels are still in VAX format. \par {\*\bkmkstart Heading11}{\*\bkmkstart _Toc425047490}{\*\bkmkstart _Toc425048045}{\*\bkmkstart _Toc425329673}{\*\bkmkstart _Toc425750569}{\*\bkmkstart _Toc453201380}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.7.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Separate Host Types{\*\bkmkend Heading11}{\*\bkmkend _Toc425047490}{\*\bkmkend _Toc425048045}{\*\bkmkend _Toc425329673}{\*\bkmkend _Toc425750569}{\*\bkmkend _Toc453201380} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The solution to the binary label problem is }{\i separate}{ host formats for the image and the binary label. The system labels HOST, INTFMT, and REALFMT describe the host formats for the image host type, while the system labels BHOST, BINTFMT, and BREALFMT describe the host formats for the binary .\par It is possible to generate files that have data in two different host formats: one for the image itself and one for the binary labels. This is not particularly desirable, but there is no practical alternative. As long as applications make sure they use the binary label host formats while accessing the binary labels, there\rquote s no problem. However, this does place a burden on application programmers to make sure they access binary labels correctly. \par UPDATE mode changes a file in place (rather than by copying) but does not convert it to native format. The application must write out any binary label updates in the format of the file, or it must read and re-write the entire binary label in a native format. The RTL handles the conversion automatically for image data. \par A set of subroutines should be written for each type of binary label to read/write/update that label. If all applications used this set of subroutines, it wouldn't matter what format the binary labels were kept in. The subroutines would be able to adapt and hide the details from the application program. If changes were made to the binary labels, or even if they were converted to property labels, the only code that would need to change would be the subroutines that access them. \par {\*\bkmkstart Heading12}{\*\bkmkstart _Toc425047491}{\*\bkmkstart _Toc425048046}{\*\bkmkstart _Toc425329674}{\*\bkmkstart _Toc425750570}{\*\bkmkstart _Toc453201381}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.7.2\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Programming and Binary Labels{\*\bkmkend Heading12}{\*\bkmkend _Toc425047491}{\*\bkmkend _Toc425048046}{\*\bkmkend _Toc425329674}{\*\bkmkend _Toc425750570}{\*\bkmkend _Toc453201381} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This Section shows how application programs make use of the binary label support features provided by the RTL.\par The use of binary labels is discouraged, due to portability problems. Where possible, property labels should be used instead. They usually serve the same function as binary headers, though possibly not binary prefixes. Binary labels are allowed, but before creating a new format, stop to consider if property labels might be a better approach. See }{\field{\*\fldinst { REF _Ref424721848 \\n  \\* MERGEFORMAT }}{\fldrslt {4.1.2.1}}}{ }{\field{\*\fldinst { REF _Ref424721848 \\* MERGEFORMAT }}{\fldrslt {Using Property Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading70 }}{\fldrslt {\cs109\lang1024 74}}}{\cs109 )}{, for details. \par The first problem is to open the file. Opening a file for input, update, and output will be covered separately, as the behavior is slightly different. All modes make use of }{\b x/zvadd}{ and }{\b x/zvopen}{ to open the files. The optional arguments mentioned may be used with either routine. \par For an input file, binary label host formats are obtained from the BHOST, BINTFMT, and BREALFMT system labels in the input file. The host formats thus obtained are used for the }{\b x/zvpixsizeb}{ and }{\b x/zvtrans_in}{ routines, as well as for }{\b x/zvget}{. The labels in the file are assumed to be correct, so there is no real override. If you need an override, you can always use the host formats directly through }{\b x/zvpixsize}{ or }{\b x/zvtrans_in}{. If the input file does not have the BHOST, etc. labels (for older images), then VAX format is assumed. If the input file has no label at all (COND NOLABELS), then the binary host formats are obtained from the BHOST, BINTFMT, and BREALFMT optional arguments to }{\b x/zvadd}{ or }{\b x/zvopen}{. \par For an update file, binary label host formats are also obtained from the file. The only difference is if you wish to change the binary label type of the file. You would need to re-write all the binary labels in the new format (be careful because the size might change), but you would also need to change the binary label format system label items (BHOST, BINTFMT, and BREALFMT) via }{\b x/zladd}{. If you use }{\b x/zladd}{ to change these items, then do }{\i not}{ use }{\b x/zvget}{ on them, or use }{\b x/zvpixsizeb}{ or }{\b x/zvtrans_in}{ at all, as these routines may still use the original binary label format. The }{\b x/zlget}{ routine would get the new values. \par The BLTYPE optional argument is not used for input or update files. You may change the BLTYPE system label on an update file via }{\b x/zladd}{, however. See the next section for a description of BLTYPE. \par Output files are more complex. There are two basic cases: either you convert the binary labels to native format, or you leave them alone. Which option you choose is controlled by the BIN_CVT optional argument. \par If you set BIN_CVT to ON,  write the binary labels in the native host format. The BHOST, BINTFMT, and BREALFMT system label items are set automatically to the native host formats. There is no override; the corresponding optional arguments are disabled when BIN_CVT is ON.\par Turn BIN_CVT ON if you are writing a new file with binary labels in native format. Although the name implies \ldblquote convert\rdblquote , it applies to any binary labels written in native format. If BIN_CVT is ON, then the application must know the kind of binary label being written. To do this, set the BLTYPE label using the BLTYPE optional argument. See the next section for a description of BLTYPE. \par If BIN_CVT is OFF (default), then the assumption is that you are copying the binary label without converting it. The binary label host formats used are those of the primary input file. If the primary input is not available, the default is VAX format. The primary input may be changed with }{\b x/zvselpi}{.\par BIN_CVT OFF is the appropriate mode to use for general-purpose applications that do not know the format of the binary label. The BHOST, BINTFMT, and BREALFMT optional arguments to }{\b x/zvadd}{ and}{\b  x/zvopen}{ will override any other settings, so you could write binary labels in an arbitrary format by setting to OFF and setting the three optional arguments to appropriate values.\par If you need to write specifically in VAX format, then do not depend on the default being VAX format (as mentioned above). That may not be reliable, depending on the primary input. If you want to write in a specific format, specify that format in the optional arguments. Do not use }{\b x/zladd}{ to change the binary label system label items on an output file. Specify them when you open the file. \par The BLTYPE optional argument is active if is OFF. Set it if you know the kind of binary label being written. BLTYPE comes from the primary input if you do not specify it. See the next section for a description of BLTYPE. \par Once a file is open, translate the binary label data you read and/or write to/from native format. The actual translations are performed in the same way as described in the rest of . Section }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{ (page }{\field{\*\fldinst { PAGEREF Heading5 }}{\fldrslt {\lang1024 9}}}{), except using the BHOST, BINTFMT, and BREALFMT labels and the }{\b x/zvpixsizeb}{ and }{\b x/zvtrans_inb}{ routines.\par As mentioned previously, }{\i all}{ binary label data read in must be converted to native format before being used. There are no exceptions to this rule. \par Binary labels written out to a file may be in either native or foreign formats, as discussed previously. \par {\*\bkmkstart Heading13}{\*\bkmkstart _Toc425047492}{\*\bkmkstart _Toc425048047}{\*\bkmkstart _Toc425329675}{\*\bkmkstart _Toc425750571}{\*\bkmkstart _Toc453201382}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 1.7.3\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Binary Label Type{\*\bkmkend Heading13}s{\*\bkmkend _Toc425047492}{\*\bkmkend _Toc425048047}{\*\bkmkend _Toc425329675}{\*\bkmkend _Toc425750571}{\*\bkmkend _Toc453201382} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {BLTYPE improves the documentation of files and makes the VICAR system more robust. Everyone using binary labels is encouraged to make use of BLTYPE. \par BLTYPE is a string that describes the kind of binary label in the file. It may be set with }{\b x/zvadd}{ or }{\b x/zvopen}{, or by calling }{\b x/zladd}{ on an already open file. No error checking or range of valid values are enforced by the RTL.\par The BLTYPE should be a short (maximum 32 characters) string that names the binary label type. It does not attempt to describe the fields in the binary label at all, but merely provides a pointer to how the fields could be determined. Some of the currently registered names are \ldblquote GLL_SSI_EDR\rdblquote , \ldblquote IBIS\rdblquote , and \ldblquote M94_HRSC\rdblquote . \par To maintain a consistent set of names, a name registry (similar to the one for properties) has been established for BLTYPE. Possible values for BLTYPE must be entered into this registry, with a pointer to documentation describing the format of the binary label. To create a new kind of binary label, tell the keeper of the registry what name you want to use and the format, either explicitly or by stating that it is in document }{\i X}{. The registrar will check for duplicates, approve your request and enter your name into the registry.\par The keeper of this registry is the VICAR system programmer. \par The RTL makes no checks on the validity of the names used. It is the responsibility of each individual programmer to make sure that they use this system. Failure to do so may result in your program not being accepted for delivery. \par Application programs that expect a certain kind of binary label should check the value of BLTYPE to make sure that they have been given the correct type, and issue an error message if it is incorrect. If BLTYPE is not present or blank, assume that the binary label is of the correct type for backwards compatibility. \par More sophisticated application programs could use the BLTYPE field to read several different kinds of binary labels. These could be different versions of the same basic binary label (e. g. a type of \ldblquote X V2. 0\rdblquote  for version 2 of the X label type), or labels from different projects. Widespread use of BLTYPE will allow a general-purpose program to be written that understands most binary label types. \par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\sect }\sectd \linex0\headery1440\footery706\colsx709\endnhere\sectdefaultcl {\headerl \pard\plain \s42\li360\sb120\sa120\nowidctlpar\brdrb\brdrs\brdrw15 \tqr\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst {\cs44  PAGE }}{\fldrslt {\cs44\lang1024 42}}}{\cs44 \tab }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1"\\n \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 2}}}{\cs44     }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 Programming Practice}}}{\par }}{\headerr \pard\plain \s42\li360\sb120\sa120\nowidctlpar\brdrb\brdrs\brdrw15 \tqr\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst {\cs44  STYLEREF \\n"Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 2}}}{\cs44    }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 Programming Practice}}}{\cs44 \tab }{\field{\*\fldinst {\cs44  PAGE }}{\fldrslt {\cs44\lang1024 43}}}{\par }}{\*\bkmkstart Heading52}{\*\bkmkstart Heading36}{\*\bkmkstart _Toc425047493}{\*\bkmkstart _Toc425048048}{\*\bkmkstart _Toc425750572}{\*\bkmkstart _Toc453201383}{\*\bkmkend Heading14}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 2.\tab}\pard\plain \s1\li360\sb60\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Programming Practice{\*\bkmkend _Toc425047493}{\*\bkmkend _Toc425048048}{\*\bkmkend _Toc425750572}{\*\bkmkend _Toc453201383}\par {\*\bkmkstart Heading15}{\*\bkmkstart _Toc425047494}{\*\bkmkstart _Toc425048049}{\*\bkmkstart _Toc425750573}{\*\bkmkstart _Toc453201384}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.1\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {General VICAR conventions{\*\bkmkend Heading15}{\*\bkmkend _Toc425047494}{\*\bkmkend _Toc425048049}{\*\bkmkend _Toc425750573}{\*\bkmkend _Toc453201384} \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b Portability}{. All VICAR software runs on all platforms that MIPL supports. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Separate FORTRAN and C Interfaces}{. All subroutines have separate FORTRAN and C calling sequences, with different names. Subroutines call only the appropriate language interface. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Status return. }{The status code is the function return. If automatic error checking is on (via }{\b x/zveaction}{ or one of the \ldblquote *_ACT\rdblquote  key words), then status return may be ignored. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Pass by value. }{All input values to the RTL are passed by value as in standard C, rather than by reference. Output variables or arrays are passed by reference. Check to remove \ldblquote }{\cs33\f6 &}{ \ldblquote 's before input arguments. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Data Formats and I/O}{. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {Applications read files written in any host representation. See }{\field{\*\fldinst { REF Heading6 \\n  \\* MERGEFORMAT }}{\fldrslt {1.3.1}}}{ }{\field{\*\fldinst { REF Heading6 \\* MERGEFORMAT }}{\fldrslt {VICAR File Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading6 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{.\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {Applications write files in the native host representations of the machine on which they are currently running. See }{\field{\*\fldinst { REF Heading6 \\n  \\* MERGEFORMAT }}{\fldrslt {1.3.1}}}{ }{\field{\*\fldinst { REF Heading6 \\* MERGEFORMAT }}{\fldrslt {VICAR File Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading6 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{.\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {Programs reading binary labels read any host format, and convert to native format before using. See }{\field{\*\fldinst { REF Heading5 \\n  \\* MERGEFORMAT }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{ and }{\field{\*\fldinst { REF Heading10 \\n  \\* MERGEFORMAT }}{\fldrslt {1.7}}}{ }{\field{\*\fldinst { REF Heading10 \\* MERGEFORMAT }}{\fldrslt {Using Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading10 }}{\fldrslt {\cs109\lang1024 16}}}{\cs109 )}{.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b Data Format Translation.}{ Do not write your own pixel data type or host representation conversion routines. The routine x/zvtrans is the standard way to translate data between different host representations and pixel data types in VICAR. See }{\field{\*\fldinst { REF Heading6 \\* MERGEFORMAT }}{\fldrslt {VICAR File Representations}}}{ (page }{\field{\*\fldinst { PAGEREF Heading6 }}{\fldrslt {\lang1024 9}}}{).\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Do not use EQUIVALENCE}{ for data type conversion in FORTRAN. Use the }{\cs33\f6 INT2BYTE}{ or }{\cs33\f6 BYTE2INT }{routines. See }{\field{\*\fldinst { REF Heading44 \\n  \\* MERGEFORMAT }}{\fldrslt {2.7.2}}}{ }{\field{\*\fldinst { REF Heading44 \\* MERGEFORMAT }}{\fldrslt {No EQUIVALENCE for Type Conversion}}}{ (page }{\field{\*\fldinst { PAGEREF Heading44 }}{\fldrslt {\lang1024 37}}}{).\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Pixel Sizes. }{Do not assume the size in bytes of a pixel or other data; it may be different on other machines. Use one of the }{\b x/zvpixsize}{ routines, or }{\cs33\f6 size of}{ in C, to determine the size of a data element. See }{\field{\*\fldinst { REF Heading8 \\n  \\* MERGEFORMAT }}{\fldrslt {1.5}}}{ }{\field{\*\fldinst { REF Heading8 \\* MERGEFORMAT }}{\fldrslt {Pixel Type Declarations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading8 }}{\fldrslt {\cs109\lang1024 13}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Name Registries. }{Every property name or BLTYPE name used is entered into the appropriate name registry. See }{\field{\*\fldinst { REF _Ref424721848 \\n  \\* MERGEFORMAT }}{\fldrslt {4.1.2.1}}}{ }{\field{\*\fldinst { REF _Ref424721848 \\* MERGEFORMAT }}{\fldrslt {Using Property Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading70 }}{\fldrslt {\cs109\lang1024 74}}}{\cs109 )}{ and }{\field{\*\fldinst { REF Heading12 \\n  \\* MERGEFORMAT }}{\fldrslt {1.7.2}}}{ }{\field{\*\fldinst { REF Heading12 \\* MERGEFORMAT }}{\fldrslt {Programming and Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading12 }}{\fldrslt {\cs109\lang1024 17}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Operating System Calls. }{All OS-specific code is eliminated or isolated, and should be written in C if possible. See }{\field{\*\fldinst { REF Heading49 \\n  \\* MERGEFORMAT }}{\fldrslt {2.7.6}}}{ }{\field{\*\fldinst { REF Heading49 \\* MERGEFORMAT }}{\fldrslt {VMS-Specific Code}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading49 }}{\fldrslt {\cs109\lang1024 40}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Conditional Compilation. }{Conditional compilation statements to handle machine dependencies use names of specific features that are defined in standard include files based on the machine type. Feature dependencies are defined only in}{\cs34\i\fs24  }{\cs33\f6 x/zvmaininc.h }{or }{\cs33\f6 vmachdep.h}{. Symbols VMS_OS and UNIX_OS distinguish between VMS and UNIX operating systems. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b No Terminal I/O. }{VICAR applications may not write directly to the terminal (e. g. stdout). Use }{\b x/zvmessage}{ instead.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ANSI C. }{Function prototype include files use }{\cs33\f6 #ifndef}{ wrappers, _NO_PROTO, and extern \ldblquote C\rdblquote  declarations. FORTRAN bridge routines do not use prototypes or the prototype form of declaration.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORTRAN 77 standard. }{All FORTRAN code conforms to the ANSI FORTRAN -77 standard, with the exception of the allowed extensions listed in the reference. See }{\field{\*\fldinst { REF Heading48 \\n  \\* MERGEFORMAT }}{\fldrslt {2.7.5}}}{ }{\field{\*\fldinst { REF Heading48 \\* MERGEFORMAT }}{\fldrslt {VMS FORTRAN Extensions}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading48 }}{\fldrslt {\cs109\lang1024 39}}}{\cs109 )}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORTRAN Strings. }{All FORTRAN-callable subroutines written in C use the RTL string conversion routines ( }{\b sfor2c}{ }{\i et al}{) to handle CHARACTER*n arguments. See }{\field{\*\fldinst { REF _Ref393876585 \\n  \\* MERGEFORMAT }}{\fldrslt {2.6.4}}}{ }{\field{\*\fldinst { REF _Ref393876585 \\* MERGEFORMAT }}{\fldrslt {Passing Strings}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393876585 }}{\fldrslt {\cs109\lang1024 31}}}{\cs109 )}{.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b vimake. }{VICAR applications use imakefiles compatible with vimake to create their build files.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b vpack. }{VICAR applications are packed into a COM file using the vpack command.\par {\*\bkmkstart Heading16}{\*\bkmkstart _Toc425047495}{\*\bkmkstart _Toc425048050}{\*\bkmkstart _Toc425750574}{\*\bkmkstart Heading20}{\*\bkmkstart _Toc425047498}{\*\bkmkstart _Toc425048053}{\*\bkmkstart _Toc425329677}{\*\bkmkstart _Toc425750577}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Optional Arguments}{{\*\bkmkend Heading20}{\*\bkmkend _Toc425047498}{\*\bkmkend _Toc425048053}{\*\bkmkend _Toc425329677}{\*\bkmkend _Toc425750577} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {There are two types of RTL routines: those that take a constant number of arguments, and those that take optional arguments of the form \ldblquote key word\rdblquote , \rdblquote value\rdblquote , \ldblquote key word\rdblquote ,\rdblquote  value\rdblquote , etc.\par }{\i All}{ routines that accept keyword-value pairs, whether or not the pairs are used in any particular call, must have an argument list terminator. The terminator is a language-dependent argument at the end of the argument list, where the next key word would be if it existed. \par In FORTRAN, the terminator is a single blank in quotes at the end of the argument list:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvopen(unit, status, 'op', 'write','open_act','sa',' ') \line call xvread(unit, buffer, status, 'line', 1, ' ') \line call xvclose(unit, status, '')\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {In C, the terminator is a 0 or NULL argument ( }{\i not}{ a blank):\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 status = zvopen(unit, \ldblquote op\rdblquote , \ldblquote write\rdblquote , \ldblquote open_act\rdblquote , \ldblquote sa\rdblquote , 0); \line status = zvread(unit, buffer, \ldblquote line\rdblquote , 1, 0); \line status = zvclose(unit, 0);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Certain RTL routines used to take pure optional arguments (not keyword/value), but that practice is not portable and is now obsolete.}{\cs33\f6 \par {\*\bkmkstart _Toc453201385}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.2\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {ANSI C{\*\bkmkend Heading16}{\*\bkmkend _Toc425047495}{\*\bkmkend _Toc425048050}{\*\bkmkend _Toc425750574}{\*\bkmkend _Toc453201385}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {ANSI C is used for all VICAR programs. This section describes what needs to be done within the VICAR environment in order to successfully use ANSI C. Read it before using ANSI C with VICAR. \par Function prototypes allow the compiler to check the number and types of arguments to subroutines. If they don't match, a warning is issued. This feature will catch many common programming errors. You will undoubtedly find many more compiler warnings if you use prototypes, but that is a good thing. Most of those warnings are errors in the code, or questionable coding practices. Take heed and your code quality should improve. \par A function with a prototype does not suffer default argument promotion; it can, for example, pass a float as a float, rather than promoting it to a double. This can be more efficient in some cases. This is also a danger, however; if a subroutine is intended to be called from non-ANSI code (which includes almost all SUBLIB routines), then  be careful to use only argument types that won't be promoted in the absence of a prototype in order to remain compatible. Any ANSI C reference should be able to provide more details. \par Program writers should be careful to include the appropriate include files, in order to get the function prototypes for each subroutine package. The prototype file for the RTL is called \ldblquote zvproto.h\rdblquote }{\caps . y}{ou should include this file in any routines that make use of the RTL. \par Subroutine writers should provide an include file that defines the prototypes for the functions in your subroutine package. This include file may be very short if you have only one function, or quite long for a big package. This include file should generally be the same as that containing public definitions, although it can be separate if need be. For example, the RTL include file, \rdblquote zvproto.h\rdblquote , has only prototypes. \par When you declare prototypes, there are three things you need to do: provide a wrapper, use _NO_PROT O, and support C++. The first thing is to protect your file against multiple inclusions. A \ldblquote wrapper\rdblquote  define and #ifndef should be put around the entire file. This way, if the file is included more than once, it will not be compiled the second time.\par Second, your include file may be used in a non-ANSI environment. For this reason, it is important to protect the prototypes with the _NO_PROTO symbol. The _NO_PROTO symbol is declared in }{\cs33\f6 xvmaininc.h}{. If _NO_PROTO is not defined, use prototypes. If it is, use the old-style declarations instead.\par Third, allow support of C++. C++ uses the same prototype mechanism as ANSI C, but prototypes are required. In order to cross languages and link to a C module, however, the C declaration must be enclosed in \ldblquote }{\cs33\f6 extern \ldblquote C\rdblquote  \{}{...}{\cs33\f6 \}}{ \ldblquote . By putting this wrapper around your entire include file, and providing prototypes for every function, you can make your subroutines available from C++. \par Here is an example which demonstrates all three techniques. Use it as a template for prototype includes. \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {/* xyz.h: include file for the XYZ subroutine package. */\line #ifndef _XYZ_H\line #define _XYZ_H\line \line #include "xvmaininc.h"     /* not needed if you can guarantee the caller */\line                            /* has already included it */\line \line #ifdef __cplusplus\line extern "C" \{\line #endif\line \line #define ONE_OF_MY_FLAGS 10            /* your common definitions go here */\line \line #ifndef _NO_PROTO\line \line double xyz(int a, char *b, double d); /* your prototypes go here */\line \line #else /* _NO_PROTO */\line \line double xyz();                         /* non-prototype decls go here */\line \line #endif /* _NO_PROTO */\line \line #ifdef __cplusplus\line \}        /* end extern "C" */\line #endif\line \line #endif /* XYZ_H */}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {There are some pitfalls using ANSI C prototypes. First, do }{\i not}{ put prototypes on any FORTRAN bridge routines. FORTRAN doesn't understand them, and the prototypes interfere with the FORTRAN string passing mechanisms. Use the old-style declarations instead. Prototypes can and should exist for the C function called }{\i by}{ the bridge. \par Second, variadic functions (those with variable arguments) are a problem if you are intending to have both ANSI and non-ANSI callers. The ANSI C standard states that variadic functions must use \ldblquote }{\cs33\f6 ...}{\ldblquote  in the prototype and function header. The implication is that compiler is free to use a different argument-passing mechanism for these functions (although current compilers don't seem to do this).\par The old form of using varying arguments, <varargs.h>  doesn't have the risk of a different argument-passing mechanism. Plus, if a variadic function is going to be called by non-ANSI C code, the...\ldblquote  form is not available. For this reason, and to be safe, you should use <varargs.h> instead of <stdarg.h>, and not the  ...\ldblquote  form. See the comments in zvproto.h for more details. This should not cause much of a problem in VICAR code because varying arguments may only be used in certain limited situations. \par {\*\bkmkstart Heading17}{\*\bkmkstart _Toc425047496}{\*\bkmkstart _Toc425048051}{\*\bkmkstart _Toc425750575}{\*\bkmkstart _Toc453201386}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.3\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {C Calling Sequence{\*\bkmkend Heading17}{\*\bkmkend _Toc425047496}{\*\bkmkend _Toc425048051}{\*\bkmkend _Toc425750575}{\*\bkmkend _Toc453201386} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {All RTL routines have a C language binding: every routine has an entry point that uses C-style arguments and calling sequences. All portable C language programs use the C language interface to the RTL. \par The C-language routines are named similarly to the old (now FORTRAN-style) routines, but start with a \ldblquote }{\cs33\f6 z}{\rdblquote  instead of \ldblquote }{\cs33\f6 x}{\rdblquote . For example, instead of calling }{\b xvwrit }{or }{\b xlget}{, a C program would now call }{\b zvwrit }{or }{\b zlget}{. \par {\*\bkmkstart Heading19}{\*\bkmkstart _Toc425047497}{\*\bkmkstart _Toc425048052}{\*\bkmkstart _Toc425329676}{\*\bkmkstart _Toc425750576}{\*\bkmkstart _Toc453201387}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.3.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {C Data Types{\*\bkmkend Heading19}{\*\bkmkend _Toc425047497}{\*\bkmkend _Toc425048052}{\*\bkmkend _Toc425329676}{\*\bkmkend _Toc425750576}{\*\bkmkend _Toc453201387} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The standard C definitions for each of the VICAR pixel data types are listed. See }{\field{\*\fldinst { REF _Ref393619567 \\* MERGEFORMAT }}{\fldrslt {Table 4: C Declarations for Pixel Types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393619567 }}{\fldrslt {\cs109\lang1024 24}}}{\cs109 )}{. The data types that may be passed into the RTL, and the C declarations for each type, are listed in }{\field{\*\fldinst { REF _Ref393619550 \\* MERGEFORMAT }}{\fldrslt {Table 6: C Declarations for Run-Time Library Arguments}}}{.(below)}{\cs33\f6 \par }\trowd \trqc\trgaph108\trleft-108\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2028\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx6684\pard\plain \li360\sb60\sa60\nowidctlpar\intbl\adjustright \f4\fs20\cgrid {\cs33\b\f6 Pixel Type \cell C Declaration \cell }\pard \widctlpar\intbl\adjustright {\cs33\b\f6 \row }\trowd \trqc\trgaph108\trleft-108\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2028\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx6684\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 BYTE \cell unsigned char \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2028\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx6684\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 HALF \cell short int \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 FULL \cell int \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 REAL \cell float \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 DOUB \cell double \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2028\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx6684\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 COMP \cell }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 struct complex \{float r, i; \\\}; }{\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar\adjustright \f4\fs20\cgrid {{\*\bkmkstart _Ref393619567}Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 4}}}{: C Declarations for Pixel Types{\*\bkmkend _Ref393619567} \par }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2880\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx8748\pard\plain \li360\sb60\sa60\nowidctlpar\intbl\adjustright \f4\fs20\cgrid {\cs33\b\f6 RTL Argument Type \cell C Declaration \cell }\pard \widctlpar\intbl\adjustright {\cs33\b\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2880\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx8748\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 integer \cell int \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2880\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx8748\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 string \cell char x[n] \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 value \cell int, char x[n], float, or double \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 integer array \cell int x[m] \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 string array \cell char x[m][n] \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 value array \cell array of any \ldblquote  value\rdblquote  type above \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 pixel buffer \cell pointer to any pixel type. }{See }{\field{\*\fldinst { REF _Ref393619567 \\* MERGEFORMAT }}{\fldrslt {Table 4: C Declarations for Pixel Types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393619567 }}{\fldrslt {\cs109\lang1024 24}}}{\cs109 )}{\cs33\f6  \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 FORTRAN string \cell char *x \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 FORTRAN string array \cell char *x \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 void pointer \cell void *x (actually, a pointer to anything) \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 pixel pointer \cell address of pointer to any pixel type. }{See }{\field{\*\fldinst { REF _Ref393619567 \\* MERGEFORMAT }}{\fldrslt {Table 4: C Declarations for Pixel Types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393619567 }}{\fldrslt {\cs109\lang1024 24}}}{\cs109 )}{\cs33\f6 \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2880\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx8748\pard \li360\sb60\sa60\nowidctlpar\intbl\adjustright {\cs33\f6 pointer to string array \cell }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 char **x }{\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar\adjustright \f4\fs20\cgrid {{\*\bkmkstart _Ref393619550}Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 6}}}{: C Declarations for Run-Time Library Arguments{\*\bkmkend _Ref393619550} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Because labels and parameters can have more than one value, the routines that deal with them must be able to accept (or output) arrays of strings. The RTL expects all arrays of strings to be two-dimensional arrays of \ldblquote char\rdblquote . This does not mean an array of pointers to strings, but a pointer to an area of memory n*m bytes long, where n is the maximum size of each string and m is the number of strings. The inner dimension, n, must be passed in to the routine so it knows how to access the string array.\par All RTL routines that use string arrays have a way to specify the length. The length is the size of the inner dimension; it is not the length of any particular string, but must include space for the null terminator at the end of a string. For example, if a string has at most 10 characters, make sure the length is at least 11 to allow room for the null terminator. \par {\*\bkmkstart _Toc425047499}{\*\bkmkstart _Toc425048054}{\*\bkmkstart _Toc425329678}{\*\bkmkstart _Toc425750578}{\*\bkmkstart _Toc453201388}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.4\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {FORTRAN Calling Sequence{\*\bkmkend _Toc425047499}{\*\bkmkend _Toc425048054}{\*\bkmkend _Toc425329678}{\*\bkmkend _Toc425750578}{\*\bkmkend _Toc453201388} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The Run-Time Library has two entry points (called language bindings) for every routine. One is designed to be called from FORTRAN only, and the other is designed to be called from C only. The FORTRAN routines start with \ldblquote x\rdblquote , as in }{\b xvread}{, }{\b xladd}{, etc. \par {\*\bkmkstart Heading21}{\*\bkmkstart _Toc453201389}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.4.1\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Character Strings{\*\bkmkend Heading21}{\*\bkmkend _Toc453201389} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Most RTL routines take characters strings as arguments. They appear in parameter names, key words, messages, and many other places. Under the old RTL, strings could be passed in either of two ways: as FORTRAN CHARACTER*n variables, or as BYTE or LOGICAL*1 arrays. The array method will no longer work. \par All FORTRAN-callable RTL routines accept character strings }{\i only }{in FORTRAN CHARACTER*n format. CHARACTER*n variables and constants have a length associated with them (the \ldblquote n\rdblquote ), which the RTL uses to find the end of the string, and to make sure that buffer overflow does not occur on output strings. Byte arrays can\rquote t be used, since in FORTRAN there is no way for the RTL to find the end of the string. Arrays of CHARACTER*1 will not work; the RTL will think the string being passed in is one character long. \par {\*\bkmkstart _Toc453201390}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.4.2\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {FORTRAN Data Types{\*\bkmkend _Toc453201390} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The standard FORTRAN definitions for each of the VICAR pixel data types are listed below in }{\field{\*\fldinst { REF _Ref393695027 \\* MERGEFORMAT }}{\fldrslt {Table 6: FORTRAN declarations for pixel types}}}{. The data types that may be passed in to the RTL, and the FORTRAN declarations for each type, are listed below in }{\field{\*\fldinst { REF _Ref393695036 \\* MERGEFORMAT }}{\fldrslt {Table 8: FORTRAN declarations for Run-Time Library arguments}}}{.}{\cs33\f6 \par }\trowd \trqc\trgaph108\trleft-452\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1674\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx5038\pard\plain \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright \f4\fs20\cgrid {\cs33\b\f6 Pixel Type\cell FORTRAN Declaration\cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-452\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1674\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx5038\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 BYTE \cell }{BYTE \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-452\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1674\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx5038\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 HALF \cell }{INTEGER*2 \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 FULL \cell }{INTEGER*4 \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 REAL \cell }{REAL*4 \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 DOUB \cell }{REAL*8 \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-452\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1674\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx5038\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 COMP \cell }{COMPLEX*8 \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\adjustright {Note the use of the \ldblquote *n\rdblquote  form, even where not strictly necessary. This is intentional; please use the form shown for all pixel data. \par }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar\adjustright \f4\fs20\cgrid {{\*\bkmkstart _Ref393695027}Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 6}}}{: FORTRAN declarations for pixel types{\*\bkmkend _Ref393695027}\par }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2508\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx8748\pard\plain \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright \f4\fs20\cgrid {\cs33\f6 RTL Argument Type \cell  FORTRAN Declaration \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2508\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx8748\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 integer \cell INTEGER \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2508\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx8748\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 string \cell CHARACTER*n \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 value \cell INTEGER, CHARACTER*n, REAL, or DOUBLE PRECISION \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 integer array \cell INTEGER x(m) \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 string array \cell CHARACTER*n x(m) \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 value array \cell array of any \ldblquote value\rdblquote  type above \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 pixel buffer \cell array of any pixel type. }{See }{\field{\*\fldinst { REF _Ref393695027 \\* MERGEFORMAT }}{\fldrslt {Table 6: FORTRAN declarations for pixel types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393695036 }}{\fldrslt {\cs109\lang1024 26}}}{\cs109 )}{\cs33\f6 \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2508\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx8748\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 pixel pointer \cell N/A \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\adjustright {The \ldblquote *n\rdblquote  is not used for arguments, except for strings. This helps to distinguish pixel data (which uses \ldblquote *n\rdblquote ) from other types of data. \par }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar\adjustright \f4\fs20\cgrid {{\*\bkmkstart _Ref393695036}Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 8}}}{: FORTRAN declarations for Run-Time Library arguments{\*\bkmkend _Ref393695036}\par {\*\bkmkstart _Ref395927055}{\*\bkmkstart _Ref395927103}{\*\bkmkstart _Toc425047500}{\*\bkmkstart _Toc425048055}{\*\bkmkstart _Toc425750579}{\*\bkmkstart _Toc453201391}{\*\bkmkend Heading36}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.5\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Include Files{\*\bkmkend _Ref395927055}{\*\bkmkend _Ref395927103}{\*\bkmkend _Toc425047500}{\*\bkmkend _Toc425048055}{\*\bkmkend _Toc425750579}{\*\bkmkend _Toc453201391} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {There are five major classes of include files: system, VICAR main, VICAR system, VICAR subroutine, and local. \par Include only those files needed. Some includes require that other files be included first. Extra includes in your program don't gain you anything, but slow down your compiles. They also make system maintenance difficult, since the source code must occasionally be searched to see what programs use an include, and all programs that use an include must be recompiled when it changes (even if it's not really used). \par System include files are provided by the operating system. Many are OS-specific, but there are a few that are standard across platforms. Make sure the ones you need are available in both operating systems, or isolate them in machine-dependent code. System include files should be enclosed in angle brackets and have the \ldblquote .h\rdblquote  extension. Some known portable includes are:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {#include <varargs.h>\line #include <math.h>\line #include <ctype.h>\line #include <stdio.h>\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid { One known }{\i non}{-portable file is }{\cs33\f6 <unistd.h>}{. If you need symbolic constants for the lseek() arguments(which are often contained in }{\cs33\f6 unistd.h}{), use the definitions provided in xvmaininc.h. \par The VICAR main include file, which all VICAR programs should start with, must be in lower case, with double quotes. The name of the main include is \ldblquote vicmain_c\rdblquote , with no directory specifiers and no \ldblquote .h\rdblquote  extension.\par Any modules other than the main program module that need VICAR definitions should include }{\cs33\f6 xvmaininc.h}{, in lower case, with double quotes and the \ldblquote .h\rdblquote  extension xvmaininc.h is automatically included with vicmain_c. \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 #include \ldblquote vicmain_c\rdblquote  \par \emdash  or \emdash \par #include \ldblquote xvmaininc.h\rdblquote \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {VICAR system includes are provided as part of the RTL. Their names should be in lower case, with quotes and the \ldblquote .h\rdblquote  extension. The valid ones are listed below. Only a few of these should ever be used in application code, notably zvproto.h, ftnbridge.h, errdefs.h, and applic.h. The rest should only be needed in very unusual circumstances. They should generally be in the order listed below. \par Include }{\i only }{those needed. Extraneous include files will only slow down your compile and make system maintenance harder. TAE includes are handled as specified in the TAE documentation. They should be in double quotes, with the \rdblquote .inc\rdblquote  or \ldblquote .inp\rdblquote  extensions as appropriate. The first four listed below are TAE includes:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 #include \ldblquote taeconf.inp\rdblquote  \line #include \ldblquote symtab.inc\rdblquote  \line #include \ldblquote parblk.inc\rdblquote  \line #include \ldblquote pgminc.inc\rdblquote  \line #include \ldblquote zvproto.h\rdblquote  \line #include \ldblquote defines.h\rdblquote  \line #include \ldblquote declares.h\rdblquote  \line #include \ldblquote externs.h\rdblquote  \line #include \ldblquote applic.h\rdblquote  \line #include \rdblquote errdefs.h\rdblquote  \line #include \ldblquote ftnbridge.h\rdblquote  \line #include \ldblquote xviodefs.h\rdblquote \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {VICAR subroutine include files (class 2 and 3 SUBLIB, VRDI, etc.) should be in double quotes, with no path names, and should include the \ldblquote .h\rdblquote  extension, like VICAR system includes. For these includes, the directories containing the includes must be available to the compiler. This is normally handled transparently, but some libraries will require a LIB_* macro in the imakefile to access the includes.\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 #include \ldblquote vmachdep.h\rdblquote  \line #include \ldblquote gll_ssi_edr.h\rdblquote  \line #include \ldblquote xderrors.h\rdblquote \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Local includes, which are delivered as part of the COM file and are used only by that application, should be in double quotes, with no path names. Include the \ldblquote .h\rdblquote  extension, just as for VICAR system and subroutine includes. Local includes must be listed in the INCLUDE_LIST macro in the imakefile so they can be cleaned up properly.\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 #include \ldblquote my_inc.h\rdblquote  }{\par {\*\bkmkstart Heading37}{\*\bkmkstart _Toc425047501}{\*\bkmkstart _Toc425048056}{\*\bkmkstart _Toc425750580}{\*\bkmkstart _Toc453201392}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.6\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Mixing FORTRAN and C{\*\bkmkend Heading37}{\*\bkmkend _Toc425047501}{\*\bkmkend _Toc425048056}{\*\bkmkend _Toc425750580}{\*\bkmkend _Toc453201392} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This section describes how to mix code written in both FORTRAN and C. It covers both internal code (used only within one program), and SUBLIB subroutines that must be called from either language.\par A subroutine must have a separate interface for each language. A FORTRAN program can only call the FORTRAN interface, while a C program can only call the C interface, because the necessary calling conventions are so different. If you are rewriting a subroutine which is used only internally to your program, you may need an interface for only one language. Some SUBLIB routines are useful only for one language, but most subroutines will have two interfaces. \par {\*\bkmkstart _Ref393877095}{\*\bkmkstart _Toc425047502}{\*\bkmkstart _Toc425048057}{\*\bkmkstart _Toc425329679}{\*\bkmkstart _Toc425750581}{\*\bkmkstart _Toc453201393}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.6.1\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Bridge Routines{\*\bkmkend _Ref393877095}{\*\bkmkend _Toc425047502}{\*\bkmkend _Toc425048057}{\*\bkmkend _Toc425329679}{\*\bkmkend _Toc425750581}{\*\bkmkend _Toc453201393} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The calling interface for the language of subroutine are straightforward. Follow the rules for that language. The interface for the other language will be implemented via a \ldblquote bridge\rdblquote  routine, which must be written in C. \par The bridge routine accepts arguments in the format of the opposite language, converts them to the form of the subroutine\rquote s language and calls the main subroutine. For example, a subroutine written in C would have a bridge also written in C that accepts arguments in the FORTRAN style, reformat them, and call the main C subroutine. A subroutine written in FORTRAN would have a C bridge that accepts C-style arguments, and call the FORTRAN subroutine in the proper manner. \par If you are using ANSI C, do not use function prototypes on FORTRAN bridges (routines written in C that are intended to be called from FORTRAN).\par {\*\bkmkstart _Ref394558196}{\*\bkmkstart _Ref394558207}{\*\bkmkstart _Toc425047503}{\*\bkmkstart _Toc425048058}{\*\bkmkstart _Toc425329680}{\*\bkmkstart _Toc425750582}{\*\bkmkstart _Toc453201394}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.6.2\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Naming Subroutines{\*\bkmkend _Ref394558196}{\*\bkmkend _Ref394558207}{\*\bkmkend _Toc425047503}{\*\bkmkend _Toc425048058}{\*\bkmkend _Toc425329680}{\*\bkmkend _Toc425750582}{\*\bkmkend _Toc453201394} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The subroutine names for the FORTRAN and C interfaces }{\i must}{ be different. It is not sufficient to add an underscore to the end of a name; the letters themselves must be different. The name difference is forced by the fact that some FORTRAN compilers put a trailing underscore after the name, and others do not.\par In order for a C routine to be called from FORTRAN, it must be named in a manner the FORTRAN compiler will recognize. This is handled via the FTN_NAME macro. This macro is used any where the subroutine name would be, including in the declaration of the subroutine. The subroutine name is the argument for the macro; \ldblquote ftnbridge.h\rdblquote  must be included:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {#include "xvmaininc.h"\line #include "ftnbridge.h"\line \line void FTN_NAME(mysub)(param1, param2)\line int *param1, *param2;                       /* inputs */\line \{\line    zmysub(*param1, *param2);\line \}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid { would be called by FORTRAN: \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33       integer a, b \line       call mysub(a, b)\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {A FORTRAN routine that wishes to be called by C must have a bridge written in C. Otherwise, the C caller would have to use the FTN_NAME macro to call the routine, which would cause problems if the routine were ever converted to C. The bridge routine takes care of this:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {subroutine fsub(param1, param2)\line       integer param1, param2                   ! inputs\line C     do something\line       return\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid { The C bridge looks like the following. Note the use of FTN_NAME when calling the FORTRAN program:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {#include "xvmaininc.h"\line #include "ftnbridge.h"\line \line void csub(param1, param2)\line int param1, param2;                            /* inputs */\line \{\line    FTN_NAME(fsub)(&param1, &param2);\line \}\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid { It would be called from a C program:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 int a, b; \line csub(a, b); }{\par {\*\bkmkstart Heading38}{\*\bkmkstart _Toc425047504}{\*\bkmkstart _Toc425048059}{\*\bkmkstart _Toc425329681}{\*\bkmkstart _Toc425750583}{\*\bkmkstart _Toc453201395}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.6.3\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Passing Numeric Arguments{\*\bkmkend Heading38}{\*\bkmkend _Toc425047504}{\*\bkmkend _Toc425048059}{\*\bkmkend _Toc425329681}{\*\bkmkend _Toc425750583}{\*\bkmkend _Toc453201395} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Passing numeric arguments and arrays between FORTRAN and C is straightforward. The data type equivalencies are listed. See }{\field{\*\fldinst { REF _Ref393695036 \\* MERGEFORMAT }}{\fldrslt {Table 8: FORTRAN declarations for Run-Time Library arguments}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393695036 }}{\fldrslt {\cs109\lang1024 26}}}{\cs109 )}{. A routine that receives data of one type must be passed the equivalent type of data if called from the other language. The bridge may  change the datatype between the caller and the routine if desired, but the subroutine interface that actually spans the language change (caller-bridge for FORTRAN to C, bridge-routine for C to FORTRAN) must follow this table.\par For numeric arguments FORTRAN passes arguments by reference, while C normally passes input arguments by value. Such arguments must be converted in the bridge routine. A FORTRAN to C bridge declares all arguments as pointers, then puts asterisks (*) in front of the appropriate arguments to dereference them when calling the main routine. A C to FORTRAN bridge declares the appropriate arguments as values (not pointers), and uses an ampersand (&) in the call to the FORTRAN routine to convert them to pointers. There are examples in }{\field{\*\fldinst { REF _Ref394558196 \\n  \\* MERGEFORMAT }}{\fldrslt {2.6.2}}}{ }{\field{\*\fldinst { REF _Ref394558207 \\* MERGEFORMAT }}{\fldrslt {Naming Subroutines}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref394558196 }}{\fldrslt {\cs109\lang1024 29}}}{\cs109 )}{. \par Not all C arguments are passed by value. If a pointer comes in, such as for an output variable or an array, then the pointer can normally be passed unchanged to the subroutine.\par }\trowd \trqc\trgaph108\trleft-108\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2898\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx7038\pard\plain \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright \f4\fs20\cgrid {\cs33\b\f6 FORTRAN Data Type \cell C Data Type \cell }\pard \widctlpar\intbl\adjustright {\cs33\b\f6 \row }\trowd \trqc\trgaph108\trleft-108\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2898\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx7038\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 BYTE \cell unsigned char \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2898\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx7038\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 INTEGER*2 \cell short int \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 INTEGER*4 \cell int \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 REAL*4 \cell float \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 REAL*8 \cell double \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 COMPLEX*8 \cell struct complex \{float r, i; \} \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 INTEGER \cell int \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 CHARACTER*n \cell char x[n] * \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 INTEGER x(m) \cell int x[m] \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 REAL x(m) \cell float x[m] \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2898\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx7038\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl\adjustright {\cs33\f6 CHARACTER*n x(m) \cell char x[m][n] * \cell }\pard \widctlpar\intbl\adjustright {\cs33\f6 \row }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {* Characters require special handling, see }{\field{\*\fldinst { REF _Ref393876585 \\n  \\* MERGEFORMAT }}{\fldrslt {2.6.4}}}{ }{\field{\*\fldinst { REF _Ref393876585 \\* MERGEFORMAT }}{\fldrslt {Passing Strings}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393876585 }}{\fldrslt {\cs109\lang1024 31}}}{\cs109 )}{\par }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar\adjustright \f4\fs20\cgrid {Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 9}}}{: FORTRAN and C Argument Data Type Equivalence \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Two-dimensional (or higher) arrays are handled differently in each language. FORTRAN accesses them in column-major order, while C uses row-major order. The order of the subscripts is reversed. One can either copy the array and reshuffling it in the bridge (which can be inefficient), or simply document the need to reverse the subscripts in the other language when calling the routine. \par {\*\bkmkstart _Ref393876585}{\*\bkmkstart _Toc425047505}{\*\bkmkstart _Toc425048060}{\*\bkmkstart _Toc425329682}{\*\bkmkstart _Toc425750584}{\*\bkmkstart _Toc453201396}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.6.4\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Passing Strings{\*\bkmkend _Ref393876585}{\*\bkmkend _Toc425047505}{\*\bkmkend _Toc425048060}{\*\bkmkend _Toc425329682}{\*\bkmkend _Toc425750584}{\*\bkmkend _Toc453201396} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Passing FORTRAN strings is not standardized among compilers. The RTL currently supports six different methods of passing FORTRAN strings in arguments. The details of the six methods are hidden in the RTL FORTRAN String Conversion Routines, so they all look the same to the application programmer. \par Code that passes a string to or from FORTRAN uses the RTL string conversion routines (}{\b sfor2c}{ and }{\b sc2for}{ family). Code that calls the conversion routines must set the FTN_STRING flag in the imakefile. \par {\*\bkmkstart Heading39}{\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.6.4.1\tab}}\pard\plain \s4\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Accepting FORTRAN Strings in C{\*\bkmkend Heading39} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Writing a C routine that accepts FORTRAN strings as arguments is easy. Use }{\b sfor2c}{ for input from a FORTRAN program and }{\b sc2for}{ for output to a FORTRAN program.\par The }{\b sfor2c}{ and }{\b sc2for}{ family of routines are described, with examples, in \par Typically, a FORTRAN to C bridge routine will first call some of the }{\b sfor2c }{routines to convert all the input strings to C format, then it will call the main C subroutine, and finally it will convert any output strings back to FORTRAN format via the }{\b sc2for}{ family of routines. \par There is no way currently implemented to return CHARACTER*n variables as the function return of a C subroutine. Any output strings should be included as arguments instead. \par {\*\bkmkstart Heading40}{\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.6.4.2\tab}}\pard\plain \s4\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Accepting C Strings in FORTRAN{\*\bkmkend Heading40} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The easiest way to accept C strings in a FORTRAN subroutine is to write the subroutine in C instead. It is possible to accept C strings by doing a two-stage bridge routine. The first stage, written in C, handles the FTN_NAME part of the transfer, and passes the string and its length as arguments to the second bridge.\par The second bridge, written in FORTRAN, accepts the strings as BYTE arrays and uses the SUBLIB routine }{\cs33\f6 mvlc}{ and the passed-in length to convert them to FORTRAN strings, which may then be passed to the FORTRAN main subroutine. To get strings out, the reverse procedure is used. The FORTRAN bridge uses }{\cs33\f6 mvcl}{ to write a BYTE array, then passes that and the length back to the C bridge, which puts a null terminator on the string and returns it to the C caller. \par Examples of this type of bridge are the SPICE bridge routines, in the file SPBRI.COM. One of the bridges, for }{\cs33\f6 bodvar}{, is presented below. The C-callable first bridge follows:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {void zbodvar(body, item, dim, values)\line \line int body;\line char *item;\line int *dim;\line double *values;\line \{\line    int i;\line    i=strlen(item);\line \line    FTN_NAME(xbodvar) (&body, item, &i, dim, values);\line \}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {It takes the length string parameter and passes it with the string pointer to the second-stage bridge. It converts scalar and array arguments, and uses the FTN_NAME macro. The second bridge called by code above follows:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {subroutine xbodvar(body, item, i, dim, values)\line \line       integer body\line       byte item(1)\line       integer i\line       integer dim\line       double precision values(*)\line       character*80 text\line \line       text='\line       if (i.gt.80) call xvmessage('xbodvar, string too long',' ')\line \line C     Transformation to Fortran-string\line       call mvlc(item, text, i)\line \line       call bodvar(body, text, dim, values)\line \line       return\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {It converts the C string (passed as a BYTE array) and length to a FORTRAN CHARACTER*n variable, which is then passed into the }{\cs33\f6 bodvar}{ routine, the FORTRAN -callable version. \par {\*\bkmkstart _Ref395921269}{\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.6.4.3\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Machine Dependencies{\*\bkmkend _Ref395921269} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Machine dependencies can\rquote t always be avoided. Code may be dependent on the operating system (VMS or UNIX), the computer hardware or variety of UNIX. There are significant differences among UNIX implementations.\par Machine dependencies may be isolated into separate source files, and compiled only on the relevant machine. Or machine-dependent code can be written in-line, and the C preprocessor used to select the appropriate version. \par The first solution, separate source files, is appropriate when there are entire routines that are implemented differently under various operating systems. This option is normally used for differences between VMS and UNIX; only rarely will you have separate source files for variants of UNIX. Filenames end in an underscore and the OS name, for example, \rdblquote open_input_file_vms.c\rdblquote  and \ldblquote open_input_file_unix.c\rdblquote . \par Once you have separate working source files, get the appropriate one to compile during a build by modifying the imakefile.\par The MODULE_LIST (or other appropriate macro) is defined based on the machine type. Since vimake uses the C preprocessor, the rules listed below for machine-dependent preprocessor symbols should be used. For example, a program named \ldblquote prog.c\rdblquote  calls a routine that is OS-dependent, named \ldblquote sub_vms.c\rdblquote  and \ldblquote sub_unix.c\rdblquote :\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 #if VMS_OS \line #define MODULE_LIST prog.c sub_vms.c \line #define CLEAN_OTHER_LIST sub_unix.c \line #else \line #define MODULE_LIST prog.c sub_unix.c \line #define CLEAN_OTHER_LIST sub_vms.c \line #endif\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The CLEAN_OTHER_LIST macro deletes the source code for the module not compiled during a clean-source operation.\par The second solution to the machine dependency problem uses the C preprocessor to conditionally compile parts of the code. This method is appropriate for small differences and handling differences between various flavors of UNIX. The necessary preprocessor symbols are defined in }{\cs33\f6 xvmaininc.h}{.\par Use the symbols \ldblquote VMS_OS\rdblquote  and \ldblquote UNIX_OS\rdblquote  to select VMS or UNIX. Use \ldblquote #if \ldblquote  (not \ldblquote #ifdef\rdblquote ). \ldblquote #else\rdblquote  may be used to select the other operating system, but the #else clause must apply to UNIX. Put \ldblquote VMS_OS\rdblquote  in the #if statement. \par To open a standard text file with the }{\cs33\f6 fopen()}{ routine, VMS requires that you give RMS file type arguments to }{\cs33\f6 fopen()}{. Otherwise, EDT will not be able to access the file properly. For example:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 /* Open an output text file */ \line #if VMS_OS \line file = fopen(filename, \ldblquote w\rdblquote ,\rdblquote rat=cr\rdblquote , \ldblquote rfm=var\rdblquote ); \line #else \line file = fopen(filename, \ldblquote w\rdblquote ); \line #endif\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The file xvmaininc.h defines symbols for all the types of machines VICAR runs on, such as: \ldblquote VAX_ARCH\rdblquote , \ldblquote SUN4_ARCH\rdblquote , \ldblquote MAC_AUX_ARCH\rdblquote , etc., but these are never used in program code. For example, the }{\cs33\f6 fstat()}{ system routine returns the optimal blocksize on some machines, but not on others. The Sun 4 and DECstation have it, but Silicon Graphics and HP do not. The }{\cs33\f6 mmap()}{ command, is available on Sun 4 and Silicon Graphics, but not on DECstation or HP; the groupings are different.\par Machine dependencies based on }{\i features}{, rather than}{\i  machines}{  is the proper way to solve the problem. To port to a new system, we determine whether or not it has the feature in question, and modify the include files. For example, the symbol \ldblquote FSTAT_BLKSIZE_OS\rdblquote  defines whether or not }{\cs33\f6 fstat()}{ returns the optimal blocksize. \ldblquote MMAP_AVAIL_OS\rdblquote  defines whether or not the }{\cs33\f6 mmap()}{ routine is present. These and other }{\i feature defines}{, which all end in \ldblquote _OS\rdblquote  by convention, handle machine dependencies. All such definitions end in \ldblquote _OS\rdblquote , so searches through the code to find the machine dependencies are easy.\par The rule is: conditional compilation statements to handle machine dependencies use names of specific features that are required in the code. These names are defined in standard include files based on the machine type. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {Examine xvmaininc.h for current machine dependencies, and check again; it will change. There are machine dependencies that aren't listed in xvmaininc.h. Contact the VICAR system programmer to add the dependency to xvmaininc.h. This is the only include file an imakefile can use. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Since xvmaininc.h is under the control of the VICAR system programmer, it is not always possible for an application programmer to have it modified on short notice. \ldblquote vmachdep.h\rdblquote  is provided in the portable includes (p2$inc on VMS and $P2INC on UNIX). It contains dependencies that are needed only by application programs. If your definition is in vmachdep.h, it must be included in your source.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {Use the style of xvmaininc.h when adding new dependencies to \ldblquote vmachdep.h\rdblquote , and make sure you determine the correct setting for every architecture VICAR supports. If you can't find out, contact the system programmer, and if you still can't, make note of the unknowns in the include file. Reserve \ldblquote vmachdep.h\rdblquote , add your definition, and redeliver it, even if your application isn't ready for delivery. Then other programmers can modify the file as well. Don\rquote t sit on \ldblquote vmachdep.h\rdblquote ! Following are examples:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {#if FTRUNCATE_AVAIL_OS\line    if (ftruncate(devstate->dev.disk.channel, j) != 0)\line       status = errno;\line    else\line #endif\line       status = SUCCESS;\line \line ...\line \line #if OPEN_PROTECT_OS\line    file = open(filename, O_RDWR|O_CREAT, 0666);\line #else\line    file = open(filename, O_RDWR|O_CREAT);\line #endif\line \line ...\line \line /* This example shows finding the EOF with and without fstat */\line \line #if FSTAT_AVAIL_OS\line #if VMS_OS\line #include <stat.h>\line #else\line #include <sys/types.h>\line #include <sys/stat.h>\line #endif\line #else\line #include seek_include\line #endif\line ...\line #if FSTAT_AVAIL_OS\line    struct stat statbuf;\line #endif\line ...\line #if FSTAT_AVAIL_OS\line    status = fstat(file, &statbuf);\line    if (status != 0) return errno;\line    eof = statbuf.st_size;\line #else                                      /* fstat not available */\line    status = lseek(file, 0, SEEK_END);\line    if (status == -1) return errno;\line    eof = status;\line #endif\par {\*\bkmkstart Heading41}{\*\bkmkstart _Toc425047506}{\*\bkmkstart _Toc425048061}{\*\bkmkstart _Toc425750585}{\*\bkmkstart _Toc453201397}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.7\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Writing Portable FORTRAN{\*\bkmkend Heading41}{\*\bkmkend _Toc425047506}{\*\bkmkend _Toc425048061}{\*\bkmkend _Toc425750585}{\*\bkmkend _Toc453201397} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This Section discusses writing portable FORTRAN code for VICAR applications and describes how to deal with machine dependencies in VICAR code. It does not explain the rules for writing portable FORTRAN; see a reference book on FORTRAN. There are a few allowed VMS extensions to FORTRAN, which are described below.\par {\*\bkmkstart Heading42}{\*\bkmkstart _Toc425047507}{\*\bkmkstart _Toc425048062}{\*\bkmkstart _Toc425329683}{\*\bkmkstart _Toc425750586}{\*\bkmkstart _Toc453201398}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.7.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {RTL Issues{\*\bkmkend Heading42}{\*\bkmkend _Toc425047507}{\*\bkmkend _Toc425048062}{\*\bkmkend _Toc425329683}{\*\bkmkend _Toc425750586}{\*\bkmkend _Toc453201398} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Portable FORTRAN applications use the rules below when calling the RTL: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b Terminator}{. RTL routines with keyword-value pairs of optional arguments have a terminator in the argument list, even if none of the optional arguments are used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Character strings. }{Strings input to the RTL are CHARACTER*n variables or constants. Both for string arguments and token words in keyword-value pairs. See }{\field{\*\fldinst { REF Heading46 \\n  \\* MERGEFORMAT }}{\fldrslt {2.7.4}}}{ }{\field{\*\fldinst { REF Heading46 \\* MERGEFORMAT }}{\fldrslt {READ & WRITE to Strings}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading46 }}{\fldrslt {\cs109\lang1024 38}}}{\cs109 ).}{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b Optional arguments. }{Pure optional arguments are not allowed. Most routines require all arguments to be specified.\par {\*\bkmkstart Heading44}{\*\bkmkstart _Toc425047508}{\*\bkmkstart _Toc425048063}{\*\bkmkstart _Toc425329684}{\*\bkmkstart _Toc425750587}{\*\bkmkstart _Toc453201399}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.7.2\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {No EQUIVALENCE for Type Conversion{\*\bkmkend Heading44}{\*\bkmkend _Toc425047508}{\*\bkmkend _Toc425048063}{\*\bkmkend _Toc425329684}{\*\bkmkend _Toc425750587}{\*\bkmkend _Toc453201399} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The use of EQUIVALENCE to convert among datatypes, especially byte to integer, is a common trick. This practice is not portable. EQUIVALENCE must not be used to convert any data types. EQUIVALENCE is used only to conserve memory. Access the data using the same data type you stored it with.\par We recommend the }{\b x/zvtrans}{ family of routines for data conversion. See }{\field{\*\fldinst { REF Heading9 \\n  \\* MERGEFORMAT }}{\fldrslt {1.6}}}{ }{\field{\*\fldinst { REF Heading9 \\* MERGEFORMAT }}{\fldrslt {Converting Data Types & Hosts}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{. An alternative efficient method for converting between byte and integer uses the functions }{\cs33\f6 INT2BYTE}{ and }{\cs33\f6 BYTE2INT}{. Include the file \ldblquote fortport\rdblquote  in your subroutine. \ldblquote fortport\rdblquote  is a SUBLIB include; add it to FTNINC_LIST in the imakefile. \par }{\cs33\f6 INT2BYTE}{ and }{\cs33\f6 BYTE2INT}{ assume that the data is in the 0 to 255 range. No bounds checking is performed. The functions are implemented either as array lookups (rather than functions), or as statement functions, so the include file must be present to get the appropriate definition. Example:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {SUBROUTINE do_something(b, i)\line         BYTE b\line         INTEGER i\line         INCLUDE 'fortport'\line         b = INT2BYTE(i)\line         i = BYTE2INT(b)\line         RETURN\par {\*\bkmkstart Heading45}{\*\bkmkstart _Toc425047509}{\*\bkmkstart _Toc425048064}{\*\bkmkstart _Toc425329685}{\*\bkmkstart _Toc425750588}{\*\bkmkstart _Toc453201400}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.7.3\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {CHARACTER*n for Strings{\*\bkmkend Heading45}{\*\bkmkend _Toc425047509}{\*\bkmkend _Toc425048064}{\*\bkmkend _Toc425329685}{\*\bkmkend _Toc425750588}{\*\bkmkend _Toc453201400} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The FORTRAN standard does not support the use of BYTE arrays as character strings. They must be declared as CHARACTER*n variables. Moreover, descriptors are not used on most machines, so there is no way to tell the difference between a BYTE and a CHARACTER*n variable. Since CHARACTER*n variables have a declared length associated with them, and BYTE arrays do not, any routine expecting a length will get garbage if a BYTE variable is passed in. \par The RTL expects that }{\i all}{ strings will be CHARACTER*n variables. This applies to all RTL routines, but is especially important for the output routines }{\b qprint}{ and }{\b x/zvmessage}{ (}{\b x/zvmessage}{ is preferred over }{\b qprint}{ for new code). All strings destined for output must be CHARACTER*n variables. }{\field{\*\fldinst { REF Heading46 \\* MERGEFORMAT }}{\fldrslt {READ & WRITE to Strings}}}{ (page }{\field{\*\fldinst { PAGEREF Heading46 }}{\fldrslt {\lang1024 38}}}{) discusses how to do output conversion to create the strings.\par While changing output strings to CHARACTER*n is possible, there are many areas in the code, in files and data structures, where strings are stored in BYTE arrays, and it is not practical to change. For that reason, character strings in BYTE arrays may be used if it is embedded too deeply to change. The SUBLIB routines }{\cs33\f6 mvcl}{ and }{\cs33\f6 mvlc}{ have been provided to convert between BYTE arrays and CHARACTER*n variables. Do }{\i not}{ copy data directly to a CHARACTER*n variable from a BYTE array, or vice-versa, since that will fail if there are descriptors.\par Subroutines should use CHARACTER*n string arguments. In cases where it is impractical to change, BYTE arrays may be passed. Passing a CHARACTER*n argument where a BYTE array is expected is just as bad as the opposite. If possible, include separate entry points to the routine that accept both types. For example, the routine }{\cs33\f6 vic1lab}{ returns data in a character string, while }{\cs33\f6 vic1labx}{ returns data in a BYTE array. \par {\*\bkmkstart Heading46}{\*\bkmkstart _Toc425047510}{\*\bkmkstart _Toc425048065}{\*\bkmkstart _Toc425329686}{\*\bkmkstart _Toc425750589}{\*\bkmkstart _Toc453201401}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.7.4\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {READ & WRITE to Strings{\*\bkmkend Heading46}{\*\bkmkend _Toc425047510}{\*\bkmkend _Toc425048065}{\*\bkmkend _Toc425329686}{\*\bkmkend _Toc425750589}{\*\bkmkend _Toc453201401} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {To perform input and output conversion, use the FORTRAN I/O package on an \ldblquote internal file\rdblquote . An internal file to FORTRAN is simply a CHARACTER*n variable. Give the name of the variable (it may be a substring) instead of the unit number in a FORTRAN READ or WRITE statement. Write to a string and send the string to }{\b qprint}{ or }{\b x/zvmessage}{. Do not attempt to write directly to the terminal. Any messages written directly to the terminal will not appear in the session log and maybe printed in unexpected ways due to interaction with VICAR I/O or SAGE.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {Here is one way to code the above example (the leading blank is not required in }{\b xvmessage}{):\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {REAL*8 VRES, VRAD, VTAN\line       CHARACTER*80 MS1\line       WRITE (MS1,1001) VRES, VRAD, VTAN\line  1001 FORMAT ('VEL=', F9.2, ' (VRAD,VTAN)=(', F7.2, ',', F9.2, ') M/SEC')\line       CALL XVMESSAGE(MS1, ')}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {There are three things to note about this example:\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {The DATA statement is separate from the declaration. Putting initialization data on the declaration line is not portable.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {The format specifier may be put in-line in the WRITE statement if you wish.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {The numbers changed from the }{\cs18\f6 outcon}{ call because the leading blank was eliminated. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The }{\b xvmessage}{ routine always prints the first character, with no carriage control. So, all the character position numbers are one less than in the }{\cs33\f6 outcon}{ example. \par Conversion of data from string to numeric form using READ is similar. Use standard FORTRAN I/O using the CHARACTER*n variable as the internal file. Substrings are much more useful on READ to read only the portion you are interested in. For example, the following call form is typical: }{\cs33\f6 \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {CALL INCON(NPAR, %REF(ALABEL(OFF+I+5:)),PAR,20)\line       BUF(2) = PAR(1)                 !Frame number}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {where ALABEL is the input string (already a CHARACTER*n variable), BUF(2) is an integer receiving the value, and NPAR is ignored. The value is an integer in the range 0 to 99 (obtained from the documentation), so this call could be converted to:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 READ (ALABEL(OFF+I+5:),'BN,I2') BUF(2)\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {You may want to make use of the ERR=n clause on reads in order to trap errors such as a decimal point being present in an integer. \par {\*\bkmkstart Heading48}{\*\bkmkstart _Toc425047511}{\*\bkmkstart _Toc425048066}{\*\bkmkstart _Toc425329687}{\*\bkmkstart _Toc425750590}{\*\bkmkstart _Toc453201402}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.7.5\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {VMS FORTRAN Extensions{\*\bkmkend Heading48}{\*\bkmkend _Toc425047511}{\*\bkmkend _Toc425048066}{\*\bkmkend _Toc425329687}{\*\bkmkend _Toc425750590}{\*\bkmkend _Toc453201402} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {VMS has many non-standard extensions to its FORTRAN compiler, which are used frequently in VICAR code. Some of these extensions are widely available in other vendors' FORTRAN compilers, while others are not. Only standard FORTRAN77 code should be used in a portable program.\par To find out what is standard and what isn't, refer to the ANSI FORTRAN standard, or the }{\i VAX FORTRAN Language Reference Manual}{. Anything printed in blue in that manual is non-standard FORTRAN and should not be used, except as noted below. \par Some of the FORTRAN extensions are so useful that it would be impractical to write VICAR code without them. Fortunately, these extensions are common industry-wide and are available in the FORTRAN compilers for every machine MIPL is interested in. Therefore some extensions to standard FORTRAN77 are allowed. These extensions are listed below.\par You should not use any non-standard statements or features that are not mentioned below. If you absolutely have to, then make sure it is isolated in a machine-specific section of code, and  provide a means for performing the same function on machines that don't have that extension.\par Following are the }{\i only }{permit VMS FORTRAN extensions: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {BYTE and INTEGER*2 data types. (Not LOGICAL*1). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Data type length specifiers in general (i.e. The *2 in INTEGER*2). They should only be used for pixel declarations, as listed. See }{\field{\*\fldinst { REF _Ref393695027 \\* MERGEFORMAT }}{\fldrslt {Table 6: FORTRAN declarations for pixel types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393695036 }}{\fldrslt {\cs109\lang1024 26}}}{\cs109 )}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {DO-WHILE loops. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {DO-END DO loops. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {INCLUDE statement (see above for usage). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Symbolic names up to 31 characters, with at least 14 significant in external names. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Lowercase letters and underscore (_) are allowed in symbolic names. Names are not case sensitive. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Exclamation point () starts a comment anywhere in the source line. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Tab-format source lines (source lines may start with a TAB character). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {IMPLICIT NONE statement. \par {\*\bkmkstart Heading49}{\*\bkmkstart _Toc425047512}{\*\bkmkstart _Toc425048067}{\*\bkmkstart _Toc425329688}{\*\bkmkstart _Toc425750591}{\*\bkmkstart _Toc453201403}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.7.6\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {VMS-Specific Code{\*\bkmkend Heading49}{\*\bkmkend _Toc425047512}{\*\bkmkend _Toc425048067}{\*\bkmkend _Toc425329688}{\*\bkmkend _Toc425750591}{\*\bkmkend _Toc453201403} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Many current VICAR applications and subroutines have VMS-specific code embedded in them. Some of it is obvious, like a system service call. Some is insidiously difficult to find, like using a double precision floating point value as a single. This works on VMS because the first half of a double value looks like a float. This is not the case on any other machine. \par All VMS-specific code must be eliminated or isolated. If the same thing can be done in a portable way, do it that way. If not, then isolate the VMS-specific code and write UNIX code to perform the same function. If the function is useful as a general-purpose subroutine, then put it in SUBLIB. If not, include it with your code. See }{\field{\*\fldinst { REF _Ref395921269 \\n  \\* MERGEFORMAT }}{\fldrslt {2.6.4.3}}}{ }{\field{\*\fldinst { REF _Ref395921269 \\* MERGEFORMAT }}{\fldrslt {Machine Dependencies}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395921269 }}{\fldrslt {\cs109\lang1024 33}}}{\cs109 )}{ for methods of dealing with machine-dependent code. \par An attempt is made below to list the types of VMS-specific code you will run into. This is not and can not be an exhaustive list, as there are far too many potential problem areas that will only be uncovered with more experience. Use this list as examples of what to look out for. You should be familiar with writing portable FORTRAN code; if not then see a standard FORTRAN manual (the black type in the }{\i VAX FORTRAN Language Reference Manual}{ is a good source).\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {The order of bytes in an integer (or any other data type) is reversed on VMS with respect to most other machines. Any code that depends on byte order must be changed to not do so. Byte-order dependencies typically come from converting between BYTE and other data types, where the first byte of an integer is set to the value of a byte, then used as an integer. This is typically accomplished via EQUIVALENCE. Use the }{\b x/zvtrans}{ routines or the }{\cs33\f6 BYTE2INT}{ and }{\cs33\f6 INT2BYTE}{ method described above instead. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Integers and double precision floating point values must not be used as INTEGER*2s or REALs without conversion. On VMS, the address of a double could be treated as the address of a real, or they could be equivalenced to each other. This worked because the bit pattern for the first half of a double is the same as for a real. The same is true for short vs. normal integers. A pointer to an INTEGER could be treated as a pointer to an INTEGER*2 or even a BYTE. This is not valid on non-VMS systems. The IEEE floating point standard uses different bit patterns for doubles and for single-precision reals. For integers, most other machines use the \ldblquote big-endian\rdblquote  byte order. The first bytes of an INTEGER are actually the higher-order bytes, unlike VMS, so the value cannot be treated as an INTEGER*2. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {This practice is most common (and hardest to find) in subroutine calls, where a program is sloppy about passing data of the correct type. If the subroutine expects a REAL, the value passed in better be a REAL and not a DOUBLE PRECISION. The same is true for INTEGER, INTEGER*2, and BYTE. Be }{\i very}{ careful to watch out for this, as it is difficult to find. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {VMS System Calls must be eliminated or isolated. These include a whole range of things, like system services (SYS$), VMS Run-Time Library calls (LIB$, etc., not to be confused with the VICAR RTL), RMS calls or structures, QIO calls for I/O, AST's (asynchronous system traps), and anything else that is VMS specific. Any subroutine or structure with a dollar sign ($) is suspect, as most VMS system routines have $ in the name. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {There are two choices for dealing with these. The first is to dispense with system-specific calls and do things in a standard way, when possible. This could be achieved by using standard UNIX-style calls that do the same thing (many of which are implemented under VMS), which may imply calling C code that calls the UNIX routines. The second is to isolate the VMS-specific code, and write corresponding code that works on a UNIX system. Both versions could either be included as separate modules in the program itself, or they could be put in a SUBLIB subroutine if it's a capability that could be generally useful. See }{\field{\*\fldinst { REF _Ref395921269 \\n  \\* MERGEFORMAT }}{\fldrslt {2.6.4.3}}}{ }{\field{\*\fldinst { REF _Ref395921269 \\* MERGEFORMAT }}{\fldrslt {Machine Dependencies}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395921269 }}{\fldrslt {\cs109\lang1024 33}}}{\cs109 )}{ for ways of handling machine-dependent code. In general, system routines should not be called from FORTRAN, as there is little standardization. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {Assembly language (called Macro on the VAX) included in the program will  have to be rewritten. You could write assembler versions for every machine supported, but this is }{\i highly}{ discouraged. The best solution is to write the subroutine in a high-level language, preferably C. FORTRAN could be used, but C is generally a better match to assembly language.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Character strings must be CHARACTER*n variables instead of BYTE, LOGICAL*1, or INTEGER arrays. This topic is discussed in depth above. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {FORTRAN -C interfaces must be checked. There are several rules for mixing FORTRAN and C, including having separate names for subroutines that are to be called from both FORTRAN and C. Make sure you don't call a subroutine from FORTRAN by its C interface, or vice-versa, as that is not portable. String handling is a particular problem. See}{\ul  }{\field{\*\fldinst { REF Heading37 \\n  \\* MERGEFORMAT }}{\fldrslt {2.6}}}{ }{\field{\*\fldinst { REF Heading37 \\* MERGEFORMAT }}{\fldrslt {Mixing FORTRAN and C}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading37 }}{\fldrslt {\cs109\lang1024 28}}}{\cs109 )}{, for details. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Make sure that }{\i all}{ input operations from files can accept files written on a foreign machine. This is often handled automatically, but there are cases where it is not. See }{\field{\*\fldinst { REF Heading5 \\n  \\* MERGEFORMAT }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{ for details.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Do not assume that you know the size of a pixel in an inputfile. An integer may not be four bytes on every machine that VICAR runs on. Use the RTL routines }{\b x/zvpixsize}{, }{\b x/zvpixsizeu}{, or }{\b x/zvpixsizeb}{ to get the size of a pixel. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Knowledge of the bit patterns used to store data is not portable, especially floating-point data. This is not very common, but any code that does bit-twiddling is likely to have problems. Byte-order dependencies often creep into this sort of code. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Use of EQUIVALENCE to access the same bit pattern in different ways is highly unportable. If EQUIVALENCEs are used, make sure you use only one of the definitions for any given piece of data. If you use the other definition, put a new value of that type in to the EQUIVALENCE. Be careful when mixing INTEGER and REAL data types in a single array (the FORTRAN way of doing structures). While that can be legitimate if done properly, care has to be taken since the data sizes may not be the same on all machines. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Optional arguments are not allowed in subroutines. Supply all the arguments the subroutine requires. If you are porting a subroutine that accepts optional arguments, you have the choice of eliminating the extra arguments, forcing them to be there, or creating different subroutine names with different numbers of arguments. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Do not use numeric constants for things like error numbers. VICAR constants could change in the future, and \ldblquote CANNOT_FIND_KEY\rdblquote  is much more understandable than \ldblquote -38\rdblquote . Use the VICAR include files when needed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Variable and subroutine names must not conflict with UNIX system routines or the RTL internal routines. Most UNIX machines do not have the concept of a shareable image like VMS does. Shareable images allowed subroutine libraries such as the RTL to hide their internals from the program. Without them, the entire RTL is linked with your program. This greatly increases the chance of name collisions, as the internal RTL subroutine names (and TAE and SPICE and X-windows and ...) are suddenly visible, and some of the names are fairly common. Be very careful with subroutine and global variable names. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The ultimate solution to this problem is to have a consistent naming scheme for RTL internal names that won't conflict with applications. Until this is implemented, however, watch out for conflicts. Even this fix won't help other subroutine packages that MIPL does not have direct control over, such as TAE, SPICE, and X-windows. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {There are many differences in the file system and filename structure between VMS and UNIX. The VMS path name of \ldblquote }{\cs33\f6 disk:[dir.subdir]file.ext;version}{\rdblquote  is quite different from the UNIX path name of \ldblquote  }{\cs33\f6 /dir/subdir/subdir/filename}{\rdblquote . Logical names do not exist under UNIX. The analog to logical names, environment variables, act quite differently in many respects (for example, the system }{\cs33\f6 open()}{ call doesn't know how to deal with environment variables, although }{\b x/zvopen}{ and }{\b x/zvfilename}{ do).\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Filenames and path names that are embedded in the program should be removed and made available as arguments, both to handle architecture differences and differences in directory structure on other machines. Any code that parses filenames from user input must be aware of the differences and have code to handle each system. Such code should be rare as the RTL does most of the filename parsing; however, it does exist. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {Filenames and path names tend to be longer under UNIX than VMS. Many current programs arbitrarily limit filename parameters to 40 or even 20 characters in the PDF and in the code. These limits need to be lifted. Most of the time, the program never sees the filename (it lets }{\b x/zvunit}{ take care of it), so the solution is simply to not specify the maximum string length in the PDF. Instead of \ldblquote (STRING,40)\rdblquote , use \ldblquote STRING\rdblquote . If you need a buffer in the program code to handle the filename, allow at least 255 characters (which is slightly more than the maximum TAE string size). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {The filenames of the program units themselves will need changing. FORTRAN language modules must end in a \ldblquote .f\rdblquote , }{\i not}{ \ldblquote .for \ldblquote , to be compatible with vimake. UNIX likes \ldblquote .f\rdblquote , and it is more picky about filename extensions than VMS is.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Many VAX FORTRAN language extensions are used in current VICAR code. A small subset of extensions is allowed (they are listed above), since they are available on all machines of interest. All other extensions will have to be removed, as they are not portable. Check the }{\i VAX FORTRAN Language Reference Manual}{ for the feature in question. If it is printed in blue ink, then it is not portable and may not be used, unless it is in the above list. \par {\*\bkmkstart Heading51}{\*\bkmkstart _Toc425047513}{\*\bkmkstart _Toc425048068}{\*\bkmkstart _Toc425750592}{\*\bkmkstart _Toc453201404}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 2.8\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Portable TAE Command Language (TCL{\*\bkmkend Heading51}){\*\bkmkend _Toc425047513}{\*\bkmkend _Toc425048068}{\*\bkmkend _Toc425750592}{\*\bkmkend _Toc453201404}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The dcl command allows you to put VMS DCL commands in your procedure, which are not portable. The corresponding command under UNIX is }{\cs33\f6 ush}{, which allows you to execute shell commands inside the procedure. \par In order to use the }{\cs33\f6 dcl}{ or }{\cs33\f6 ush}{ commands, there has to be some way of determining which operating system you are on. A global variable called \ldblquote $syschar\rdblquote  holds the type of operating system. Index 1 in this variable is either \ldblquote UNIX\rdblquote  or \ldblquote VAX_VMS\rdblquote . For example:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {procedure\line parm file string\line refgbl $syschar\line body\line if ($syschar(1) = "UNIX")\line   ush rm &file\line else\line   dcl delete &file\line end-if\line end-proc}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Unfortunately, there appears to be no straightforward way to determine the particular version of UNIX, so use common shell commands. \par Another major trouble area for TCL is filenames. Filenames and path names look much different under VMS and UNIX. There is a lot of TCL code in VICAR that parses filenames, appends filenames to directories, etc. Many test scripts use hardcoded VMS directories and filenames to find test files. All of these will have to change. The same \ldblquote $syschar\rdblquote  variable can be used to do different things with the filename, or pick different testfiles, based on which system you are using. \par The \ldblquote $syschar\rdblquote  variable may also be tested inside help files, help within a PDF, and menus via special conditional commands. These commands are part of TAE, but they are not documented by TAE. The conditionals test to see if the given string is in any element of the \ldblquote $syschar\rdblquote  variable. Like other PDF/MDF directives, they should appear on a line by themselves with period \ldblquote .\ldblquote  in the first column: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b .if }{\b\i string}{: Prints the following lines (up to .elseif or .ifend) if }{\i string }{is in \rdblquote $syschar\rdblquote . \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b .ifn }{\b\i string}{: Prints the following lines (up to .elseif or .ifend) if }{\i string}{ is not in \rdblquote $syschar\rdblquote . \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b elseif }{\b\i string}{: Prints the following lines of text (up to .ifend or another .elseif) if the previous condition was not met, and}{\i  string}{ is in \ldblquote $syschar\rdblquote . \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b .ifend}{: Ends a conditional clause. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b .if1 }{\b\i string}{: Single-line conditional}{\caps . j}{ust like .if, but only the next line is printed, and no .ifend is required. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b .ifn1 }{\b\i string}{: Single-line negative conditional}{\caps . j}{ust like .ifn, but only the next line is printed, and no .ifend is required. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The following example is taken from the TAE command mode help file (commode.hlp): \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {                CONT*INUE\line .if VAX_VMS\line                 DCL              any-VMS/DCL-command\line                 DCL-NOINTERRUPT  any-VMS/DCL-command\line .ifend\line                 DEFC*MD COMMAND=command-name STRING=replacement-string\line \line ...\line \line                 T*UTOR-NOSCREEN PROC=proc-subcmd  parameters\line .if1 UNIX\line                 USH any-UNIX/shell-command\line                 WAIT-ASYNC JOB=job-name-list\line \line ...\line \line                         RUNTYPE Command Qualifier (continued)\line \line            If the command qualifier is set to BATCH, the following TAE\line            message is displayed:\line \line .if VAX_VMS\line                Job (nnn) submitted to queue (que)\line \line            where "nnn" is the assigned job number and "que" is\line            the name of the queue the job was submitted to.\line \line .elseif UNIX\line                 Batch job file "filename" submitted successfully.\line \line            where "filename" is the batch job file name, defined\line            as "proc".job.\line \line .ifend\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\cs33\f6 R}{efer to the TAE documentation if you have more questions on writing portable TCL. \par }\pard \li360\sb120\sa120\nowidctlpar\adjustright {\sect }\sectd \linex0\headery1440\footery706\colsx709\endnhere\sectdefaultcl {\headerl \pard\plain \s42\li360\sb120\sa120\nowidctlpar\brdrb\brdrs\brdrw15 \tqr\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst {\cs44  PAGE }}{\fldrslt {\cs44\lang1024 160}}}{\cs44 \tab }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1"\\n \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 13}}}{\cs44     }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 Appendix E: About This Document}}}{\par }}{\headerr \pard\plain \s42\li360\sb120\sa120\nowidctlpar\brdrb\brdrs\brdrw15 \tqr\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst {\cs44  STYLEREF \\n"Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 13}}}{\cs44    }{\field{\*\fldinst {\cs44  STYLEREF "Heading 1" \\* MERGEFORMAT }}{\fldrslt {\cs44\lang1024 Appendix E: About This Document}}}{\cs44 \tab }{\field{\*\fldinst {\cs44  PAGE }}{\fldrslt {\cs44\lang1024 159}}}{\par }}{\*\bkmkstart Heading68}{\*\bkmkstart Heading63}{\*\bkmkstart _Ref396007946}{\*\bkmkstart _Ref396008052}{\*\bkmkstart _Toc425047514}{\*\bkmkstart _Toc425048069}{\*\bkmkstart _Toc425750593}{\*\bkmkstart _Toc453201405}{\*\bkmkend Heading52}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 3.\tab}\pard\plain \s1\li360\sb60\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Image I/O{\*\bkmkend _Ref396007946}{\*\bkmkend _Ref396008052}{\*\bkmkend _Toc425047514}{\*\bkmkend _Toc425048069}{\*\bkmkend _Toc425750593}{\*\bkmkend _Toc453201405} \par {\*\bkmkstart _Toc425047515}{\*\bkmkstart _Toc425048070}{\*\bkmkstart _Toc453201406}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.1\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Introduction{\*\bkmkend _Toc425047515}{\*\bkmkend _Toc425048070}{\*\bkmkend _Toc453201406}\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {This Section describes the image I/O to be used with the MIPL VICAR image processing executive. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Note that a x/zvread or x/zwrite operation, without specifying the location (line/sample/band), automatically reads the "next" record. In BSQ this is the next line. See }{\field{\*\fldinst { REF _Ref453168521 \\r \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f005200650066003400350033003100360038003500320031000000}}}{\fldrslt {3.2.6}}}{ }{\field{\*\fldinst { REF _Ref453168463 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f005200650066003400350033003100360038003400360033000000}}}{\fldrslt {x/zvread\emdash Read a line}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref425739967 }}{\fldrslt {\cs109\lang1024 68}}}{) for more information.\par {\*\bkmkstart _Toc453201407}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.1.1\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Unix filename expansion{\*\bkmkend _Toc453201407}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Under Unix, filenames accepted by the RTL (via x/zvunit), either the U_NAME optional or the INP or OUT parameters) now can contain environment variables and usernames. A reference of the form }{\i $var}{ will be replaced with the value of the environment variable }{\i var}{.  The name of the environment variable (but not the dollar sign) may optionally be enclosed in curly braces ($\{}{\i var}{\}).  A tilde (~) followed by a username will be replaced with the home directory of that user.  A tilde without a username will be replaced with the home directory of the current account.  Both of these expansions exactly mimic the behavior of the C-shell, so they should be familiar to most Unix users.\par {\*\bkmkstart _Toc453201408}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.1.2\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Temporary files{\*\bkmkend _Toc453201408}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Filenames that begin with a plus sign (+) are treated as }{\i temporary}{ files in both Unix and VMS.  The old VMS VICAR style of specifying temporary filenames was to leave off the filename extension, which was replaced with a .Z}{\i xx}{ extension (where }{\i xx}{ is based on the process ID).  This approach still works under VMS, but it is not supported under Unix.  A Unix filename can have no extension and still be perfectly legal.  Plus, it is infeasible to search all the user's directories to delete temporary files when the user logs off (which is what happens under VMS).\par Instead of scattering temporary files all over the place (distinguised by their name), the new style is to collect them all in one directory.  Prepending a plus sign (+) to the name tells the VICAR RTL to put the files in the temporary directory.  This directory is pointed at by the $VTMP environment variable in Unix, and the VTMP: rooted logical name in VMS.  VTMP is set up by vicset2 for both systems (it normally points at /tmp/}{\i username}{ for Unix and a scratch directory for VMS).  Because VTMP: is a rooted directory, accessing the top-level directory outside of VICAR is a little more difficult; you must use \ldblquote vtmp:[000000]\rdblquote .\par Subdirectories of VTMP are allowed.  Under Unix, they look like \ldblquote +sub/dir/file\rdblquote , while under VMS, they look like \ldblquote +[sub.dir]file\rdblquote .  The subdirectories are not automatically created; use \ldblquote mkdir $VTMP/sub/dir\rdblquote  under Unix and \ldblquote cre/dir vtmp:[sub.dir]\rdblquote  under VMS.  Because of these differences, the use of subdirectories is not portable between systems.\par Currently, all processes using the same login id share the same temporary directory. This may be changed in the future so concurrent independent jobs will have separate directories. In the meantime, a workaound is to redefine VTMP to use a process-specific directory name.\par {\*\bkmkstart _Toc453201409}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.1.3\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Filename Expansions{\*\bkmkend _Toc453201409}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Any time the RTL accepts a filename (x/zvunit or x/zvfilename), there\par are a number of expansions that can occur, most of which will be familiar to\par C-shell programmers.  Also, a special syntax for temporary files has been\par provided. \par For UNIX, the expansions are as follows: \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\cs33\b\f6 $var}{:Expand environment variable \ldblquote }{\cs33\f6 var}{\rdblquote . \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 $\{var\}}{:Expand environment variable \ldblquote }{\cs33\f6 var}{\rdblquote . \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 ~user}{: Expand to home directory of user\rdblquote }{\cs33\f6 user}{\rdblquote . \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 ~}{: Expand to home directory of current user (}{\cs33\f6 $HOME}{). \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 $$}{: Insert a single }{\cs33\f6 $}{ (no environment variable). \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 +}{: Expand to translation of }{\cs33\f6 \rdblquote $VTMP/}{\rdblquote  for temporary files. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {For VMS, the expansions are as follows: \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\cs33\b\f6 +}{: Expand to \ldblquote }{\cs33\f6 vtmp:}{\rdblquote  (if subdirectory present) or \ldblquote }{\cs33\f6 vtmp:[000000]}{\rdblquote (if no subdirectory) for temporary files. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b no }{\cs33\b\f6 +}{\b  and no suffix}{: Append \ldblquote . Z }{\i xx}{\rdblquote  (where }{\i xx}{ comes from }{\cs33\f6 v2$pidcode}{) for old-style temporary names. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Under VMS, both expansions may occur on the same name. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {The temporary filename locations (}{\cs33\f6 $VTMP}{ and }{\cs33\f6 vtmp}{) are set up in vicset2.\par {\*\bkmkstart Heading53}{\*\bkmkstart _Toc425047516}{\*\bkmkstart _Toc425048071}{\*\bkmkstart _Toc453201410}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Image I/O {\*\bkmkend Heading53}{\*\bkmkend _Toc425047516}{\*\bkmkend _Toc425048071}API{\*\bkmkend _Toc453201410} \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst { TOC \\b "Image" \\n}}{\fldrslt {\lang1024 3.2.1\tab x/zvadd\emdash Add information to control block\par 3.2.2\tab x/zvclose Close a file\par 3.2.3\tab x/zveaction\emdash Set the default error handling action\par 3.2.4\tab x/zvget\emdash Retrieve control block information\par 3.2.5\tab x/zvopen\emdash Open a file\par 3.2.6\tab x/zvread\emdash Read a line\par 3.2.7\tab x/zvsignal\emdash Signal an error\par 3.2.8\tab x/zvunit\emdash Assign a unit number to a file\par 3.2.9\tab x/zvwrit\emdash Write an image line\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid }}\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {The nine routines for image I/O (line I/O and array I/O) are described below. A description of the optional arguments follows each subroutine description. \par {\*\bkmkstart Heading54}{\*\bkmkstart _Toc425047517}{\*\bkmkstart _Toc425048072}{\*\bkmkstart _Toc425329689}{\*\bkmkstart Image}{\*\bkmkstart _Toc453201411}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvadd\emdash Add information to control block{\*\bkmkend Heading54}{\*\bkmkend _Toc425047517}{\*\bkmkend _Toc425048072}{\*\bkmkend _Toc425329689}{\*\bkmkend _Toc453201411} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvadd(unit, status, <optionals>, ' ')}{\cs33 \line }{status = zvadd(unit, <optionals>, 0);}{\cs33 \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvadd}{ updates the internal control block information describing the file associated with UNIT. Each item of information is identified by a key word and is followed by a value which holds the update information. The keyword-value pairs are optional and may be entered in any order. To process the file,}{\b  x/zvadd}{ must be called before opening (with }{\b x/zvopen}{) the file. \par }{\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line Unit number of file from }{\b x/zvunit}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer \line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395971271 }}{\fldrslt {\cs109\lang1024 140}}}{\cs109 )}{. See also the optional arguments OPEN_ACT, IO_ACT, LAB_ACT, and ERR_ACT. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b U_NL:}{ input, integer \line Indicates that the Executive is to create an output file capable of holding NL lines. If the file associated with the unit number already exists but is too small, it will be enlarged. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NS:}{ input, integer \line As in NL but for samples. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NB:}{ input, integer \line As in NL but for bands. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NBB:}{ input, integer \line For output files, indicates the number of bytes of binary prefix that will precede each image line. The binary prefix will be stored in an area before each image line. It will be hidden from subsequent programs unless the program opens the file with a COND value that includes BINARY. Subsequent reads of a file with COND including BINARY will return the binary prefix to each line ahead of the line in the read buffer. An output file with a non-zero U_NBB will expect the binary prefix to precede the image line in the }{\b x/zvwrit}{ buffer. For input files U_NBB is ignored. Defaults to 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NLB:}{ input, integer \line For output files, indicates the number of lines of binary header information that is to precede the image lines in an image file. The image I/O subsystem will expect these lines to be written with }{\b x/zvwrit}{ prior to the writing of the image lines. The image header will remain hidden from subsequent programs unless those programs open the file with a value of COND that includes the substring, BINARY. For input files, }{\b U_NLB}{ is ignored. Defaults to 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_N1, U_N2, U_N3}{: input, integers \line Indicate that the Executive is to ensure that the output file will have the dimensions specified by the values associated with the respective arguments. U_N1 refers to the first file dimension, U_N2 the second, and U_N3 the third. These arguments are useful for the program which does not care about the file organization, and simply wants to deal with records and pixels. The relation between these arguments and the normal NL, NS, NB arguments are as follows:}{\cs33\f6 \par }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx828\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1644\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2460\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx3276\pard\plain \li360\sb60\sa60\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\cs33\f6 ORG\cell N1\cell N2\cell N3\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx828\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1644\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2460\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx3276\pard \li360\sb60\sa60\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 BSQ\cell NS\cell NL\cell NB\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx828\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1644\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2460\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx3276\pard \li360\sb60\sa60\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 BIL\cell NS\cell NB\cell NL\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx828\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1644\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2460\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx3276\pard \li360\sb60\sa60\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 BIP\cell NB\cell NS\cell }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 NL}{\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\row }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 10}}}{: File Organization\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b U_ORG:}{ input, string \line Indicates the file organization that the programmer expects or desires for the file. The acceptable organizations are band sequential, band interleaved by pixel, and band interleaved by line. The respective values that represent these states are, 'BSQ', 'BI P', and 'BIL'. If the file is being created by the }{\b x/zvopen}{, then the indicated organization will become the new file organization. If the file is an existing file that is not to be deleted and created again, then the Executive will check the indicated organization against that of the existing file. If they are not the same then an error condition will be raised. If the image file has less than three dimensions, this argument will be ignored. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {U_DIM: input, integer\line Number of dimensions of dimensions the file has. Current default if U_DIM not specified is 3. 4 is permitted but not supported.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b METHOD}{: input, string \line Indicates the access method for the file.\line Valid values are 'SEQ' (sequential) or 'RANDOM'. The default is 'SEQ'. 'SEQ' and 'RANDOM' only effect the internal buffering used by the executive; if the method is 'SEQ', then a larger buffer will be used for I/O, resulting in more efficient processing. If 'RANDOM' is given, a smaller buffer will be used to avoid reading unnecessary data.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {If the file is a tape file, an error condition will be raised if 'RANDOM' is specified. The specification of 'RANDOM' for a file with OP equal to 'WRITE' is equivalent to 'SEQ'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b OP}{: input, string \line Indicates the intended operation. Valid values are 'READ', 'WRITE', and 'UPDATE'. Default is 'READ'. }{\b Output files must have OP equal to WRITE. }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OPEN_ACT:}{ input, string \line Indicates the action to be taken by the Executive when an error condition is raised as a result of the open. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings:\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort. Otherwise, the routine will return an error number in STATUS. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the OPEN_MES optional to be printed. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to be printed. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If OPEN_ACT consists only of blanks, an error will cause the }{\b x/zvopen}{ to return an error number in STATUS. Default is the action specified with }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b IO_ACT:}{ input, string \line As in OPEN_ACT but for}{\b  x/zvread}{ and }{\b x/zvwrit}{. Default is specified with }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LAB_ACT:}{ input, string \line Specified as is OPEN_ACT, LAB_ACT defines a default error action to be taken by the XL routines. It can be overridden in a call to an XL routine with the ERR_ACT optional. The message given if a 'U' is given is specified by LAB_MESS. The default for LAB_ACT is given by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b CLOS_ACT:}{ input, string \line Indicates an action to be taken when the file is closed. If the string contains one of the substrings listed below, the corresponding action will be taken. More than one action may be specified. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {DELETE: Causes the file to be deleted. Default is to retain the file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {FREE: Frees up the unit number so it can be used again. If this action is specified, then the file can no longer be accessed using this unit number. If you want to access the file again, x/zvunit must be called again. Since there are a limited number of unit slots available, FREE is most useful when processing large numbers of files. It allows VICAR to re-use this unit slot. If FREE is not specified (the default), then the file may be opened again via x/zvopen without calling x/zvunit, but VICAR cannot assign this unit number to another file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b FORMAT}{: output, string, maximum length 32 \line The format of the pixel in an existing file. Possibilities are BYTE, HALF, FULL, REAL, DOUB, COMP. WORD and COMPLEX are equivalent to HALF and COMP, but are non-standard. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b O_FORMAT:}{ input, string \line For input files this argument is ignored. For output files, O_FORMAT becomes the format of the output file. Valid values are 'BYTE', 'HALF', 'FULL', 'REAL', 'DOUB', and 'COMP'. 'WORD' and 'COMPLEX' are equivalent to 'HALF' and 'COMP', respectively, but for consistency are no longer to be used. The Executive will ensure that the output pixels have the indicated FORMAT by converting if necessary. A related argument is U_FORMAT which is the format of the pixels returned or passed to }{\b x/zvread}{ or }{\b x/zvwrit}{. Default is the primary input FORMAT, that is, the format of the pixels in the input file.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_FORMAT:}{ input, string \line Indicates the format of pixels in the buffer returned by }{\b x/zvread}{ or the format of the pixels the program will pass to }{\b x/zvwrit}{. If for input files U_FORMAT is not equal to the input file format, then VICAR will convert. On output, if U_FORMAT is not equal to O_FORMAT then VICAR will convert. Default for input files is the input file format; for output files, it is the primary input U_FORMAT.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b I_FORMAT:}{ input, string, maximum length 8 \line If an input file is unlabeled and does not have the default pixel format of 'BYTE', then this optional may be used to set the proper format; valid values are ' BYTE', 'HALF', 'FULL','REAL', 'DOUB', and 'COMP'. 'WORD' and 'COMPLEX' are equivalent to 'HALF' and 'COMP', respectively, but for consistency should no longer be used.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OPEN_MES:}{ input, string, maximum length 132 \line OPEN_MES holds the user message that is issued when the OPEN_ACT argument contains the substring 'U' and an error occurs. Default is specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b IO_MESS:}{ input, string, maximum length 132 \line Holds the user message that is issued under certain settings of the IO_ACT argument when I/O errors occur. Default is specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LAB_MESS:}{ input, string, maximum length 132 \line Holds the user message that is issued when the ERR_ACT optional is not given to an XL routine, and the LAB_ACT optional contains the substring 'U'. Default is specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: input, string, maximum length 8 \line With this argument, the programmer can designate the type of the output file desired. If the file already exists the Executive will alter any file name and label items that indicate the file type. On input, the file will be checked for type. If a mismatch occurs between the TYPE argument and the actual file type, an error status condition will be raised. Currently supported values are: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {IMAGE: The file contains image data. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {PARM: The file contains parameters for input to a program via the PARAMS parameter on the command line. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {PARAM: Same as PARM, but an older file type. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {GRAPH1: The file is an IBIS Graphics-1 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {GRAPH2: The file is an IBIS Graphics-2 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {GRAPH3: The file is an IBIS Graphics-3 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {TABULAR: The file is an IBIS Tabular file. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b COND}{: input, string, maximum length 132 \line If the string is null or contains only blanks, this argument will have no effect. If the string contains one of the substrings listed below, the indicated condition will be set for the specified file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b NOLABELS}{: Indicates that no label processing will be done for the file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b NOBLOCK}{: Indicates that if the file is an output file (OP=WRITE), the file will not be blocked (RECSIZE=BUFSIZ). \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b BINARY: }{indicates that the binary prefix and binary header, if they exist, will be unhidden to the program (see U_NLB and U_NBB) \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b VARREC}{: Indicates that the file is a tape containing variable length records. NOLABELS and NOBLOCK must also be specified with this argument. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The string may contain more than one substring, such as 'COND', 'NOBLOCK NOLABELS'. Default is to label and block files and hide the binary areas of the file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b U_FILE:}{ input, integer \line Used to specify the file number to be accessed on a tape. If U_FILE = 0, the tape advances to the next file (the default). If U_FILE > 0, the tape is moved to the absolute file number given. U_FILE may not be less than zero. The first file on a tape is file number one; thus if U_FILE = 1, the tape will be rewound. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b HOST, string: }{The type of computer used to generate the image. The value for HOST appears in the system image label. It is used only for documentation; the RTL uses the INTFMT and REALFMT label items to determine the representation of the pixels in the file. HOST will default to the type of computer the program is running on, so it normally will not be needed. It is used to write a file in a host format other than the native one. While this is not recommended (the general rule is read anything, write native format), it is allowed. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. New values for HOST will appear every time the RTL is ported to a new machine, so no checking is done on the string. However, the currently accepted values and what they represent, are listed. See }{\field{\*\fldinst { REF _Ref393618344 \\* MERGEFORMAT }}{\fldrslt {Table 1: Valid VICAR HOST Labels and Machine Types}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618344 }}{\fldrslt {\cs109\lang1024 11}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {NATIVE: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {LOCAL: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b INTFMT, string}{: The format used to represent integers in the file. INTFMT, REALFMT, and HOST should all match, so if you change one please change all three. INTFMT is a system label item in the image used by the RTL to automatically convert data read in, via }{\b x/zvread, }{to the native integer representation. It defaults to the representation of the machine the program is running on, so it only needs to be set when writing in a non-native format. If you are reading a file in such a way that the RTL does }{\i not}{ automatically convert datatypes, such as Array I/O or CONVERT OFF,  pay attention to the INTFMT label (via}{\b  x/zvget}{) and use the }{\b x/zvtrans}{ representation (for binary labels see BINTFMT below). See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values of INTFMT may change as the RTL is ported to new machines. However, the currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618329 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {NATIVE: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {LOCAL: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b REALFMT, string}{ :The format used to represent floating point numbers in the file. INTFMT, REALFMT, and HOST should all match, so if you change one please change all three. REALFMT is a system label item in the image used by the RTL to automatically convert data read in, via }{\b x/zvread}{, to the native floating point representation. It defaults to the representation of the machine the program is running on, so it only need s to be set when writing in a non-native format. If you are reading a file in such a way that the RTL does }{\i not a}{utomatically convert data types, such as Array I/O or CONVERT OFF,  pay attention to the REALFMT label (via }{\b x/zvget}{) and use the }{\b x/zvtrans}{ family of routines to translate to the native representation (for binary labels see INTFMT below). See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values of REALFMT may change as the RTL is ported to new machines. However, the currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618311 \\* MERGEFORMAT }}{\fldrslt {Table 3: Valid VICAR Real Number Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618311 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b NATIVE}{: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b LOCAL}{: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BHOST, string}{: The type of computer used to generate the binary labels. The value for BHOST appears in the system image label. It is used only for documentation; the RTL uses the BINTFMT and INTFMT label items to determine the representation of the binary labels in the file. For input (or update) files, the BHOST optional is used if the INTFMT label is not present in the file (if neither are present it defaults to VAX-VMS). For output files, the BHOST optional is used if is OFF (if not present the file's BHOST comes from the primary input, or defaults to VAX-VMS). If is ON, the BHOST optional is ignored since the file's INTFMT gets set to the native host. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values for BHOST are exactly the same as for HOST above (including NATIVE and LOCAL). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BINTFMT, string}{: The format used to represent integers in the binary label. BINTFMT, BREALFMT, and BHOST should all match, so if you change one change all three. BINTFMT is a system label item in the image made available by the RTL to help applications to convert binary labels read or written to the file. For input (or update) files, the BINTFMT optional is used if the BINTFMT label is not present in the file (if neither are present it defaults to the integer format for VAX-VMS). For output files, the BINTFMT optional is used if is OFF (if not present the file's BINTFMT comes from the primary input, or defaults to the integer format for VAX-VMS). If is ON, the BINTFMT optional is ignored since the file's BINTFMT gets set to the native host integer format. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. Applications using binary labels should pay close attention to BINTFMT, as they are responsible for doing their own data format conversions. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The valid values for BINTFMT are exactly the same as for INTFMT above (including NATIVE and LOCAL). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BREALFMT, string}{: The format used to represent real numbers in the binary label. BREALFMT, BINTFMT, and BHOST should all match, so if you change one change all three. INTFMT is a system label item in the image made available by the RTL to help applications to convert binary labels read or written to the file. For input (or update) files, the BREALFMT optional is used if the BREALFMT label is not present in the file (if neither are present it defaults to the floating-point format for VAX-VMS). For output files, the BREALFMT optional is used if is OFF (if not present the file's INTFMT comes from the primary input, or defaults to the floating-point format for VAX-VMS). If is ON, the BREALFMT optional is ignored since the file's BREALFMT is set to the native host floating-point format. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. Applications using binary labels should pay close attention to BREALFMT, as they are responsible for doing their own data format conversions. \line The valid values for BREALFMT are exactly the same as for REALFMT above (including NATIVE and LOCAL). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BLTYPE, string: }{The type of the binary label}{\b . }{The value for BLTYPE appears in the system image label. This is not type in the sense of datatype, but is a string identifying the kind of binary label in the file. The RTL does not do any interpretation or checking of BLTYPE. It is intended mainly for documentation, so people looking at the image will know what kind of binary label is present. It may also be used by application programs to make sure they can process the given type of binary label, or to make sure it is processed correctly. For input (or update) files, the BLTYPE optional is used if the BLTYPE label is not present in the file (not that \ldblquote used\rdblquote  in this sense means only being made available to }{\b x/zvget}{). For output files, the BLTYPE optional is used for the BLTYPE system label of the file (regardless of the setting). If the optional is not present, the file's BLTYPE comes from the primary input. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values of BLTYPE are maintained in a name registry, so that all possible kinds of binary labels can be documented in one place. Although the RTL does no checking on the given name, only names that are registered should be used in BLTYPE. See }{\field{\*\fldinst { REF Heading12 \\n }}{\fldrslt {1.7.2}}}{ }{\field{\*\fldinst { REF Heading12 \\* MERGEFORMAT }}{\fldrslt {Programming and Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading12 }}{\fldrslt {\cs109\lang1024 17}}}{\cs109 )}{, for more details. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b CONVERT}{, string:  The valid values for CONVERT are ON and OFF. The default is ON. Normally, the RTL will automatically convert pixels that are read from a file to the native host representation, and to the data type specified in U_FORMAT.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Setting CONVERT to OFF turns off both of these conversions, giving you the bit patterns that are in the file directly. When writing a file, host conversion is possible (although not normally used), but the U_FORMAT data type conversion is normally performed. Setting CONVERT to OFF turns off both of these conversions as well, writing the bit patterns that are in memory directly to the file.\par Note:  Be careful!  If you turn CONVERT OFF, you are responsible for doing your own data type conversions. Any given program should be able to read files written on any machine, so if you turn off CONVERT you should make use of the}{\b  x/ztvtrans}{ family of routines. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for details.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BIN_CVT}{, string:  The valid values for BIN_CVT are ON and OFF. The default is OFF. BIN_CVT is used to inform the RTL whether or not you will be converting binary labels to the native host representation. If BIN_CVT is ON, then the host formats in the output file (BHOST, BINTFMT, and BREALFMT) will be set to the native machine's host formats. This will be the standard case for applications that know how to interpret the binary label. Since the binary label type is known, the application can convert the data to the native format before writing the file.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {If the application does not know the binary label type, however (such as a general-purpose application), then it cannot convert the host format. In this case, set BIN_CVT to OFF. This means the output file will receive the binary label host types of the primary input file, defaulting to VAX-VMS if not available. The general-purpose application may then simply transfer the binary labels over to the output file without re-formatting them. The BHOST, BINTFMT, and BREALFMT optional arguments will override this setting, but if BIN_CVT is OFF (they are ignored if BIN_CVT is on). BIN_CVT is ignored for input files. See }{\field{\*\fldinst { REF Heading12 \\r \\* MERGEFORMAT }}{\fldrslt {1.7.2}}}{ }{\field{\*\fldinst { REF Heading12 \\* MERGEFORMAT }}{\fldrslt {Programming and Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading12 }}{\fldrslt {\cs109\lang1024 17}}}{\cs109 )}{, for more details.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UPD_HIST}{, string: The valid values for UPD_HIST are ON and OFF. Default is OFF. UPD_HIST  controls whether or not to write a history label when the file is opened in UPDATE mode. If it is ON, a label is written; if OFF (the default), no label is written. UPD_HIST is only used in UPDATE mode, not in READ or WRITE. In WRITE mode, a history label is always created). {\*\bkmkstart Heading55}{\*\bkmkstart _Toc425047518}{\*\bkmkstart _Toc425048073}{\*\bkmkstart _Toc425329690}\par {\*\bkmkstart _Toc453201412}{\*\bkmkend Heading55}{\*\bkmkend _Toc425047518}{\*\bkmkend _Toc425048073}{\*\bkmkend _Toc425329690}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.2\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvclose\emdash Close a file{\*\bkmkend _Toc453201412}\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvclose(unit, status, <optionals>, ' ')\line status = zvclose(unit, <optionals>, 0);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvclose}{ will close an open image file. The use of }{\b x/zvclose}{ is required in an application program. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line Unit number of file from }{\b x/zvunit}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer \line Error status code. A value of one indicates success. See the optional arguments OPEN_ACT, and IO_ACT under}{\b  x/zvopen}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b CLOS_ACT:}{ input, string, maximum length 132 \line Indicates an action to be taken when the file is closed. If the string contains one of the substrings listed below, the corresponding action will be taken. More than one action may be specified. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b DELETE}{: Causes the file to be deleted. Default is to retain the file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b FREE}{: Frees up the unit number so it can be used again. If this action is specified, then the file can no longer be accessed using this unit number. If you want to access the file again, x/zvunit must be called again. Since there are a limited number of unit slots available, FREE is most useful when processing large numbers of files. It allows VICAR to re-use this unit slot. If FREE is not specified (the default), then the file may be opened again via }{\b x/zvopen}{ without calling }{\b x/zvunit}{, but VICAR cannot assign this unit number to another file. \par {\*\bkmkstart Heading56}{\*\bkmkstart _Toc425047519}{\*\bkmkstart _Toc425048074}{\*\bkmkstart _Toc425329691}{\*\bkmkstart _Toc453201413}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.3\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zveaction\emdash Set the default error handling action{\*\bkmkend Heading56}{\*\bkmkend _Toc425047519}{\*\bkmkend _Toc425048074}{\*\bkmkend _Toc425329691}{\*\bkmkend _Toc453201413} \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {call xveaction (action, message) \line status = zveaction (action, message) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zveaction}{ sets the default error handling action for the entire VICAR job. It is used as a default for all the error handling optionals such as OPEN_ACT, IO_ACT, LAB_ACT, and ERR_ACT, and it is used directly by routines that do not have their own independent error action arguments. \par The default if }{\b x/zveaction}{ is not called is a null string for both the action and the message. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ACTION}{: input, string, maximum length 8 \line Indicates the action to be taken by the Executive when an error condition is raised. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A: }{an error will cause an immediate program abort.}{\b  }{Otherwise, the routine will return an error number in a status variable (if available). \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that is specified with the MESSAGE argument to be printed. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to be printed. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent of each other. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If ACTION consists only of blanks, or if }{\b x/zveaction}{ has never been called, an error will cause the Executive to return an error number in a status variable (if one is available on the particular subroutine that had the error). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b MESSAGE}{: input, string, maximum length 132 \line MESSAGE holds the user message that is issued when the ACTION argument contains the substring 'U' and an error occurs. Even if ACTION is overridden by a action optional (such as OPEN_ACT), the message specified by this argument may still be used if the optional contains the substring 'U', unless,, it is overridden by the corresponding message optional (such as OPEN_MES). \par {\*\bkmkstart Heading57}{\*\bkmkstart _Toc425047520}{\*\bkmkstart _Toc425048075}{\*\bkmkstart _Toc425329692}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer \line Error status code. A value of one indicates success. See the optional arguments OPEN_ACT, and IO_ACT under}{\b  x/zvopen}{. }{\b \par {\*\bkmkstart _Toc453201414}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.4\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvget\emdash Retrieve control block information{\*\bkmkend Heading57}{\*\bkmkend _Toc425047520}{\*\bkmkend _Toc425048075}{\*\bkmkend _Toc425329692}{\*\bkmkend _Toc453201414} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvget(unit, status, <optionals>, ' ')\line status = zvget(unit, <optionals>, 0);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvget}{ permits the programmer to request file information stored in the executive's internal control block associated with a unit number. The item of information is identified by an input key word field. The information is returned by }{\b x/zvget}{ in the variable following the key word argument. The keyword-value pairs are optional and may be entered pairwise in any order. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line Unit number of file from }{\b x/zvunit}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer \line Error status code. A value of one indicates success. See the optional arguments OPEN_ACT and IO_ACT under}{\b  x/zvopen}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b FORMAT}{: output, string, maximum length 32 \line The format of the pixel in an existing file. Possibilities are BYTE, HALF, FULL, REAL, DOUB, COMP. WORD and COMPLEX are equivalent to HALF and COMP, but are non-standard. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NL}{: output, integer \line The number of lines in the image \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NS}{: output, integer \line The number of samples in the image. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NB}{: output, integer \line The number of bands in the image. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b N1, N2, or N3}{: output, integer \line The number of pixels in the first, second and third dimensions of the image. The values returned refer to the physical dimensions of the file and are independent of file organization. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DIM}{: output, integer \line The dimension of the image. Valid values are 2 or 3. Currently, all new files created by the executive have a DIM of 3. If DIM is 3 and NB is 1, then the file effectively has a DIM of 2. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ORG}{: output, string, maximum length 32 \line The file organization; organizations may be: BSQ (band sequential), BIP (band interleaved by pixel), or BIL (band interleaved by line). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NAME}{: output, string, maximum length 132.\line The host system file name. For a display, the display id is returned. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: output, string, maximum length 32 \line The type of file. Currently supported values are: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b IMAGE}{: The file contains image data.}{\b  }{\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b PARM}{: The file contains parameters for input to a program via the PARAMS parameter on the command line. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b PARAM}{: Same as PARM, but an older file type. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b GRAPH1}{: The file is an IBIS Graphics-1 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b GRAPH2}{: The file is an IBIS Graphics-2 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b GRAPH3}{: The file is an IBIS Graphics-3 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b TABULAR}{: The file is an IBIS Tabular file. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b PIX_SIZE:}{ output, integer \line The size of a pixel in bytes. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BUFSIZ}{: output, integer \line The size of the internal buffer being used for the I/O operations. If the file is a tape, BUFSIZ will be equivalent to the block size of the tape in bytes. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b RECSIZE}{: output, integer \line The record size in bytes. Equal to PIX_SIZE x N1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VARSIZE}{: output, integer \line The record size of the last read for variable length records. VARSIZE is only valid if COND VARREC was given in }{\b x/zvopen}{ or }{\b x/zvadd}{. If VARREC was not specified, the value of VARSIZE is undefined. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FLAGS: }{output, integer \line FLAGS is an integer whose bits represent various attributes of the unit in question. To test a value in FLAGS, perform a bit-wise AND with it. For example, in the C language you could test to see if a file is open with the code \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f6\fs20\cgrid {int flags;\line \line xvget(&unit, &stat, "FLAGS", &flags);\line if (flags & OPEN) \{. . .\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The various flags listed here are predefined for applications written in C}{\caps . o}{nly the names should be used, to protect against changes in future versions of the executive. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b OPEN}{ indicates that the unit has already been opened by }{\b x/zvopen}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NO_LABELS}{ indicates that the file was opened with the COND, NOLABELS option. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LABELS_MODIFIED}{ indicates that the label I/O routines have been called, modifying the image label. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b UNIT_TAPE}{ indicates that the unit is a tape file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DATA_WRITTEN}{ indicates that the first logical data record was written. For internal use only. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOBLOCK}{ indicates that COND, NOBLOCK was specified at open time, and that tapes will be unblocked (one logical record per physical record). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BINARY }{indicates that COND, BINARY was specified at open time, causing binary labels, if present, to be available to the application. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VARREC }{indicates that COND, VARREC was specified at open time, allowing variable length records on a tape. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SEQUENTIAL_DEVICE}{ indicates that the device only allows sequential access, such as a magnetic tape. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b HOST, string: }{The type of computer used to generate the image. The value for HOST appears in the system image label. It is used only for documentation; the RTL uses the INTFMT and REALFMT label items to determine the representation of the pixels in the file. HOST will default to the type of computer the program is running on, so it normally will not be needed. It is used to write a file in a host format other than the native one. While this is not recommended (the general rule is read anything, write native format), it is allowed. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. New values for HOST will appear every time the RTL is ported to a new machine, so no checking is done on the string. However, the currently accepted values, and what they represent, are listed. See }{\field{\*\fldinst { REF _Ref393618344 \\* MERGEFORMAT }}{\fldrslt {Table 1: Valid VICAR HOST Labels and Machine Types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618344 }}{\fldrslt {\cs109\lang1024 11}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b NATIVE}{: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b LOCAL}{: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b INTFMT, string}{: The format used to represent integers in the file. INTFMT, REALFMT, and HOST should all match, so if you change one please change all three. INTFMT is a system label item in the image used by the RTL to automatically convert data read in, via }{\b x/zvread, }{to the native integer representation. It defaults to the representation of the machine the program is running on, so it only needs to be set when writing in a non-native format. If you are reading a file in such a way that the RTL does }{\i not}{ automatically convert datatypes, such as Array I/O or CONVERT OFF,  pay attention to the INTFMT label (via}{\b  x/zvget}{) and use the }{\b x/zvtrans}{ representation (for binary labels see BINTFMT below). See }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{ (page }{\field{\*\fldinst { PAGEREF Heading5 }}{\fldrslt {\lang1024 9}}}{), for more information. The valid values of INTFMT may change as the RTL is ported to new machines. However, the currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618329 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b NATIVE}{: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b LOCAL}{: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b REALFMT, string}{ :The format used to represent floating point numbers in the file. INTFMT, REALFMT, and HOST should all match, so if you change one please change all three. REALFMT is a system label item in the image used by the RTL to automatically convert data read in, via }{\b x/zvread}{, to the native floating point representation. It defaults to the representation of the machine the program is running on, so it only need s to be set when writing in a non-native format. If you are reading a file in such a way that the RTL does }{\i not a}{utomatically convert data types, such as Array I/O or CONVERT OFF,  pay attention to the REALFMT label (via }{\b x/zvget}{) and use the }{\b x/zvtrans}{ family of routines to translate to the native representation (for binary labels see INTFMT below). See }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{ (page }{\field{\*\fldinst { PAGEREF Heading5 }}{\fldrslt {\lang1024 9}}}{), for more information. The valid values of REALFMT may change as the RTL is ported to new machines. However, the currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618329 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b NATIVE}{: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b LOCAL}{: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BHOST, string}{: The type of computer used to generate the binary labels. The value for BHOST appears in the system image label. It is used only for documentation; the RTL uses the BINTFMT and INTFMT label items to determine the representation of the binary labels in the file. For input (or update) files, the BHOST optional is used if the INTFMT label is not present in the file (if neither are present it defaults to VAX-VMS). For output files, the BHOST optional is used if is OFF (if not present the file's BHOST comes from the primary input, or defaults to VAX-VMS). If is ON, the BHOST optional is ignored since the file's INTFMT gets set to the native host. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values for BHOST are exactly the same as for HOST above (including NATIVE and LOCAL). \par {\*\bkmkstart Heading58}{\*\bkmkstart _Toc425047521}{\*\bkmkstart _Toc425048076}{\*\bkmkstart _Toc425329693}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BINTFMT, string}{: The format used to represent integers in the binary label. BINTFMT, BREALFMT, and BHOST should all match, so if you change one change all three. BINTFMT is a system label item in the image made available by the RTL to help applications to convert binary labels read or written to the file. For input (or update) files, the BINTFMT optional is used if the BINTFMT label is not present in the file (if neither are present it defaults to the integer format for VAX-VMS). For output files, the BINTFMT optional is used if is OFF (if not present the file's BINTFMT comes from the primary input, or defaults to the integer format for VAX-VMS). If is ON, the BINTFMT optional is ignored since the file's BINTFMT gets set to the native host integer format. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. Applications using binary labels should pay close attention to BINTFMT, as they are responsible for doing their own data format conversions. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The valid values for BINTFMT are exactly the same as for INTFMT (including NATIVE and LOCAL). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BLTYPE, string: }{The type of the binary label}{\b . }{The value for BLTYPE appears in the system image label. This is not type in the sense of datatype, but is a string identifying the kind of binary label in the file. The RTL does not do any interpretation or checking of BLTYPE. It is intended mainly for documentation, so people looking at the image will know what kind of binary label is present. It may also be used by application programs to make sure they can process the given type of binary label, or to make sure it is processed correctly. For input (or update) files, the BLTYPE optional is used if the BLTYPE label is not present in the file (not that \ldblquote used\rdblquote  in this sense means only being made available to }{\b x/zvget}{). For output files, the BLTYPE optional is used for the BLTYPE system label of the file (regardless of the setting). If the optional is not present, the file's BLTYPE comes from the primary input. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values of BLTYPE are maintained in a name registry, so that all possible kinds of binary labels can be documented in one place. Although the RTL does no checking on the given name, only names that are registered should be used in BLTYPE. See }{\field{\*\fldinst { REF Heading12 \\n }}{\fldrslt {1.7.2}}}{ }{\field{\*\fldinst { REF Heading12 \\* MERGEFORMAT }}{\fldrslt {Programming and Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading12 }}{\fldrslt {\cs109\lang1024 17}}}{\cs109 )}{, for more details. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BREALFMT, string}{: The format used to represent real numbers in the binary label. BREALFMT, BINTFMT, and BHOST should all match, so if you change one change all three. INTFMT is a system label item in the image made available by the RTL to help applications to convert binary labels read or written to the file. For input (or update) files, the BREALFMT optional is used if the BREALFMT label is not present in the file (if neither are present it defaults to the floating-point format for VAX-VMS). For output files, the BREALFMT optional is used if is OFF (if not present the file's INTFMT comes from the primary input, or defaults to the floating-point format for VAX-VMS). If is ON, the BREALFMT optional is ignored since the file's BREALFMT is set to the native host floating-point format. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. Applications using binary labels should pay close attention to BREALFMT, as they are responsible for doing their own data format conversions. \line The valid values for BREALFMT are exactly the same as for REALFMT(including NATIVE and LOCAL). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b IMG_REC: output, integer}{\line The number of the last record read or written using x/zvread and x/zvwrit. In BSQ this is the last line.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b UPD_HIST}{, string: The valid values for UPD_HIST are ON and OFF. Default is OFF. UPD_HIST  controls whether or not to write a history label when the file is opened in UPDATE mode. If it is ON, a label is written; if OFF (the default), no label is written. UPD_HIST is only used in UPDATE mode, not in READ or WRITE. In WRITE mode, a history label is always created). \par {\*\bkmkstart _Toc453201415}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.5\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvopen\emdash Open a file{\*\bkmkend Heading58}{\*\bkmkend _Toc425047521}{\*\bkmkend _Toc425048076}{\*\bkmkend _Toc425329693}{\*\bkmkend _Toc453201415} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvopen(unit, status, <optionals>, ' ')\line status = zvopen(unit, <optionals>, 0);}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvopen}{ prepares the file for I/O processing. If the file is an input file, it verifies the file's existence and the existence and form of its label. \par For output files, }{\b x/zvopen}{ will ensure that the file is the right size, that being either the size indicated by the programmer on the call to }{\b x/zvopen}{, the size field for the file, or the input file, in that order. If the file does not exist,}{\b  x/zvopen}{ will create it. If the file exists but is too small, }{\b x/zvopen}{ will expand it. If the file is a tape file, it will be positioned to the desired file. \par For all output files, }{\b x/zvopen}{ will create, unless the programmer negates this default function, an output label for the file. \par A call to }{\b x/zvopen}{ is required before I/O processing can take place on the file. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line Unit number of file from }{\b x/zvunit}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer \line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. See also the optional arguments OPEN_ACT, IO_ACT, LAB_ACT, and ERR_ACT. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\*\bkmkstart Heading60}{\*\bkmkstart _Toc425047522}{\*\bkmkstart _Toc425048077}{\*\bkmkstart _Toc425329694}{\*\bkmkstart Heading59}{\*\bkmkstart _Toc423243870}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b U_NL:}{ input, integer \line Indicates that the Executive is to create an output file capable of holding NL lines. If the file associated with the unit number already exists but is too small, it will be enlarged. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NS:}{ input, integer \line As in NL but for samples. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NB:}{ input, integer \line As in NL but for bands. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NBB:}{ input, integer \line For output files, indicates the number of bytes of binary prefix that will precede each image line. The binary prefix will be stored in an area before each image line. It will be hidden from subsequent programs unless the program opens the file with a COND value that includes BINARY. Subsequent reads of a file with COND including BINARY will return the binary prefix to each line ahead of the line in the read buffer. An output file with a non-zero U_NBB will expect the binary prefix to precede the image line in the }{\b x/zvwrit}{ buffer. For input files U_NBB is ignored. Defaults to 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NLB:}{ input, integer \line For output files, indicates the number of lines of binary header information that is to precede the image lines in an image file. The image I/O subsystem will expect these lines to be written with }{\b x/zvwrit}{ prior to the writing of the image lines. The image header will remain hidden from subsequent programs unless those programs open the file with a value of COND that includes the substring, BINARY. For input files, }{\b U_NLB}{ is ignored. Defaults to 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_N1, U_N2, U_N3}{: input, integers \line Indicate that the Executive is to ensure that the output file will have the dimensions specified by the values associated with the respective arguments. U_N1 refers to the first file dimension, U_N2 the second, and U_N3 the third. These arguments are useful for the program which does not care about the file organization, and simply wants to deal with records and pixels. The relation between these arguments and the normal NL, NS, NB arguments are as follows:}{\cs33\f6 \par }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx828\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1644\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2460\clvertalt\clbrdrt\brdrs\brdrw30\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx3276\pard\plain \li360\sb60\sa60\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\cs33\f6 ORG\cell N1\cell N2\cell N3\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx828\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1644\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2460\clvertalt\clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx3276\pard \li360\sb60\sa60\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 BSQ\cell NS\cell NL\cell NB\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx828\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1644\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2460\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw15\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx3276\pard \li360\sb60\sa60\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 BIL\cell NS\cell NB\cell NL\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 \row }\trowd \trqc\trgaph108\trleft-108\trkeep\trbrdrt\brdrs\brdrw30\brdrcf1 \trbrdrl\brdrs\brdrw30\brdrcf1 \trbrdrb\brdrs\brdrw30\brdrcf1 \trbrdrr\brdrs\brdrw30\brdrcf1 \trbrdrh\brdrs\brdrw15\brdrcf1 \trbrdrv\brdrs\brdrw15\brdrcf1 \clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw30\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx828\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx1644\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw15\brdrcf1 \cltxlrtb \cellx2460\clvertalt\clbrdrt\brdrs\brdrw15\brdrcf1 \clbrdrl\brdrs\brdrw15\brdrcf1 \clbrdrb\brdrs\brdrw30\brdrcf1 \clbrdrr\brdrs\brdrw30\brdrcf1 \cltxlrtb \cellx3276\pard \li360\sb60\sa60\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 BIP\cell NB\cell NS\cell }\pard \li360\sb60\sa60\keepn\nowidctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\cs33\f6 NL}{\cell }\pard \widctlpar\intbl{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\row }\pard\plain \s40\qc\li360\sb120\sa360\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Table }{\field{\*\fldinst { SEQ Table \\* ARABIC }}{\fldrslt {\lang1024 11}}}{: File Organization\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ADDRESS}{ output, pointer (integer for FORTRAN) \line ADDRESS is a special argument which instructs the executive to cause the image file to be treated as an array of memory, and returns to the program the address of the beginning of the image data. The program may then use this address to manipulate the image data. No calls to }{\b x/zvread}{ or }{\b x/zvwrit}{ are needed, although they will still function. See the examples Section for details of how to use this argument in FORTRAN and C. }{\b Note:}{ There is a VMS memory management flaw that occasionally surfaces when using the ADDRESS optional. If you are opening and closing very large array I/O files, you might get a VASFULL (Virtual Address Space Full) error message, even though there should be plenty of virtual memory left. If this happens (and you're programming in C), try doing a large malloc () immediately followed by a free () call for the same memory area before opening any array I/O files. It is best to put the calls at the top of the program. This solution sounds like a no-operation, and from the programmer's point of view it is, but it causes VMS to do things that get around the problem. The amount of memory you allocate should enough to cover all dynamic memory allocated by your program, plus about 100K or so. Try a megabyte to start with, and adjust it upwards or downwards as needed. \line }{\b Example:}{ \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f6\fs20\cgrid {\cs33 free (malloc (1024*1024)); /* Fix Virtual Address Space Full error */}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b U_ORG:}{ input, string \line Indicates the file organization that the programmer expects or desires for the file. The acceptable organizations are band sequential, band interleaved by pixel, and band interleaved by line. The respective values that represent these states are, 'BSQ', 'BI P', and 'BIL'. If the file is being created by the }{\b x/zvopen}{, then the indicated organization will become the new file organization. If the file is an existing file that is not to be deleted and created again, then the Executive will check the indicated organization against that of the existing file. If they are not the same then an error condition will be raised. If the image file has less than three dimensions, this argument will be ignored. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {U_DIM: input, integer\line Number of dimensions of dimensions the file has. Current default if U_DIM not specified is 3. 4 is permitted but not supported.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b METHOD}{: input, string \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Indicates the access method for the file. Valid values are 'SEQ' (sequential) or 'RANDOM'. The default is 'SEQ'. 'SEQ' and 'RANDOM' only effect the internal buffering used by the executive; if the method is 'SEQ', then a larger buffer will be used for I/O, resulting in more efficient processing. If 'RANDOM' is given, a smaller buffer will be used to avoid reading unnecessary data. \par If the file is a tape file, an error condition will be raised if 'RANDOM' is specified. The specification of 'RANDOM' for a file with OP equal to 'WRITE' is equivalent to 'SEQ'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b OP}{: input, string \line Indicates the intended operation. Valid values are 'READ', 'WRITE', and 'UPDATE'. Default is 'READ'. }{\b Output files must have OP equal to WRITE. }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OPEN_ACT:}{ input, string \line Indicates the action to be taken by the Executive when an error condition is raised as a result of the open. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings:\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort. Otherwise, the routine will return an error number in STATUS. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the OPEN_MES optional to be printed. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to be printed. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If OPEN_ACT consists only of blanks, an error will cause the }{\b x/zvopen}{ to return an error number in STATUS. Default is the action specified with }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b IO_ACT:}{ input, string \line As in OPEN_ACT but for}{\b  x/zvread}{ and }{\b x/zvwrit}{. Default is specified with }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LAB_ACT:}{ input, string \line Specified as is OPEN_ACT, LAB_ACT defines a default error action to be taken by the XL routines. It can be overridden in a call to an XL routine with the ERR_ACT optional. The message given if a 'U' is given is specified by LAB_MESS. The default for LAB_ACT is given by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b CLOS_ACT:}{ input, string \line Indicates an action to be taken when the file is closed. If the string contains one of the substrings listed below, the corresponding action will be taken. More than one action may be specified. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {DELETE: Causes the file to be deleted. Default is to retain the file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {FREE: Frees up the unit number so it can be used again. If this action is specified, then the file can no longer be accessed using this unit number. If you want to access the file again, x/zvunit must be called again. Since there are a limited number of unit slots available, FREE is most useful when processing large numbers of files. It allows VICAR to re-use this unit slot. If FREE is not specified (the default), then the file may be opened again via x/zvopen without calling x/zvunit, but VICAR cannot assign this unit number to another file. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b O_FORMAT:}{ input, string \line For input files this argument is ignored. For output files, O_FORMAT becomes the format of the output file. Valid values are 'BYTE', 'HALF', 'FULL', 'REAL', 'DOUB', and 'COMP'. 'WORD' and 'COMPLEX' are equivalent to 'HALF' and 'COMP', respectively, but for consistency are no longer to be used. The Executive will ensure that the output pixels have the indicated FORMAT by converting if necessary. A related argument is U_FORMAT which is the format of the pixels returned or passed to }{\b x/zvread}{ or }{\b x/zvwrit}{. Default is the primary input FORMAT, that is, the format of the pixels in the input file.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_FORMAT:}{ input, string \line Indicates the format of pixels in the buffer returned by }{\b x/zvread}{ or the format of the pixels the program will pass to }{\b x/zvwrit}{. If for input files U_FORMAT is not equal to the input file format, then VICAR will convert. On output, if U_FORMAT is not equal to O_FORMAT then VICAR will convert. Default for input files is the input file format; for output files, it is the primary input U_FORMAT.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b I_FORMAT:}{ input, string, maximum length 8 \line If an input file is unlabeled and does not have the default pixel format of 'BYTE', then this optional may be used to set the proper format; valid values are ' BYTE', 'HALF', 'FULL','REAL', 'DOUB', and 'COMP'. 'WORD' and 'COMPLEX' are equivalent to 'HALF' and 'COMP', respectively, but for consistency should no longer be used.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OPEN_MES:}{ input, string, maximum length 132 \line OPEN_MES holds the user message that is issued when the OPEN_ACT argument contains the substring 'U' and an error occurs. Default is specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b IO_MESS:}{ input, string, maximum length 132 \line Holds the user message that is issued under certain settings of the IO_ACT argument when I/O errors occur. Default is specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LAB_MESS:}{ input, string, maximum length 132 \line Holds the user message that is issued when the ERR_ACT optional is not given to an XL routine, and the LAB_ACT optional contains the substring 'U'. Default is specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: input, string, maximum length 8 \line With this argument, the programmer can designate the type of the output file desired. If the file already exists the Executive will alter any file name and label items that indicate the file type. On input, the file will be checked for type. If a mismatch occurs between the TYPE argument and the actual file type, an error status condition will be raised. Currently supported values are: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {IMAGE: The file contains image data. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {PARM: The file contains parameters for input to a program via the PARAMS parameter on the command line. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {PARAM: Same as PARM, but an older file type. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {GRAPH1: The file is an IBIS Graphics-1 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {GRAPH2: The file is an IBIS Graphics-2 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {GRAPH3: The file is an IBIS Graphics-3 file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {TABULAR: The file is an IBIS Tabular file. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b COND}{: input, string, maximum length 132 \line If the string is null or contains only blanks, this argument will have no effect. If the string contains one of the substrings listed below, the indicated condition will be set for the specified file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b NOLABELS}{: Indicates that no label processing will be done for the file. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b NOBLOCK}{: Indicates that if the file is an output file (OP=WRITE), the file will not be blocked (RECSIZE=BUFSIZ). \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b BINARY: }{indicates that the binary prefix and binary header, if they exist, will be unhidden to the program (see U_NLB and U_NBB) \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b VARREC}{: Indicates that the file is a tape containing variable length records. NOLABELS and NOBLOCK must also be specified with this argument. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The string may contain more than one substring, such as 'COND', 'NOBLOCK NOLABELS'. Default is to label and block files and hide the binary areas of the file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b U_FILE:}{ input, integer \line Used to specify the file number to be accessed on a tape. If U_FILE = 0, the tape advances to the next file (the default). If U_FILE > 0, the tape is moved to the absolute file number given. U_FILE may not be less than zero. The first file on a tape is file number one; thus if U_FILE = 1, the tape will be rewound. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b HOST, string: }{The type of computer used to generate the image. The value for HOST appears in the system image label. It is used only for documentation; the RTL uses the INTFMT and REALFMT label items to determine the representation of the pixels in the file. HOST will default to the type of computer the program is running on, so it normally will not be needed. It is used to write a file in a host format other than the native one. While this is not recommended (the general rule is read anything, write native format), it is allowed. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. New values for HOST will appear every time the RTL is ported to a new machine, so no checking is done on the string. However, the currently accepted values and what they represent, are listed. See }{\field{\*\fldinst { REF _Ref393618344 \\* MERGEFORMAT }}{\fldrslt {Table 1: Valid VICAR HOST Labels and Machine Types}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618344 }}{\fldrslt {\cs109\lang1024 11}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {NATIVE: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {LOCAL: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b INTFMT, string}{: The format used to represent integers in the file. INTFMT, REALFMT, and HOST should all match, so if you change one please change all three. INTFMT is a system label item in the image used by the RTL to automatically convert data read in, via }{\b x/zvread, }{to the native integer representation. It defaults to the representation of the machine the program is running on, so it only needs to be set when writing in a non-native format. If you are reading a file in such a way that the RTL does }{\i not}{ automatically convert datatypes, such as Array I/O or CONVERT OFF,  pay attention to the INTFMT label (via}{\b  x/zvget}{) and use the }{\b x/zvtrans}{ representation (for binary labels see BINTFMT below). See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values of INTFMT may change as the RTL is ported to new machines. However, the currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618329 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {NATIVE: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {LOCAL: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b REALFMT, string}{ :The format used to represent floating point numbers in the file. INTFMT, REALFMT, and HOST should all match, so if you change one please change all three. REALFMT is a system label item in the image used by the RTL to automatically convert data read in, via }{\b x/zvread}{, to the native floating point representation. It defaults to the representation of the machine the program is running on, so it only need s to be set when writing in a non-native format. If you are reading a file in such a way that the RTL does }{\i not a}{utomatically convert data types, such as Array I/O or CONVERT OFF,  pay attention to the REALFMT label (via }{\b x/zvget}{) and use the }{\b x/zvtrans}{ family of routines to translate to the native representation (for binary labels see INTFMT below). See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values of REALFMT may change as the RTL is ported to new machines. However, the currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618311 \\* MERGEFORMAT }}{\fldrslt {Table 3: Valid VICAR Real Number Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618311 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. In addition, the following values are also accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b NATIVE}{: The host type of the currently running machine \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b LOCAL}{: Same as NATIVE \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BHOST, string}{: The type of computer used to generate the binary labels. The value for BHOST appears in the system image label. It is used only for documentation; the RTL uses the BINTFMT and INTFMT label items to determine the representation of the binary labels in the file. For input (or update) files, the BHOST optional is used if the INTFMT label is not present in the file (if neither are present it defaults to VAX-VMS). For output files, the BHOST optional is used if is OFF (if not present the file's BHOST comes from the primary input, or defaults to VAX-VMS). If is ON, the BHOST optional is ignored since the file's INTFMT gets set to the native host. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values for BHOST are exactly the same as for HOST above (including NATIVE and LOCAL). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BINTFMT, string}{: The format used to represent integers in the binary label. BINTFMT, BREALFMT, and BHOST should all match, so if you change one change all three. BINTFMT is a system label item in the image made available by the RTL to help applications to convert binary labels read or written to the file. For input (or update) files, the BINTFMT optional is used if the BINTFMT label is not present in the file (if neither are present it defaults to the integer format for VAX-VMS). For output files, the BINTFMT optional is used if is OFF (if not present the file's BINTFMT comes from the primary input, or defaults to the integer format for VAX-VMS). If is ON, the BINTFMT optional is ignored since the file's BINTFMT gets set to the native host integer format. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. Applications using binary labels should pay close attention to BINTFMT, as they are responsible for doing their own data format conversions. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The valid values for BINTFMT are exactly the same as for INTFMT above (including NATIVE and LOCAL). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BREALFMT, string}{: The format used to represent real numbers in the binary label. BREALFMT, BINTFMT, and BHOST should all match, so if you change one change all three. INTFMT is a system label item in the image made available by the RTL to help applications to convert binary labels read or written to the file. For input (or update) files, the BREALFMT optional is used if the BREALFMT label is not present in the file (if neither are present it defaults to the floating-point format for VAX-VMS). For output files, the BREALFMT optional is used if is OFF (if not present the file's INTFMT comes from the primary input, or defaults to the floating-point format for VAX-VMS). If is ON, the BREALFMT optional is ignored since the file's BREALFMT is set to the native host floating-point format. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. Applications using binary labels should pay close attention to BREALFMT, as they are responsible for doing their own data format conversions. \line The valid values for BREALFMT are exactly the same as for REALFMT above (including NATIVE and LOCAL). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BLTYPE, string: }{The type of the binary label}{\b . }{The value for BLTYPE appears in the system image label. This is not type in the sense of datatype, but is a string identifying the kind of binary label in the file. The RTL does not do any interpretation or checking of BLTYPE. It is intended mainly for documentation, so people looking at the image will know what kind of binary label is present. It may also be used by application programs to make sure they can process the given type of binary label, or to make sure it is processed correctly. For input (or update) files, the BLTYPE optional is used if the BLTYPE label is not present in the file (not that \ldblquote used\rdblquote  in this sense means only being made available to }{\b x/zvget}{). For output files, the BLTYPE optional is used for the BLTYPE system label of the file (regardless of the setting). If the optional is not present, the file's BLTYPE comes from the primary input. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information. The valid values of BLTYPE are maintained in a name registry, so that all possible kinds of binary labels can be documented in one place. Although the RTL does no checking on the given name, only names that are registered should be used in BLTYPE. See }{\field{\*\fldinst { REF Heading12 \\n }}{\fldrslt {1.7.2}}}{ }{\field{\*\fldinst { REF Heading12 \\* MERGEFORMAT }}{\fldrslt {Programming and Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading12 }}{\fldrslt {\cs109\lang1024 17}}}{\cs109 )}{, for more details. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b CONVERT}{, string:  The valid values for CONVERT are ON and OFF. The default is ON. Normally, the RTL will automatically convert pixels that are read from a file to the native host representation, and to the data type specified in U_FORMAT.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Setting CONVERT to OFF turns off both of these conversions, giving you the bit patterns that are in the file directly. When writing a file, host conversion is possible (although not normally used), but the U_FORMAT data type conversion is normally performed. Setting CONVERT to OFF turns off both of these conversions as well, writing the bit patterns that are in memory directly to the file.\par Note:  Be careful!  If you turn CONVERT OFF, you are responsible for doing your own data type conversions. Any given program should be able to read files written on any machine, so if you turn off CONVERT you should make use of the}{\b  x/ztvtrans}{ family of routines. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for details.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BIN_CVT}{, string:  The valid values for BIN_CVT are ON and OFF. The default is OFF. BIN_CVT is used to inform the RTL whether or not you will be converting binary labels to the native host representation. If BIN_CVT is ON, then the host formats in the output file (BHOST, BINTFMT, and BREALFMT) will be set to the native machine's host formats. This will be the standard case for applications that know how to interpret the binary label. Since the binary label type is known, the application can convert the data to the native format before writing the file.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {If the application does not know the binary label type, however (such as a general-purpose application), then it cannot convert the host format. In this case, set BIN_CVT to OFF. This means the output file will receive the binary label host types of the primary input file, defaulting to VAX-VMS if not available. The general-purpose application may then simply transfer the binary labels over to the output file without re-formatting them. The BHOST, BINTFMT, and BREALFMT optional arguments will override this setting, but if BIN_CVT is OFF (they are ignored if BIN_CVT is on). BIN_CVT is ignored for input files. See }{\field{\*\fldinst { REF Heading12 \\n }}{\fldrslt {1.7.2}}}{ }{\field{\*\fldinst { REF Heading12 \\* MERGEFORMAT }}{\fldrslt {Programming and Binary Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading12 }}{\fldrslt {\cs109\lang1024 17}}}{\cs109 )}{, for more details.\par {\*\bkmkstart _Ref425739967}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UPD_HIST}{, string: The valid values for UPD_HIST are ON and OFF. Default is OFF. UPD_HIST  controls whether or not to write a history label when the file is opened in UPDATE mode. If it is ON, a label is written; if OFF (the default), no label is written. UPD_HIST is only used in UPDATE mode, not in READ or WRITE. In WRITE mode, a history label is always created). \par {\*\bkmkstart _Ref453168463}{\*\bkmkstart _Ref453168521}{\*\bkmkstart _Toc453201416}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.6\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvread\emdash Rea{\*\bkmkstart vread}{\*\bkmkend vread}d a line{\*\bkmkend Heading59}{\*\bkmkend _Toc423243870}{\*\bkmkend _Ref425739967}{\*\bkmkend _Ref453168463}{\*\bkmkend _Ref453168521}{\*\bkmkend _Toc453201416} \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {call xvread(unit, buffer, status, <optionals>, ' ')\line status = zvread(unit, buffer, <optionals>, 0);}{\cs33\f6 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvread}{ will read a single line from the file associated with the UNIT. The data will be returned in BUFFER and the status indicator will be returned in STATUS. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line Unit number of file from }{\b x/zvunit}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BUFFER}{: output, array of anything \line Array to receive input data. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer \line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. See also the optional arguments OPEN_ACT, IO_ACT, LAB_ACT, and ERR_ACT. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b LINE}{: input, integer \line Indicates the starting line for the read. For BSQ images, by default the starting line is incremented from its position in the last read until each band is exhausted (after NL reads), at which time it resets to the first line for the new band. For BIL images, the line number increments after NB reads, and for BIP images the line number increments after NS x NB reads. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SAMP}{: input, integer \line Indicates the starting sample (starting pixel in the SAMP dimension) for the read. For BSQ and BIL images, the default is 1. For BIP images, the starting sample is incremented from the last read by default. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BAND}{: input, integer \line Indicates the starting band for the read. For BIP images, the default is 1. For BIL images, the starting band is incremented from the last read by default. For BSQ images, the starting band increments when each band is exhausted, that is, every NL lines.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NSAMPS}{: input, integer \line Indicates the number of samples to be accessed in a single operation. Defaults to the number of pixels in an image line if the file organization is BSQ or BIL. Not yet available for BIP images. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NBANDS}{: input, integer \line As in NLINES but for the band dimension. Currently only available for a file organization of BIP. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NLINES}{: input, integer \line Indicates the number of lines to be accessed in a single operation. Defaults to 1.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b IO_MESS:}{ input, string, maximum length 132 \line Holds the user message that is issued under certain settings of the IO_ACT argument when I/O errors occur. Default is specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OP}{: input, string \line Indicates the intended operation. Valid values are 'READ', 'WRITE', and 'UPDATE'. Default is 'READ'. }{\b Output files must have OP equal to WRITE. }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OPEN_ACT:}{ input, string \line Indicates the action to be taken by the Executive when an error condition is raised as a result of the open. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings:\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort. Otherwise, the routine will return an error number in STATUS. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the OPEN_MES optional to be printed. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to be printed. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If OPEN_ACT consists only of blanks, an error will cause the }{\b x/zvopen}{ to return an error number in STATUS. Default is the action specified with }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b U_FORMAT:}{ input, string \line Indicates the format of pixels in the buffer returned by }{\b x/zvread}{ or the format of the pixels the program will pass to }{\b x/zvwrit}{. If for input files U_FORMAT is not equal to the input file format, then VICAR will convert. On output, if U_FORMAT is not equal to O_FORMAT then VICAR will convert. Default for input files is the input file format; for output files, it is the primary input U_FORMAT.\par {\*\bkmkstart _Toc453201417}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.7\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvsignal\emdash Signal an error{\*\bkmkend Heading60}{\*\bkmkend _Toc425047522}{\*\bkmkend _Toc425048077}{\*\bkmkend _Toc425329694}{\*\bkmkend _Toc453201417} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvsignal (unit, status, abend_flag) \line status = zvsignal (unit, status, abend_flag) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvsignal}{ will signal an error if one has occurred in any of the image I/O routines (x/zv...) or label I/O routines (x/zl...). It uses the same internal routines that the OPEN_ACT, IO_ACT, LAB_ACT, and ERR_ACT optionals use, so no error checking is duplicated.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line The unit number of a file. }{\b x/zvsignal}{ will use this unit number to determine routine in which an error may have occured, and if it was a read or write, the line number in the image. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: input, integer \line The status returned from a previous subroutine call to be checked. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ABEND_FLAG:}{ input, logical*4 or integer \line Flag to indicate whether ABEND (abnormal program terminator) should be called to terminate execution of the program. If ABEND_FLAG is TRUE (non-zero) and an error has occurred,}{\b  x/zvsignal}{ will not return and the program will terminate abnormally. \par {\*\bkmkstart Heading61}{\*\bkmkstart _Toc425047523}{\*\bkmkstart _Toc425048078}{\*\bkmkstart _Toc425329695}{\*\bkmkstart _Toc453201418}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.8\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvunit\emdash Assign a unit number to a file{\*\bkmkend Heading61}{\*\bkmkend _Toc425047523}{\*\bkmkend _Toc425048078}{\*\bkmkend _Toc425329695}{\*\bkmkend _Toc453201418} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvunit(unit, name, instance, status, <optionals>, ' ')\line status = zvunit(unit, name, instance, <optionals>, 0);}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvunit}{ will return an unused file unit number. The programmer may use this number in any of the above routines. This routine must be called to obtain a unit number for every file that is to be accessed by the VICAR image and label I/O subroutine package. \par Under UNIX, filenames accepted by the RTL (via }{\b x/zvunit}{, either the U_NAME optional or the INP or OUT parameters) can contain environment variables andusernames. A reference of the form $}{\i var}{ will be replaced with the value of the environment variable }{\i var}{. The name of the environment variable (but not the dollar sign) may optionally be enclosed in curly braces ($\{}{\i var}{\}). A tilde (}{\cs33\f6 ~}{) followed by a username will be replaced with the home directory of that user. A tilde without a username will be replaced with the home directory of the current account. Both of these expansions exactly mimic the behavior of the C-shell, so they should be familiar to most UNIX users. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: output, integer \line An unused file unit number that may be used with any of the image I/O routines. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NAME}{: input, string, maximum length 32 \line Indicates which file is to be associated with the returned unit number. By convention, the string 'INP' denotes the input files, and the string, 'OUT', the output files that appear on the command line. If NAME is any other string other than 'INP' or 'OUT', }{\b x/zvunit}{ will create a new file for output and return the unit number for that file. The size and other attributes of the file will be determined by}{\b  x/zvopen}{ as for any output file asociated with 'OUT'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INSTANCE}{: input, integer \line Indicates which file of possibly several 'INP' or 'OUT' files is to be selected. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer \line Error status indicator. A value of one indicates success. Errors are handled in the manner specified by}{\b  x/zveaction}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b U_NAME:}{ input, string, maximum length 132 \line If the NAME argument is not 'INP' or 'OUT' then }{\b x/zvunit}{ will return the unit number of a file not associated with any file name appearing on the command line. This argument is used to name that file. It may take any form that a command line file name may take. To get back unit numbers for more than one file, increment the INSTANCE argument for each file. \par {\*\bkmkstart Heading62}{\*\bkmkstart _Toc425047524}{\*\bkmkstart _Toc425048079}{\*\bkmkstart _Toc425329696}{\*\bkmkstart _Toc453201419}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 3.2.9\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvwrit\emdash Write an image line{\*\bkmkend Heading62}{\*\bkmkend _Toc425047524}{\*\bkmkend _Toc425048079}{\*\bkmkend _Toc425329696}{\*\bkmkend _Toc453201419} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvwrit(unit, buffer, status, <optionals>, ' ')\line status = zvwrit(unit, buffer, <optionals>, 0);}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvwrit }{will write a single line of pixels to the image file associatedwith the UNIT. The data will be written from BUFFER and the status indicator will be  returned in STATUS. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line Unit number of file from }{\b x/zvunit}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BUFFER}{: output, array of anything \line Array containing output data. \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b {\*\bkmkstart Heading82}{\*\bkmkstart _Ref396008008}{\*\bkmkstart _Ref396008080}{\*\bkmkstart _Toc425047525}{\*\bkmkstart _Toc425048080}{\*\bkmkend Heading68}{\*\bkmkend Heading63}{\*\bkmkend Image}Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b LINE}{: input, integer \line Indicates the starting line for the read. For BSQ images, by default the starting line is incremented from its position in the last read until each band is exhausted (after NL reads), at which time it resets to the first line for the new band. For BIL images, the line number increments after NB reads, and for BIP images the line number increments after NS x NB reads. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SAMP}{: input, integer \line Indicates the starting sample (starting pixel in the SAMP dimension) for the read. For BSQ and BIL images, the default is 1. For BIP images, the starting sample is incremented from the last read by default. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BAND}{: input, integer \line Indicates the starting band for the read. For BIP images, the default is 1. For BIL images, the starting band is incremented from the last read by default. For BSQ images, the starting band increments when each band is exhausted, that is, every NL lines.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NSAMPS}{: input, integer \line Indicates the number of samples to be accessed in a single operation. Defaults to the number of pixels in an image line if the file organization is BSQ or BIL. Not yet available for BIP images. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NBANDS}{: input, integer \line As in NLINES but for the band dimension. Currently only available for a file organization of BIP. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NLINES}{: input, integer \line Indicates the number of lines to be accessed in a single operation. Defaults to 1.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_NL:}{ input, integer \line Indicates that the Executive is to create an output file capable of holding NL lines. If the file associated with the unit number already exists but is too small, it will be enlarged. \par {\*\bkmkstart _Ref452624269}{\*\bkmkstart _Ref452624305}{\*\bkmkstart _Toc453201420}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 4.\tab}}\pard\plain \s1\li360\sb60\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Label I/O{\*\bkmkend _Ref396008008}{\*\bkmkend _Ref396008080}{\*\bkmkend _Toc425047525}{\*\bkmkend _Toc425048080}{\*\bkmkend _Ref452624269}{\*\bkmkend _Ref452624305}{\*\bkmkend _Toc453201420} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This Section describes the label I/O to be used with the MIPL VICAR image processing executive. \par {\*\bkmkstart Heading69}{\*\bkmkstart _Toc425047526}{\*\bkmkstart _Toc425048081}{\*\bkmkstart _Toc453201421}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.1\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Introduction{\*\bkmkend Heading69}{\*\bkmkend _Toc425047526}{\*\bkmkend _Toc425048081}{\*\bkmkend _Toc453201421} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This Section contains a programmer's guide for reading, adding, and deleting items in an image file label. A label describes the size, nature, processing history, origin and attributes of an associated image file. When an image is generated as an output file by an image processing task, the Executive will create an output label, combining items in the input file label with new label information derived from the current processing function. In this way, a history of the processing of the data contained in the output file will be maintained. In addition, the Executive will guarantee that required label information, such as the output image size, will be correctly produced. The user and owner of a file may also modify the label of that file from the command language. \par A programmer may modify the label of any file that is written or updated by a program. The routines described in this Section permit the programmer to make such modifications.\par {\*\bkmkstart _Toc425047527}{\*\bkmkstart _Toc425048082}{\*\bkmkstart _Toc425329697}{\*\bkmkstart _Toc453201422}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.1.1\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {A Label Model{\*\bkmkend _Toc425047527}{\*\bkmkend _Toc425048082}{\*\bkmkend _Toc425329697}{\*\bkmkend _Toc453201422}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {A label is composed of label items. A label item is a text key word of 32 character maximum size that identifies the label item, and a value which is the information part of the label item. A value may be multi-valued, that is, contain more than one value. As an example, a label item for an image file may be the dimension of the image, comprised of a key word DIM, and a value, 3. For another example, consider as a label item the image size. The key word might be SIZE, and the value, (800,800,3). This label item is multi-valued. \par The set of keyword-value label items that comprise a label is considered by the executive to be partitioned into three sets of items, the system, history and property. The system items consist of those items that are independent of the history of the file. These items will include the size of the image, its organization, its pixel format, and the blocksize. \par The organization of the label into system, history and property, and the further breakdown of the history into subsets based on processing task reflects the model of the image label that programmers have found to be convenient at MIPL. \par System labels are defined by the VICAR RTL and contain all the information necessary for the RTL to access the image, such as size, pixel type, and host format information. System label items are not normally modified once the image is created. Since they are defined by the RTL, application programmers may not add their own system label items. \par History labels contain the processing history of the image. Each time a VICAR task is run on an image, a new history task gets added to the history label of the image. The history labels are copied from the \ldblquote primary input\rdblquote  file (usually the first input file), and the new task is appended to the end. Application programs are free to add label items as they wish to the history label. \par Property labels are used to describe the current state (or properties) of the image. They should eventually take over that function from the history labels, leaving the history labels to be }{\i only }{history. This may take a while, due to the large amount of software and images that use the history labels, but the goal is to make property labels the only place for non-historical image labels. \par Property labels are divided into named groups or sets called }{\i properties}{, much like history labels are divided into named groups called }{\i tasks}{. There is only one instance of each property name, unlike history tasks. For example, while there may be a half dozen LOGMOS tasks in the history label, there could be only one MIDR property in the property label. \par Within each property group are individual label items. The label items look identical to their counterparts in the system and history labels. They may be string, integer, real, or double precision, and may have multiple values (i.e. an array). The keys for each label item must be unique within the property group, but may be duplicated between groups. The keys can be up to 32 characters long, just like any other label key. The label keys PROPERTY and TASK are reserved to separate property and history label sets, and may not be used by applications. \par An example property label is listed (via }{\cs33\f6 label-list}{) below. The properties and names listed are examples, not official names.\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {----Property: TSTMAP ----}{\b \line }{PROJ='mercator'}{\b \line }{CENTER=(45.0, 12.7)}{\b \line }{LINE=5}{\b \line }{SAMP=5}{\b \line }{SCALE=10.0}{\b \line }{----Property: TSTLUT ----}{\b \line }{RED=(1, 2, 3, 4)}{\b \line }{GREEN=(4, 5, 6, 7)}{\b \line }{BLUE=(7, 8, 9, 10)\par {\*\bkmkstart _Toc425329698}{\*\bkmkstart _Toc453201423}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.1.2\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Property Labels{\*\bkmkend _Toc425329698}{\*\bkmkend _Toc453201423}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Before property labels were introduced, history labels served a dual role: they contained processing history (which tasks were run in what order) along with information about the image\rquote s current state. A good example is the Magellan MIDR label. All descriptive information about the MIDR product is kept by convention in the first LOGMOS history task. They have no historical meaning whatsoever, as they are updated by later processing runs. They describe the current state of the image.\par Another example is map labels, which describe the image\rquote s map projectio. A program that changes the projection adds a new map label entry to the history label. The last entry is the current projection. While in this case the map labels are historical, it is confusing to search through all the map labels to find the last (current) one. It is useful to keep a history of previous projections, but it is not clear to an inexperienced user which projection is current. \par This dual role for history labels was confusing. Which of potentially several LOGMOS runs were the MIDR labels kept in? What task created the map labels? What was the actual processing history ? Since previous tasks were modified, some historical information was lost. These problems led to the creation of property labels. \par Property labels are used in place of binary labels for most applications. Property labels do not suffer the same portability problems as binary labels, and may be written and read by standard VICAR RTL routines. They replace binary headers in most cases. Replacing binary prefixes may be more difficult. Although binary labels are still allowed replacing them with property labels is strongly encouraged. \par {\*\bkmkstart Heading70}{\*\bkmkstart _Ref424721848}{\*\bkmkstart _Toc425047528}{\*\bkmkstart _Toc425048083}{\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.1.2.1\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Using Property Labels{\*\bkmkend Heading70}{\*\bkmkend _Ref424721848}{\*\bkmkend _Toc425047528}{\*\bkmkend _Toc425048083} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Property labels are accessed in much the same way that history labels are. The routines}{\b  x/zladd}{,}{\b  x/zldel}{,}{\b  x/zlget}{, and}{\b  x/zlinfo}{ have been modified to accept \ldblquote PROPERTY\rdblquote  for the }{\i type}{ argument, as well as \ldblquote SYSTEM\rdblquote  and \ldblquote HISTORY\rdblquote }{\caps . s}{pecify which property the label belongs to via the \ldblquote PROPERTY\rdblquote  optional argument to these routines. Like history labels, property labels may have multiple instances, accessed through the \ldblquote INSTANCE\rdblquote  keyword. The \ldblquote HIST\rdblquote  key word is not used for property labels. In addition, a new routine, }{\b x/zlpinfo}{, has been added to get a list of properties in the label, similar to }{\b x/zlhinfo}{. \par Internally, property labels are stored in between the system and history labels. A property set starts with a }{\cs33\f6 PROPERTY=}{\i property-name}{, label item, followed by all labels for that property. The property ends at the next PROPERTY key word or at the start of the history labels (indicated by a TASK key word). \par Properties appear automatically when a label item for that property is added. There is no explicit creation step to add a new property; just add a label item in that property and it will be created with an instance number of 1. The same is not true for deletion (via the RTL): if you want to delete an entire property  delete all the elements from it and then delete the PROPERTY marker (using PROPERTY as the key word to delete from the property set). The }{\cs33\f6 label-delete}{ program can do this. It is important to that this is exactly the way history labels work: tasks are created automatically when programs are run, but to delete a task delete all the key words for that task, including the marker labels (TASK, DAT_TIM, and USER). \par Property labels, like history labels, are automatically copied from the primary input file to the output file. This is done because most properties will not change in a typical program run. Programs should update any properties that do change,. The copying of property labels can be controlled via }{\b x/zvselpi}{ which allows you to change the source for the primary input file.\par If you are implementing something new, like a look-up table or a new flight label, then you can use the property labels without problem. However, if you are moving an image that used to use history labels to the property label, like the map projection or an old flight label, you have to make sure that you can read files with the information either in the property label or in the history label. Old images with the information in the history label exist and will be used. For this case, you might want to adopt a similar strategy to the reading of other host's data: read the label from either the property or history label (wherever it is), but only write out property labels. \par {\*\bkmkstart _Toc425047529}{\*\bkmkstart _Toc425048084}{\*\bkmkstart _Toc425329699}{\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.1.2.2\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Property Instance Numbers\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Properties record the current state of an image, while history labels record the operations that have been performed on an image. Property instances are used when multiple \ldblquote current states" are valid. For example, when different methods may be used for to generate pointing correction, or different people do this manually, different pointing corrections will be obtained.  These corrections are all valid for their intended use; since there is no way to determine the correct pointing, they are all simultaneously valid. Each pointing correction is stored as an instance of a single property.\par There is no change to the label format in the file; a property instance is just another property set with the same name as a previous instance.  There is no explicit identifier in the label.  We suggest that you create a special label item in each multi-instance property type that identifies the type. Then you have two choices for finding a specific instance of a property. You can use }{\i  }{\b x/zlpinfo}{ to get a list, then cycle through all the instances of the property you care about, looking for the special label item. The alternative is to use }{\b x/zlget}{ on the identifier for the property in question, incrementing the instance number until an error is returned, indicating that no more instances of this property exist.\par {\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.1.2.3\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Property Names{\*\bkmkend _Toc425047529}{\*\bkmkend _Toc425048084}{\*\bkmkend _Toc425329699} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The RTL does no error or valid value checking on the name of a property, other than to ensure that it is 32 characters or less and is composed of printable ASCII characters. Any name at all can be used as a property name. However, there must be some control over property names, and the items that go in the property, or chaos will result. \par It is up to the application programmer community to define how the property labels will be used, what they will be called, and what will go in them. The property name should be a short description of what the property is. For example, good names might be MAP, LUT, GLL-SSI, MGN-MIDR, or VIEWING-GEOMETRY (these examples, not official names). If it can be general purpose, make it so, otherwise include the project name in the property name. It is possible to put a version number in the property name if necessary, such as \ldblquote MAP V2. 0\rdblquote , but this should be done only if a major revision redefines the existing label items. Label items can be added to an existing property without changing a version number. And if you have a version number in the name, all existing code that wants to find that property will have to be changed to include the version number. \par In order to maintain a consistent set of names, a name registry (similar to the one for BLTYPE) has been established for properties. Every property name must be entered into this registry, with a pointer to documentation describing the label items that can appear in the property. If you want to create a new property, simply tell the keeper of the registry what name you want to use and what the label items that make it up are (either explicitly or by referring to a document). The registrar will check for duplicates, approve your request, and enter your name into the registry. \par At the present time, the keeper of this registry is the VICAR system programmer. \par The name registry system is voluntary; the RTL makes no checks on the validity of the names used. It is the responsibility of each individual programmer to make sure that they use this system. Failure to do so may result in your program not being accepted for delivery. \par {\*\bkmkstart Heading72}{\*\bkmkstart _Toc425047531}{\*\bkmkstart _Toc425048086}{\*\bkmkstart _Toc453201424}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.2\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Image Label Access {\*\bkmkend Heading72}{\*\bkmkend _Toc425047531}{\*\bkmkend _Toc425048086}API{\*\bkmkend _Toc453201424} \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst { TOC \\b "Label" \\n}}{\fldrslt {\lang1024 4.2.1\tab x/zladd Add information to an existing label item\par 4.2.2\tab x/zldel Remove a label item\par 4.2.3\tab x/zlget\emdash Return the value of a label item\par 4.2.4\tab x/zlhinfo\emdash Return history label information\par 4.2.5\tab x/zlinfo\emdash Return information about a single label item\par 4.2.6\tab x/zlninfo\emdash Return name of next key\par 4.2.7\tab x/zlpinfo\emdash Returns the names of property subsets in the given file\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid }}\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This Section describes the subroutines that make up the programmer's interface for label processing. \par {\*\bkmkstart Heading73}{\*\bkmkstart _Toc425047532}{\*\bkmkstart _Toc425048087}{\*\bkmkstart _Toc425329700}{\*\bkmkstart Label}{\*\bkmkstart _Toc453201425}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.2.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zladd\emdash Add information to an existing label item{\*\bkmkend Heading73}{\*\bkmkend _Toc425047532}{\*\bkmkend _Toc425048087}{\*\bkmkend _Toc425329700}{\*\bkmkend _Toc453201425} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xladd(unit, type, key, value, status, <optionals>, ' ')\line status = zladd(unit, type, key, value, <optionals>, 0);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zladd}{ adds label items or values to multi-valued label items to a label. Strings in the image label are delimited by single quotes (}{\cs33\f6 '}{). A single quote in an input string will be repeated before being put in the label. On output (from }{\b x/zlget}{), the pair will be returned as one single quote. In other words, the repeating of quotes is transparent to the application program. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line Unit of associated file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: input, string\line `PROPERTY', 'HISTORY' or 'SYSTEM'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b KEY}{: input, string\line The key word of the label item. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALUE}{: input, array (size: NELEMENT)\line Holds the values of the label item. The type of argument required depends on the FORMAT optional given. For single values, INT requires an integer, REAL requires floating point (single-precision), and STRING requires a simple string argument ( (char *) in C, CHARACTER in FORTRAN). For multi-valued items (if NELEMENT is not 1), INT and REAL take single-dimension arrays of integers or reals. A STRING must be a two-dimensional array of characters in either FORTRAN or C. \line For example, a string array capable of handling 10 elements, with 80 characters in each element,  is declared in C: }{\cs33\f6 char value[10][80];}{ \line The standard C null string terminator is required, so the above array could only hold 79 characters. You will still pass in the length (in ULEN) as 80. ULEN is required for C strings that have more than one element. It is not legal to pass in an array of string pointers; the value must be a true array of characters. \line In FORTRAN you use a CHARACTER array: }{\cs33\f6 CHARACTER*80 VALUE (10)\line }{ULEN is not required, because the character descriptor contains the length of each string. Trailing spaces are stripped from FORTRAN strings by the executive; you can not add a label item that ends in a blank. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status. The possible errors are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395971271 }}{\fldrslt {\cs109\lang1024 140}}}{\cs109 )}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_ACT:}{ input, string\line Indicates the action to be taken by the Executive when an error condition is raised as a result of a call to this routine. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort. Otherwise, the routine will return an error number in STATUS. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the ERR_MESS optional to be printed. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to be printed. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent of each other. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If ERR_ACT consists only of blanks, an error will cause routine to return an error number in STATUS. \line If ERR_ACT is not specified, then the action defaults to the value of the LAB_ACT optional to }{\b x/zvopen}{ (the default for LAB_ACT is specified by }{\b x/zveaction}{). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_MESS:}{ input, string\line Holds the user message that the programmer wishes printed when an error occurs as directed by ERR_ACT. Default is specified by }{\b x/zveaction}{. \line  if the ERR_ACT option is not specified, and the LAB_ACT option given to }{\b x/zvopen}{ specifies a message be printed, the message given by LAB_MESS, }{\i not}{ ERR_MESS is printed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORMAT}{: input, format\line Indicates the format of the given label item value. Valid values are: 'INT', 'REAL', \lquote DOUB\rquote  and 'STRING'. The VALUE array type should match FORMAT, i.e. float for REAL, double for DOUB, etc. See }{\field{\*\fldinst { REF _Ref393619550 \\* MERGEFORMAT }}{\fldrslt {Table 6: C Declarations for Run-Time Library Arguments}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393619550 }}{\fldrslt {\cs109\lang1024 25}}}{) for matching C declarations. See }{\field{\*\fldinst { REF _Ref393695027 \\* MERGEFORMAT }}{\fldrslt {Table 6: FORTRAN declarations for pixel types}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393695036 }}{\fldrslt {\cs109\lang1024 26}}}{\cs109 )}{ for matching FORTRAN declarations.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b FORMAT is required. }{If the value in the FORMAT optional does not match the format of the currently existing label item, the label item is changed to match the optional. If this is not possible (i.e., a non-numeric string being changed to an integer), an error is returned. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b LEVEL}{: input, integer\line In the ADD routine, which allows label items to be added to a label, a level may be associated with a label item when that item is added. LEVEL holds the positive integer which is the level of the label item. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ELEMENT}{: input, integer\line For a multi-value item, the starting point to add the VALUE. If there are 4 elements currently, and ELEMENT is 3, then the new value will become the third element, and the old third and fourth will either be moved down to make room (if MODE is 'INSERT'), or will be replaced (if MODE is \lquote REPLACE'). A value of -1 says to add the element at the end, after all existing elements. The default is -1, i.e. to add it at the end. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NELEMENT}{: input, integer\line The number of values to be added to a multi-value item. Default: 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b HIST}{: input, string\line If TYPE is 'HISTORY' then this argument holds the name of the processing task that identifies the particular history subset in which 'KEY' may be found; if not entered, defaults to current task. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INSTANCE}{: input, integer\line If TYPE is 'HISTORY\rquote , \lquote INSTANCE\rquote  specifies into which instance the name of the task from \lquote HIST\rquote  will be entered. If TYPE is \lquote PROPERTY\rquote , \lquote INSTANCE\rquote  specifies into which instance the name of the property set from \lquote PROPERTY\rquote  will be entered. Attempting to add a label to a non-esistent property instance will cause a new instance to be created.  Instance numbers created may not match instance number entered. If there are 5 instances now, and you add instance 10, the label will go in a new instance 6. INSTANCE=0 forces creation of a new instance. Default: 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ULEN}{: input, integer\line The length of an input string. This optional only applies if the FORMAT is STRING. For multi-valued items, ULEN is the maximum length of each string in the array, i.e. it is the size of the first dimension of the array. ULEN is required in some cases, and it is ignored in others. These are explained below. \line There are two ways to pass strings: C char and FORTRAN CHARACTER. See the VALUE argument for an example of each. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b C: }{If NELEMENT is not 1 (multi-valued), then ULEN is required}{\b . }{If NELEMENT is 1, then ULEN is optional. If present, it is used, otherwise the length is the null-terminated length of the string. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b FORTRAN CHARACTER: }{ULEN}{\b  }{is always ignored.}{\b  }{The length is obtained from the character descriptor. \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b MODE}{: input, string\line Specifies what to do with labels that already exist. There are three allowable values: 'ADD', 'INSERT', and 'REPLACE'. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b 'ADD': }{this is the default action. If the label already exists, a DUPLICATE_KEY error is returned, and the label is not changed. If the label doesn't exist, it is created. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b 'INSERT'}{: If the label does not exist in the file, a new one is created. If it does exist, then all elements that are added are inserted into the existing list of elements. All elements in the old label past the point of insertion are moved down to make room. For example, if the label has 4 elements, and you are adding 2 elements (NELEMENT is 2) at position 3 (ELEMENT is 3), then the two new elements would become numbers 3 and 4, and the old 3 and 4 would get moved to numbers 5 and 6. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b 'REPLACE'}{: If the label does not exist in the file, a new one is created. If it does exist, then all elements that are added replace any elements in the old label with the same sequence numbers (if any). For example, if the label has 5 element s, and you are adding 2 elements (NELEMENT is 2) at position 3 (ELEMENT is 3), then the two new elements would replace the old element numbers 3 and 4. Items 1, 2, and 5 remain unchanged. 'REPLACE' is not a reliable way to replace the entire contents of a label, as you do not always know ahead of time how many elements are present. To do that, call }{\b x/zldel}{ and }{\b x/zladd}{ in sequence. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b PROPERTY}{, string: The name of the property set that the label routine is accessing The PROPERTY optional argument is only valid if the TYPE argument of the above routines is set to \ldblquote PROPERTY\rdblquote . See }{\field{\*\fldinst { REF _Ref424721848 \\n }}{\fldrslt {4.1.2.1}}}{ }{\field{\*\fldinst { REF _Ref424721848 \\* MERGEFORMAT }}{\fldrslt {Using Property Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading70 }}{\fldrslt {\cs109\lang1024 74}}}{\cs109 )}{, for more information. \par {\*\bkmkstart Heading74}{\*\bkmkstart _Toc425047533}{\*\bkmkstart _Toc425048088}{\*\bkmkstart _Toc425329701}{\*\bkmkstart _Toc453201426}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.2.2\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zldel\emdash Remove a label item{\*\bkmkend Heading74}{\*\bkmkend _Toc425047533}{\*\bkmkend _Toc425048088}{\*\bkmkend _Toc425329701}{\*\bkmkend _Toc453201426} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xldel(unit, type, key, status, <optionals>, ' ')\line status = zldel(unit, type, key, <optionals>, 0);}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zldel}{ removes a label item from a file that the user owns (an output file on a command line) or for which the user has update privilege. }{\b x/zldel}{ permits the partial deletion of values in a multi-value label item. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line Unit of associated file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: input, string\line `PROPERTY', 'HISTORY' or 'SYSTEM'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b KEY}{: input, string\line The key word of the desired label item. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output integer\line Error status. The possible errors are listed in }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ (page }{\field{\*\fldinst { PAGEREF _Ref395971271 }}{\fldrslt {\lang1024 140}}}{). }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_ACT:}{ input, string\line Indicates the action to be taken by the Executive when an error condition is raised as a result of a call to this routine. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort.}{\b  }{Otherwise, the routine will return an error number in STATUS. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the ERR_MESS optional to be printed. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to be printed. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent of each other. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If ERR_ACT consists only of blanks, an error will cause routine to return an error number in STATUS. \line If ERR_ACT is not specified, then the action defaults to the value of the LAB_ACT optional to }{\b x/zvopen}{ (the default for LAB_ACT is specified by }{\b x/zveaction}{). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_MESS:}{ input, string\line Holds the user message that the programmer wishes printed when an error occurs as directed by ERR_ACT. Default is specified by }{\b x/zveaction}{. \line If the ERR_ACT option is not specified, and the LAB_ACT option given to }{\b x/zvopen}{ specifies a message be printed, the message given by LAB_MESS, }{\i not}{ ERR_MESS is printed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ELEMENT}{: input, integer\line For a multi-value item, the starting value to delete. Default: 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NELEMENT}{: input, integer \line The number of values to be deleted from a multi-value item. A value of -1 means to delete all the values. The default is -1, i.e. to delete all the values. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NRET}{: output, integer\line The number of values actually deleted by the call to }{\b x/zldel}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b HIST}{: input, string \line If TYPE is 'HISTORY\rquote  then this argument holds the name of the processing task that identifies the particular history subset in which 'KEY' may be found; if not entered, it defaults to the current task. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INSTANCE}{: input, integer\line If TYPE is 'HISTORY\rquote  and HIST has been entered, INSTANCE gives the sequence number of the particular instance of the processing task for the condition where a processing task occurs more than once in the history subsets. If TYPE is \lquote PROPERTY\rquote  and PROPERTY has been entered, INSTANCE gives the sequence number of the particular instance of the property label for the condition where a property set with identical names occurs more than once. Default: 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b PROPERTY}{, string: The name of the property set that the label routine is accessing The PROPERTY optional argument is only valid if the type argument of the above routines is set to \ldblquote PROPERTY\rdblquote . See }{\field{\*\fldinst { REF _Ref424721848 \\n }}{\fldrslt {4.1.2.1}}}{ }{\field{\*\fldinst { REF _Ref424721848 \\* MERGEFORMAT }}{\fldrslt {Using Property Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading70 }}{\fldrslt {\cs109\lang1024 74}}}{\cs109 )}{, for more information. \par {\*\bkmkstart Heading75}{\*\bkmkstart _Toc425047534}{\*\bkmkstart _Toc425048089}{\*\bkmkstart _Toc425329702}{\*\bkmkstart _Toc453201427}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.2.3\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zlget\emdash Return the value of a label item{\*\bkmkend Heading75}{\*\bkmkend _Toc425047534}{\*\bkmkend _Toc425048089}{\*\bkmkend _Toc425329702}{\*\bkmkend _Toc453201427} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xlget(unit, type, key, value, status, <optionals>, ' ')\line status = zlget(unit, type, key, value, <optionals>, 0);}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zlget}{ returns the value or values associated with a label item key word. VALUE may be an array; the optional argument NELEMENT will indicate the dimension of VALUE. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line Unit of associated file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: input, string\line `PROPERTY', 'HISTORY' or 'SYSTEM'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b KEY}{: input, string\line The key word of the desired label item. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALUE}{: output, array (size:NELEMENT) Receives the values of the label item. The type of argument required depends on the FORMAT optional given. For single values, INT returns an integer, REAL returns floating point (single-precision), and STRING returns a simple string argument ( (char *) in C and CHARACTER in FORTRAN). For multi-valued items (if NELEMENT is not 1), INT and REAL take single-dimension arrays of integers or reals. ASTRING must be a two-dimensional array of characters in either FORTRAN or C. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {For example, if you wanted to have a string array capable of handling 10 elements, with 80 characters in each element, this is how you would declare it in C: \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f6\fs20\cgrid {\cs33 char value[10][80];}{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The standard C null string terminator is always returned in the string, so the above array could only hold 79 characters. You would still pass in the length (via ULEN) as 80.\par From C, ULEN is required for multivalued strings (string arrays), as it specifies the inner dimension of the array. For scalar strings (not an array), ULEN is not strictly required as the length of the string is not required. BUT, you will have no protection against overflowing the buffer. Specifying ULEN for a scalar string ensures that an exceptionally long string value will not exceed the size of your buffer. So it is a good idea to always specify ULEN from C, although it's only really required for a string array.\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f6\fs20\cgrid {In FORTRAN you use a CHARACTER array: }{\cs33 CHARACTER*80 VALUE (10) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {In this case ULEN is not required, as the character descriptor contains the length of each string. The space after the string itself is filled with blanks.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b STATUS}{: output, integer\line Error status. The possible errors are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395971271 }}{\fldrslt {\cs109\lang1024 140}}}{\cs109 )}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_ACT:}{ input, string\line Indicates the action to be taken by the Executive when an error condition is raised as a result of this call. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings:\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort; otherwise, the routine will return with an error number in STATUS \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the ERR_MESS optional to print \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to print. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent of each other. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If ERR_ACT consists only of blanks, an error will cause routine to return an error number in STATUS. \line If ERR_ACT is not specified, then the action defaults to the value of the LAB_ACT optional to }{\b x/zvopen}{ (the default for LAB_ACT is specified by }{\b x/zveactiion}{). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_MESS:}{ input, string\line Holds the user message that the programmer wishes printed when an error occurs as directed by ERR_ACT. Default is specified by }{\b x/zveaction}{. \line  if the ERR_ACT option is not specified, and the LAB_ACT option given to }{\b x/zvopen}{ specifies a message be printed, the message given by LAB_MESS, }{\i not}{ ERR_MESS is printed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORMAT}{: input, format\line Indicates the format of the given label item value. Valid values are: 'INT', 'REAL', \lquote DOUB\rquote  and 'STRING'. The VALUE array type should match FORMAT, i.e. float for REAL, double for DOUB, etc. See }{\field{\*\fldinst { REF _Ref393619550 \\* MERGEFORMAT }}{\fldrslt {Table 6: C Declarations for Run-Time Library Arguments}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393619550 }}{\fldrslt {\cs109\lang1024 25}}}{) for matching C declarations. See }{\field{\*\fldinst { REF _Ref393695027 \\* MERGEFORMAT }}{\fldrslt {Table 6: FORTRAN declarations for pixel types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393695036 }}{\fldrslt {\cs109\lang1024 26}}}{\cs109 )}{ for matching FORTRAN declarations.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {In}{\b  the present implementation, FORMAT is required. }{If the format does not match the format of the currently existing label item, the label item is changed to match what is given in this optional. If this is not possible (i.e., a non-numeric string being changed to an integer), an error is returned. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b INSTANCE}{: input, integer\line If TYPE is 'HISTORY\rquote  and HIST has been entered, INSTANCE gives the sequence number of the particular instance of the processing task for the condition where a processing task occurs more than once in the history subsets. If TYPE is \lquote PROPERTY\rquote  and PROPERTY has been entered, INSTANCE gives the sequence number of the particular instance of the property label for the condition where a property set with identical names occurs more than once. Default: 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LEVEL}{: output, integer\line In the ADD routine, which allows label items to be added to a label, a level may be associated with a label item when that item is added. LEVEL returns the positive integer which is the level of the label item. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LENGTH}{: output, integer\line The length of returned values. The length of 'INT' and 'REAL' formats is always 4. The length of a string item is the length of the longest string element, not including the null terminator (if present). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ELEMENT}{: input, integer\line For a multi-value item, the starting value to return into VALUE. Default: 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NELEMENT}{: input, integer\line The number of values to be returned of a multi-value item. A value of -1 means to return all elements. The default is 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NRET}{: output, integer\line The number of values actually returned by the call to }{\b x/zlget}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b HIST}{: input, string\line If TYPE is 'HISTORY' then this argument holds the name of the processing task that identifies the particular history subset in which 'KEY' may be found; if not entered it becomes the current task. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b PROPERTY}{, string: The name of the property set that the label routine is accessing The PROPERTY optional argument is only valid if the type argument of the above routines is set to \ldblquote PROPERTY\rdblquote . See }{\field{\*\fldinst { REF _Ref424721848 \\n }}{\fldrslt {4.1.2.1}}}{ }{\field{\*\fldinst { REF _Ref424721848 \\* MERGEFORMAT }}{\fldrslt {Using Property Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading70 }}{\fldrslt {\cs109\lang1024 74}}}{\cs109 )}{, for more information. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ULEN}{: input, integer\line The length of an input string. This optional only applies if the FORMAT is STRING. For multi-valued items, ULEN is the maximum length of each string in the array, i.e. it is the size of the first dimension of the array. ULEN is required in some cases, and it is ignored in others. These are explained below. \line There are two ways to pass strings: C char and FORTRAN CHARACTER. See the VALUE argument for an example of each. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b C: }{If NELEMENT is not 1 (multi-valued), then ULEN is required}{\b . }{If NELEMENT is 1, then ULEN is optional. If present, it is used, otherwise the length is the null-terminated length of the string. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b FORTRAN CHARACTER: }{ULEN}{\b  }{is always ignored.}{\b  }{The length is obtained from the character descriptor. \par {\*\bkmkstart Heading77}{\*\bkmkstart _Toc425047536}{\*\bkmkstart _Toc425048091}{\*\bkmkstart _Toc425329704}{\*\bkmkstart _Toc453201428}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.2.4\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zlhinfo\emdash Return history label information{\*\bkmkend Heading77}{\*\bkmkend _Toc425047536}{\*\bkmkend _Toc425048091}{\*\bkmkend _Toc425329704}{\*\bkmkend _Toc453201428} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xlhinfo(unit, tasks, instances, nhist, status, <optionals>, ' ')\line status = zlhinfo(unit, tasks, instances, nhist, <optionals>, 0);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {A history label is partitioned into subsets, one for each processing task that has 'read' or 'written' the data in the file described by the label. }{\b x/zlhinfo}{ returns the names and instances of the history label subsets for the file associated with UNIT. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line The unit number of the file described by the label of interest. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TASKS}{: output, string, fixed length 32 FORTRAN, 33 in C bytes\line An array of the task names in order of occurrence. At the present time the length of a task name is still truncated to 8 ( only 8 are significant), but when calling }{\b x/zlhinfo}{ you should now provide a 32 character buffer (33 in C for the null terminator) in order to accomodate future expansion. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INSTANCES}{: output, integer array\line An array with the same number of elements as TASKS giving the instance of each task. If, for instance, the task A is the first third and sixth element in TASKS, then INSTANCES (1)=1, INSTANCES (3)=2, and INSTANCES (6)=3. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NHIST}{: input/output, integer\line On input, it is the max dimension of TASKS and INSTANCES. On output, it is the number of tasks in the current label. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line The error status. The values are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395971271 }}{\fldrslt {\cs109\lang1024 140}}}{\cs109 )}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_ACT:}{ input, string\line Indicates the action to be taken by the Executive when an error condition is raised as a result of this call. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings :\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort; otherwise, the routine will return with an error number in STATUS \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the ERR_MESS optional to print \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to print \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent of each other. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If ERR_ACT consists only of blanks, an error will cause routine to return an error number in STATUS. \line If ERR_ACT is not specified, then the action defaults to the value of the LAB_ACT optional to }{\b x/zvopen}{ (the default for LAB_ACT is specified by }{\b x/zveaction}{). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_MESS:}{ input, string\line Holds the user message that the programmer wishes printed when an error occurs as directed by ERR_ACT. Defaults is specified by }{\b x/zveaction}{. \line  if the ERR_ACT option is not specified, and the LAB_ACT option given to }{\b x/zvopen}{ specifies a message be printed, the message given by LAB_MESS, }{\i not}{ ERR_MESS is printed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NRET}{\line Returns the total number of tasks in the label. This can differ from the NHIST argument if the buffers provided were too small. NRET returns the total number of tasks available, while NHIST returns the number actually in the buffers. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ULEN}{ specifies the length of each element in the TASKS array. You can specify any length (up to the maximum of 32 plus one for the terminator) for task names. In FORTRAN, the FORTRAN string length is used. In C, the length comes from ULEN (and defaults to 8 if ULEN is not given for backwards compatibility). Use a ULEN of at least 9 from C, in order to get all 8 characters with a null terminator. \par {\*\bkmkstart Heading78}{\*\bkmkstart _Toc425047537}{\*\bkmkstart _Toc425048092}{\*\bkmkstart _Toc425329705}{\*\bkmkstart Heading126}{\*\bkmkstart _Toc425047598}{\*\bkmkstart _Toc425048153}{\*\bkmkstart _Toc453201429}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.2.5\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zlinfo\emdash Return information about a single label item{\*\bkmkend _Toc453201429} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xlinfo(unit,type,key,format,maxlen,nelement,status,<optionals>,' ')\line status = zlinfo(unit,type,key,format,maxlen,nelement,<optionals>, 0);}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zlinfo}{ will return certain information about a single label item of given TYPE and KEY. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line Unit of associated file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: input, string\line `PROPERTY', 'HISTORY' or 'SYSTEM'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b KEY}{: input, string\line The key word of the desired label item. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORMAT}{: output, string, maximum length 8\line FORMAT indicates the format of the label item. Valid values are: 'INT', 'REAL', or 'STRING'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXLENGTH}{: output, integer\line Indicates the maximum length of any value associated with this key word. The length of 'INT' and 'REAL' items is always 4, meaning 4 bytes. The length of a 'STRING' item does }{\i not}{ include the null terminator, so if you are dynamically allocating an array in C to hold the values,  dimension it to MAXLENGTH + 1 to leave room for the null terminator. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NELEMENT}{: output, integer\line Returns the number of values associated with the entered key word. \par {\*\bkmkstart Heading79}{\*\bkmkstart _Toc423243893}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line The error status. The values are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395971271 }}{\fldrslt {\cs109\lang1024 140}}}{\cs109 )}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_ACT:}{ input, string\line Indicates the action to be taken by the Executive when an error condition is raised as a result of this call. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings:\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort; otherwise, the routine will return with an error number in STATUS \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the ERR_MESS optional to print \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to print \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {The three values are independent of each other. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If ERR_ACT consists only of blanks, an error will cause routine to return an error number in STATUS. \line If ERR_ACT is not specified, then the action defaults to the value of the LAB_ACT optional to }{\b x/zvopen}{ (the default for LAB_ACT is specified by }{\b x/zveaction}{). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ERR_MESS:}{ input, string\line Holds the user message that the programmer wishes printed when an error occurs as directed by ERR_ACT. Default is specified by }{\b x/zveaction}{. \line If the ERR_ACT option is not specified, and the LAB_ACT option given to }{\b x/zvopen}{ specifies a message be printed, the message given by LAB_MESS, }{\i not}{ ERR_MESS is printed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MOD}{: output, integer\line Indicates whether the label item is modifiable by the programmer. Values: 0 modifiable, 1 not modifiable. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STRLEN}{: output, integer\line This optional returns the maximum length of any label element when the elements are treated as strings. For STRING format labels, this is identical to MAXLENGTH. For INT or REAL formats, the label is treated as if the integer or real values were strings, and the length of the character representation of the value is returned. This is needed in combination with calling}{\b  x/zlget}{ with a FORMA T of STRING, which causes all items to be returned as strings. This is useful when printing the values, as no format conversion is required. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INSTANCE}{: input, integer\line If TYPE is 'HISTORY\rquote  and HIST has been entered, INSTANCE gives the sequence number of the particular instance of the processing task for the condition where a processing task occurs more than once in the history subsets. If TYPE is \lquote PROPERTY\rquote  and PROPERTY has been entered, INSTANCE gives the sequence number of the particular instance of the property label for the condition where a property set with identical names occurs more than once. Default: 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b HIST}{: input, string\line If TYPE is 'HISTORY' then this argument holds the name of the processing task that identifies the particular history subset in which 'KEY' may be found; if not entered, defaults to current task. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b PROPERTY}{, string: The name of the property set that the label routine is accessing The PROPERTY optional argument is only valid if the TYPE argument of the above routines is set to \ldblquote PROPERTY\rdblquote . See }{\field{\*\fldinst { REF _Ref424721848 \\n }}{\fldrslt {4.1.2.1}}}{ }{\field{\*\fldinst { REF _Ref424721848 \\* MERGEFORMAT }}{\fldrslt {Using Property Labels}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading70 }}{\fldrslt {\cs109\lang1024 74}}}{\cs109 )}{, for more information. \par {\*\bkmkstart _Toc453201430}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.2.6\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zlninfo\emdash Return name of next key{\*\bkmkend Heading79}{\*\bkmkend _Toc423243893}{\*\bkmkend _Toc453201430} \par }\pard\plain \sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\f6 call xlninfo(unit,key,format,maxlength,nelement,status,<optionals>,' ')\line status = zlninfo(unit,key,format,maxlength,nelement,<optionals>, 0);}{\cs33\f6 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zlninfo}{ operates much like the routine }{\b x/zlinfo}{ except that }{\b x/zlninfo}{ does not expect an input for KEY. Instead, }{\b x/zlninfo}{ will return a string in KEY which holds the next label item key word in the sequence of label items for the given TYPE. In addition, }{\b x/zlninfo}{ will return the same information as }{\b x/zlinfo}{. If the last available label item has already been returned then that condition will be indicated in STATUS. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line Unit of associated file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b KEY}{: output, string, maximum length 32\line The key word of the next label item. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORMAT}{: output, string, maximum length 8\line Indicates the format of the label item. Values: 'INT', 'REAL', 'STRING'. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXLENGTH}{: output, integer\line Indicates the maximum length of any value associated with this key word. The length of 'INT' and 'REAL' items is always 4, meaning 4 bytes. The length of a 'STRING' item does }{\i not}{ include the null terminator, so if you are dynamically allocating an array in C to hold the values,  dimension it to MAXLENGTH + 1 to leave room for the null terminator. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NELEMENT}{: output, integer\line Returns the number of values associated with the entered key word. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line The error status. The values are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395971271 }}{\fldrslt {\cs109\lang1024 140}}}{\cs109 )}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_ACT:}{ input, string\line Indicates the action to be taken by the Executive when an error condition is raised as a result of this call. A valid string may contain one or more of three characters in any order, 'A', 'U', 'S'. The presence of each character has the following meanings:\par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: an error will cause an immediate program abort; otherwise, the routine will return with an error number in STATUS \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: an error will cause the string that the user has specified with the ERR_MESS optional to print \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: an error will cause a system message to print \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {The three values are independent of each other. Thus 'SA' will cause a system message to be printed and the program to abort if an error occurs. If ERR_ACT consists only of blanks, an error will cause routine to return an error number in STATUS. \line If ERR_ACT is not specified, then the action defaults to the value of the LAB_ACT optional to }{\b x/zvopen}{ (the default for LAB_ACT is specified by }{\b x/zveaction}{). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ERR_MESS:}{ input, string\line Holds the user message that the programmer wishes printed when an error occurs as directed by ERR_ACT. Default is specified by }{\b x/zveaction}{. \line If the ERR_ACT option is not specified, and the LAB_ACT option given to }{\b x/zvopen}{ specifies a message be printed, the message given by LAB_MESS, }{\i not}{ ERR_MESS is printed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MOD}{: output, integer\line Indicates whether the label item is modifiable by the programmer. Values: 0 modifiable, 1 not modifiable. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STRLEN}{: output, integer\line This optional returns the maximum length of any label element when the elements are treated as strings. For STRING format labels, this is identical to MAXLENGTH. For INT or REAL formats, the label is treated as if the integer or real values were strings, and the length of the character representation of the value is returned. This is needed in combination when calling}{\b  x/zlget}{ with a FORMAT of STRING, which causes all items to be returned as strings. This is useful when printing the values, as no format conversion is required. \par {\*\bkmkstart _Toc453201431}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 4.2.7\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zlpinfo\emdash Returns the names of property subsets in the given file{\*\bkmkend Heading126}{\*\bkmkend _Toc425047598}{\*\bkmkend _Toc425048153}{\*\bkmkend _Toc453201431} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xlpinfo(unit, properties, nprop, status, <optionals>, ' ')\line status = zlpinfo(unit, properties, nprop, <optionals>, 0);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Returns the names of property subsets in the given file. Property labels are broken up into subsets, each with a property name. This routine returns a list of all property names in the file specified by UNIT, which must be open. This routine is identical to }{\b xlhinfo}{, except that it returns property names instead of task names and instances.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: integer, input\line UNIT is the unit number of an open file. The property names in the property label of this file are returned. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b PROPERTIES}{: string array, output\line PROPERTIES is a string array that gets the list of property names. When }{\b x/zlpinfo}{ is called from C, the size of each string in the array is given by the ULEN optional argument (which is required from C). There is no 8-character default as there is in }{\b zlhinfo}{. From FORTRAN, ULEN is optional, since the string length is obtained from the array itself (which must be a CHARACTER*n array). Since property names can be up to 32 characters, you should declare a FORTRAN array to be at least CHARACTER*32, and a C array should be at least 33 characters long (one additional character for the null terminator). The number of strings in the array is specified by the NPROP argument. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NPROP}{: integer, input/output\line On input, NPROP is the major dimension (maximum number of strings) in PROPERTIES. On output, it returns the number of properties returned in PROPERTIES. If there are more properties than the input NPROP allows, then the returned NPROP will be the same as the input since the maximum number of properties are returned. If you want the total number of properties in the label, regardless of the size of your supplied buffer, use the NRET optional argument. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line The error status. The values are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395971271 }}{\fldrslt {\cs109\lang1024 140}}}{\cs109 )}{. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_ACT}{: string, input\line Indicates the action to be taken by the RTL when an error occurs in this routine. A valid string may contain one or more of the characters listed below, in any order. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{ : Abort the program on error; otherwise the routine returns with STATUS set. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{ : Print the string specified in ERR_MESS if an error occurs. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{ : Print a system error message describing the error. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The three values are independent of each other. Thus, \ldblquote SA\rdblquote  will cause a system error message to be printed and the program to abort if an error occurs. If ERR_ACT is empty or contains only blanks, no action will be taken on error, and the error code will be returned in STATUS. \line If ERR_ACT is not specified, then the action defaults to the value of the LAB_ACT optional to}{\b  x/zvopen}{. The default for LAB_ACT is specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ERR_MESS:}{ string, input\line Specifies the user message to be printed when an error occurs as directed by ERR_ACT. If the ERR_ACT option is not specified, and the LAB_ACT option given to }{\b x/zvopen}{ specifies that a message be printed, the message given by LAB_ACT, }{\i not}{ ERR_MESS, is printed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NRET}{, integer, output\line NRET returns the total number of properties in the label. This can differ from the NPROP argument if the buffer provided was too small. NPROP returns the number actually in the buffer, while NRET returns the total number available. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ULEN}{, integer, input\line ULEN specifies the length of each element in the PROPERTIES array. ULEN is required on }{\b x/zlpinfo}{ when called from C to define the inner dimension of the array}{\caps . m}{ake sure to leave space for the null terminator, so ULEN should be at least 33. From FORTRAN, ULEN is optional. If it is not given, the string length will be picked up from the string array itself. The CHARACTER*n variable should be at least 32 characters. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INST_NUM}{, integer array, output. \line  An array with the same number of elements as NPROPS giving the instance of each property. INST_NUM returns a list of instances that match the names already returned. For example, if the property A is the first third and sixth element in PROPERTIES, then INST_NUM (1)=1, INST_NUM (3)=2, and INST_NUM (6)=3. If INST_NUM is not supplied, you won't get instance numbers, but you will still get repeated occurrences of names in the property name list if multiple instances are present.\par {\*\bkmkstart _Ref393697375}{\*\bkmkstart _Ref396008129}{\*\bkmkstart _Ref396008158}{\*\bkmkstart _Toc425047538}{\*\bkmkstart _Toc425048093}{\*\bkmkstart _Ref425588639}{\*\bkmkstart _Toc453201432}{\*\bkmkend Heading82}{\*\bkmkend Label}{\*\bkmkend Heading78}{\*\bkmkend _Toc425047537}{\*\bkmkend _Toc425048092}{\*\bkmkend _Toc425329705}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 5.\tab}}\pard\plain \s1\li360\sb60\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Parameter I/O{\*\bkmkend _Ref396008129}{\*\bkmkend _Ref396008158}{\*\bkmkend _Toc425047538}{\*\bkmkend _Toc425048093}{\*\bkmkend _Ref425588639}{\*\bkmkend _Toc453201432} \par {\*\bkmkstart Heading83}{\*\bkmkstart _Toc425047539}{\*\bkmkstart _Toc425048094}{\*\bkmkstart _Toc453201433}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.1\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Introduction{\*\bkmkend Heading83}{\*\bkmkend _Toc425047539}{\*\bkmkend _Toc425048094}{\*\bkmkend _Toc453201433} \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {A user of an application program under the TAE controls the behavior of the program by entering parameters either on the command line of the program, via the tutor mode, or in response to an interactive prompt from the program. \par Parameters may be of type real, key word, integer, or string, and may be singly or multiply valued. \par Input and output files to an application program are considered parameters as well, of type string. \par {\*\bkmkstart Heading84}{\*\bkmkstart _Toc425047540}{\*\bkmkstart _Toc425048095}{\*\bkmkstart _Toc453201434}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Parameter I/O {\*\bkmkend Heading84}{\*\bkmkend _Toc425047540}{\*\bkmkend _Toc425048095}API{\*\bkmkend _Toc453201434} \par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\field{\*\fldinst { TOC \\b "Parameter" \\n}}{\fldrslt {\lang1024 5.2.1\tab x/zvintract\emdash Prompt user for interactive command\par 5.2.2\tab x/zviparm\emdash Return interactive parameter values\par 5.2.3\tab x/zvip\emdash Interactive version of x/zvp; abbreviated version of x/zviparm\par 5.2.4\tab x/zviparmd\emdash Interactive version of x/zvparmd\par 5.2.5\tab x/zvipcnt\emdash Return the count of a parameter.\par 5.2.6\tab x/zvipone\emdash Interactive version of x/zvpone\par 5.2.7\tab x/zvipstat Interactive version of x/zvpstat\par 5.2.8\tab x/zviptst Interactive version of x/zvptst\par 5.2.9\tab x/zvp Abbreviated version of x/zvparm\par 5.2.10\tab x/zvparm\emdash Return a parameter value\par 5.2.11\tab x/zvparmd\emdash Double-precision version of x/zvparm\par 5.2.12\tab x/zvpcnt\emdash Return the count of a parameter.\par 5.2.13\tab x/zvpone Single value from a multivalued parameter\par 5.2.14\tab x/zvpstat Information about a parameter\par 5.2.15\tab x/zvptst Indicate whether key word was specified\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid }}\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {VICAR has sixteen parameter retrieval routines that may be called from an application program: \par {\*\bkmkstart Heading85}{\*\bkmkstart _Toc425047541}{\*\bkmkstart _Toc425048096}{\*\bkmkstart _Toc425329706}{\*\bkmkstart Parameter}{\*\bkmkstart _Toc453201435}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvintract\emdash Prompt user for interactive command{\*\bkmkend Heading85}{\*\bkmkend _Toc425047541}{\*\bkmkend _Toc425048096}{\*\bkmkend _Toc425329706}{\*\bkmkend _Toc453201435} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvintract( subcmd, prompt) \line zvintract( subcmd, prompt) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {A call to this subroutine initiates a TAE interactive parameter session and returns in a buffer the parameters input by the user. This buffer is not visible to the program, but these parameters can be retrieved by the program using subroutine }{\b x/zviparm}{. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b SUBCMD}{: input, string\line Subcommand in the PDF. The string may contain up to 9 characters, and it maybe specified either as a FORTRAN CHARACTER type (by descriptor) or as a char* for C. If it's an empty string or a single blank, the entire PDF is used. This string may include the leading dash (\ldblquote -\rdblquote ); one will be added if the programmer omits it. If this string only contains a dash, then the user will be required to specify a subcommand name as the first interactive input item. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b PROMPT}{: input, string\line Prompt string to be used in the interactive parameter session. The string may contain up to 20 characters, and it may be specified either as a FORTRAN CHARACTER type(by Descriptor) ) or as a char* for C. If it's an empty string or a single blank, the TAE default (a list of the parameters) is used. \par {\*\bkmkstart Heading86}{\*\bkmkstart _Toc425047542}{\*\bkmkstart _Toc425048097}{\*\bkmkstart _Toc425329707}{\*\bkmkstart _Toc453201436}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.2\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zviparm\emdash Return interactive parameter values{\*\bkmkend Heading86}{\*\bkmkend _Toc425047542}{\*\bkmkend _Toc425048097}{\*\bkmkend _Toc425329707}{\*\bkmkend _Toc453201436} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xviparm(name, value, count, def, maxcnt)\line status = zviparm(name, value, count, def, maxcnt, length);}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zviparm}{ returns information about the value(s) specified for a parameter interactively, given a parameter name. The returned information includes: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {The value(s) specified by the user or by default. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {The count, i.e. number of values specified for the parameter. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {The default flag. This flag should not be used. It is maintained for compatibility reasons, but the parameter count should be used instead. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Both the parameter name and, if it is a character string, the value may be specified as CHARACTER*n type for FORTRAN or char for C.\par For multivalued strings, the value should be a two-dimensional array of char (C) or an array of CHARACTER*n (Fortran).  For C, the length of the inner dimension must be specified via the "length" parameter. If the length is 0, or a BYTE array is passed in Fortran, then the strings will be returned in the old x/zvsptr format, which has been deprecated and should no longer be used.\par A call to subroutine }{\b x/zvintract}{ is required before this routine is called, in order to initiate an interactive parameter session. \par If an error occurs, such as the parameter wasn't found, then COUNT is returned as 0, and the action specified by }{\b x/zveaction}{ is taken. \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAMARG}{: input, string, maximum length 8\line NAMARG specifies the parameter name as given in the PDF. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALARG}{: output, string\line If integer/real: parameter value(s) returned. This may be an array of string: argument for returned string. CHARACTER*n type for FORTRAN or char for C. For multivalued strings, the value should be a two-dimensional array of char (C) or an array of CHARACTER*n (Fortran).  For C, the length of the inner dimension must be specified via the "length" parameter.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: output, integer\line COUNT gives the number of parameter values returned. If zero, the parameter was not found. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DEF}{: output, integer\line DEF is the default flag. If DEF = 0, then values are user-specified. If DEF = 1, then values are PDF defaults. This flag should not be used. It is maintained for compatibility reasons, but the parameter count should be used instead. If you want to have a program-supplied default, then allow the parameter to be nullable. If there are no values entered, then you can provide a default value in the program. Otherwise, the defaults in the PDF should be real default values, and it shouldn't matter whether the user entered them or not. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Optional arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b MAXCNT}{: input, integer\line The maximum number of parameter values to be returned. This should be the dimension of the parameter array in the calling routine. \par {\*\bkmkstart Heading87}{\*\bkmkstart _Toc425047543}{\*\bkmkstart _Toc425048098}{\*\bkmkstart _Toc425329708}{\*\bkmkstart Heading97}{\*\bkmkstart _Toc425047553}{\*\bkmkstart _Toc425048108}{\*\bkmkstart _Toc425329718}{\*\bkmkstart _Toc453201437}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.3\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvip\emdash Interactive version of x/zvp; abbreviated version of x/zviparm{\*\bkmkend Heading97}{\*\bkmkend _Toc425047553}{\*\bkmkend _Toc425048108}{\*\bkmkend _Toc425329718}{\*\bkmkend _Toc453201437} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvip(name, value, count) \line status = zvip(name, value, count);}{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Interactive version of }{\b x/zvp}{; abbreviated version of }{\b x/zviparm}{. Returns the value(s) of the given interactive parameter, and the number of values. }{\b \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: string, input\line NAME is the name of the interactive parameter to get values from.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALUE}{: parameter\emdash value-array, output\line The value of the parameter is returned in the VALUE array. The type of the value depends on the type of the parameter, which is either INTEGER, STRING or REAL (single-precision). \line There is no provision for providing a string length under C. Therefore, }{\b zvip}{ should }{\i not}{ be used for a string array. It is okay for a single string value, but if you want to get a multi-valued string, use }{\b zviparm}{ instead. If you do get a multi valued string with }{\b zvip}{, it is returned in the }{\b zvsptr}{ packed format, which is obsolete and should not be used. In FORTRAN, this restriction does not apply, since the string length for each element can be obtained from the string itself. \line There is no way to specify the size of the value buffer, so make sure it is big enough to handle the maximum count allowed in the PDF. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: integer, output\line The number of values in the parameter is returned in COUNT. \line Warning: In }{\b xvp}{, the value of COUNT is set to 0 if the parameter has been defaulted. This is actually a design flaw, but has been retained for compatibility. The other three routines, }{\b zvp}{, }{\b xvip}{, and }{\b zvip}{, do not have this flaw. Being new routines, they can be done correctly without compatibility problems. The COUNT parameter returns the actual number of parameters in the value parameter, whether they are defaults or not. However, the variant behavior of }{\b xvp}{ is likely to cause some confusion. Do not depend on this behavior in }{\b xvp}{, as it may change to be consistent in the future. If you are using }{\b xvp}{, either construct the PDF such that this problem won't matter, or use }{\b xvpcnt}{ to get the actual count. This is a design flaw for two reasons: With the count returned as 0, there is no way to know if there is anything valid in the VALUE parameter, so it becomes useless. Second, the default flag should never be used; it is maintained for compatibility purposes only. The count of the parameter should be used instead. \par {\*\bkmkstart Heading98}{\*\bkmkstart _Toc425047554}{\*\bkmkstart _Toc425048109}{\*\bkmkstart _Toc425329719}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201438}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.4\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zviparmd\emdash Interactive version of x/zvparmd{\*\bkmkend Heading98}{\*\bkmkend _Toc425047554}{\*\bkmkend _Toc425048109}{\*\bkmkend _Toc425329719}{\*\bkmkend _Toc453201438} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xviparmd(name, value, count, def, maxcnt) \line status = zviparmd(name, value, count, def, maxcnt, length);}{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Interactive version of }{\b x/zvparmd}{. \par This routine is exactly like }{\b x/zviparm}{, except that if the interactive parameter being returned is REAL, the VALUE parameter is returned in double precision format. }{\b x/zviparm}{ returns the value in single precision. Although VALUE supports integers and strings as well, }{\b x/zviparmd}{ should generally be used only for double-precision numbers. }{\b x/zviparm}{ should be used for integers and strings. \par This routine replaces the functionality of the R8FLAG parameter that was previously on }{\b x/zviparm. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: string, input\line NAME is the name of the interactive parameter to get values from.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALUE}{: parameter\emdash value-array, output\line The value of the parameter is returned in the VALUE array. The type of the value depends on the type of the parameter, which is either INTEGER, STRING, or REAL (double-precision). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: integer, output\line Reports the number of values returned in the VALUE parameter. A COUNT of 0 means the parameter either had a null value or was not found. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DEF}{: integer, output\line Returns 1 if the parameter was defaulted, and 0 otherwise. \line NOTE: The DEF flag is obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXCNT}{: integer, input\line Specifies the maximum number of values to return. 0 means no limit. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LENGTH}{: integer, input\line Specifies the length of each string if a string array is passed in for VALUE. Useful only from C; FORTRAN gets string lengths automatically. If the parameter is not a string, or is only a single string, set LENGTH to 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201439}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.5\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvipcnt\emdash Return the count of a parameter.{\*\bkmkend Heading87}{\*\bkmkend _Toc425047543}{\*\bkmkend _Toc425048098}{\*\bkmkend _Toc425329708}{\*\bkmkend _Toc453201439} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvipcnt(name, count)\line status = zvipcnt(name, count);}{\cs33 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvpcnt}{ returns the parameter size information for an interactive parameter whose name is passed in the NAMARG parameter. \par If only two arguments are given, the actual count, or dimension of the parameter is passed back in COUNT. \par If an error occurs, such as the parameter wasn't found, then COUNT is returned as 0, and the action specified by }{\b x/zveaction}{ is taken. \par }{\b x/zvipcnt}{ may only be called after the user is prompted with }{\b x/zvintract}{. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAMARG}{: input, string\line The name of the parameter whose count is desired. NAMARG may be passed either by descriptor ( FORTRAN character) or by reference. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: output, integer \line The actual count of the parameter. For example, if the parameter is declared in the PDF file as having a count of up to 3, as in }{\cs33\f6 PARM I TYPE=INTEGER COUNT=1:3, }{and if the user specifies I=(4,7), then COUNT will be returned as 2. }{\b \par {\*\bkmkstart Heading88}{\*\bkmkstart _Toc425047544}{\*\bkmkstart _Toc425048099}{\*\bkmkstart _Toc425329709}{\*\bkmkstart Heading100}{\*\bkmkstart _Toc425047556}{\*\bkmkstart _Toc425048111}{\*\bkmkstart _Toc425329721}{\*\bkmkstart Heading99}{\*\bkmkstart _Toc425047555}{\*\bkmkstart _Toc425048110}{\*\bkmkstart _Toc425329720}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201440}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.6\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvipone\emdash Interactive version of x/zvpone{\*\bkmkend Heading99}{\*\bkmkend _Toc425047555}{\*\bkmkend _Toc425048110}{\*\bkmkend _Toc425329720}{\*\bkmkend _Toc453201440} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 status = xvipone(name, value, instance, maxlen) \line status = zvipone(name, value, instance, maxlen);}{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Interactive version of }{\b x/zvpone}{. \par This routine returns a single value from a multi-valued interactive parameter. It is most useful to get a string from a list of strings without having to mess with string arrays, but can be used for integer or real (single-precision) values as well. Note that}{\b  x/zvipone}{ is a FORTRAN function with a status return, which differs from most FORTRAN RTL routines}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: string, input\line NAME is the name of the interactive parameter to get a value from.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALUE}{: parameter\emdash value, output\line The value of the parameter is returned in VALUE. The type of the value depends on the type of the parameter, which is either INTEGER, STRING, or REAL (single-precision). There is no equivalent to }{\b x/zvipone}{ for double precision floating point; use }{\b x/zviparmd}{ instead. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INSTANCE}{: integer, input\line INSTANCE specifies which  value you want. INSTANCE starts counting at 1, so the fifth value would have an INSTANCE of 5. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXLEN}{: integer, input\line MAXLEN specifies the maximum length of the string buffer if the parameter is a string. It is used to avoid overflowing your buffer. If the parameter is not a string, or you don't care, set MAXLEN to 0. MAXLEN is rarely needed in FORTRAN, since string lengths are available from the strings themselves. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201441}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.7\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvipstat\emdash Interactive version of x/zvpstat{\*\bkmkend Heading100}{\*\bkmkend _Toc425047556}{\*\bkmkend _Toc425048111}{\*\bkmkend _Toc425329721}{\*\bkmkend _Toc453201441} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvipstat(name, count, def, maxlen, type) \line status = zvipstat(name, count, def, maxlen, type);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine returns information about an interactive parameter without returning its value. It is most useful to get the maximum length of any string and the number of strings in order to allocate a buffer before calling x/zviparm. This routine is also the only way to determine the data type of a parameter given only its name. The program should know the type in the PDF, but there are situations where this could be useful. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: string, input\line NAME is the name of the interactive parameter to get information about. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: integer, output\line Returns the number o f items in the parameter. If 0, parameter is either not found or is null. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DEF}{: integer, output\line Returns 1 if the parameter was defaulted, and 0 otherwise. \line NOTE: The DEF flag is obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXLEN}{: integer, output\line Returns the maximum length of any value in the parameter. For REAL and INT, it is just the size of a REAL or INT. For STRING, it is the length of the longest string in the parameter. It does not include the null terminator, so you should add one before allocating a buffer in C. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: string, output\line Returns the data type of the parameter. The possible values are \ldblquote INT\rdblquote , \ldblquote REAL\rdblquote , and \ldblquote STRING\rdblquote . \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201442}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.8\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zviptst{\*\bkmkend Heading88}{\*\bkmkend _Toc425047544}{\*\bkmkend _Toc425048099}{\*\bkmkend _Toc425329709}\emdash Interactive version of x/zvptst{\*\bkmkend _Toc453201442} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {GIVEN = xviptst ( KEY )\line GIVEN = zviptst ( KEY ); \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The interactive version of x/zvptst. This function returns true if a key word was specified and false if not. For example, a program could check if the value \ldblquote HALF\rdblquote  was given for a key word parameter with the code: \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {logical lhalf,xviptst\line \line       lhalf = xviptst('HALF')\line       if (lhalf) then\line         .\line         .\line         .\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The key word must be a value specified for a parameter of type KEY WORD. \par }{\b xviptst}{ must be declared LOGICAL in a FORTRAN program calling it. \par }{\b x/zviptst}{, like the other }{\b x/zvi}{ routines, may only be called after the user is prompted with }{\b x/zvintract}{. \par }\pard \li360\sb60\sa60\nowidctlpar\adjustright {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b KEY}{: input, string\line Name of key word to be tested for. Note this is not the parameter name, but one of the valid values for the key word parameter. Passed either by descriptor in FORTRAN (if CHARACTER string is passed) or reference in C (if char* is passed). \par {\*\bkmkstart Heading89}{\*\bkmkstart _Toc425047545}{\*\bkmkstart _Toc425048100}{\*\bkmkstart _Toc425329710}{\*\bkmkstart _Toc453201443}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.9\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvp\emdash Abbreviated version of x/zvparm{\*\bkmkend Heading89}{\*\bkmkend _Toc425047545}{\*\bkmkend _Toc425048100}{\*\bkmkend _Toc425329710}{\*\bkmkend _Toc453201443} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvp(name, val, count) \line status = zvp(name, val, count) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvp}{ returns information about the value(s) specified for a parameter whenthe program was run, given a parameter name. It is an abbreviated version of }{\b x/zvparm}{, for user convenience. The returned information includes: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {The value(s) specified by the user or by default. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {The count, i.e. number of values specified for the parameter. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Both the parameter name and, if it is a character string, the value may be specified as CHARACTER*n type for FORTRAN or char for C.\par For multivalued strings, the value should be a two-dimensional array of char (C) or an array of CHARACTER*n (Fortran).  For C, the length of the inner dimension must be specified via the "length" parameter. If the length is 0, or a BYTE array is passed in Fortran, then the strings will be returned in the old x/zvsptr format, which has been deprecated and should no longer be used.\par If an error occurs, such as the parameter wasn't found, then COUNT is returned as 0, and the action specified by }{\b x/zveaction}{ is taken. \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: input, string\line NAME is the parameter name argument. This specifies the parameter name. It maybe either a descriptor, if a FORTAN CHARACTER type is passed, or reference (memory address), if a char (C) array is passed). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALARG}{: output, string\line If integer/real: parameter value(s) returned. This may be an array of string: argument for returned string. CHARACTER*n type for FORTRAN or char for C. For multivalued strings, the value should be a two-dimensional array of char (C) or an array of CHARACTER*n (Fortran).  For C, the length of the inner dimension must be specified via the "length" parameter.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: output, integer\line COUNT gives the number of parameter values returned. If zero, the parameter was not found or the parameter was defaulted by the user. If the parameter was defaulted (given a default in the PDF but not by the user), then COUNT is returned as 0, regardless of the actual number of parameters in the defaulted value. This is a design flaw that must be maintained for historical reasons. \par {\*\bkmkstart Heading90}{\*\bkmkstart _Toc425047546}{\*\bkmkstart _Toc425048101}{\*\bkmkstart _Toc425329711}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201444}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.10\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvparm\emdash Return a parameter value{\*\bkmkend Heading90}{\*\bkmkend _Toc425047546}{\*\bkmkend _Toc425048101}{\*\bkmkend _Toc425329711}{\*\bkmkend _Toc453201444} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvparm( namarg, valarg, count, def, maxcnt) \line status = zvparm( namarg, valarg, count, def, maxcnt, length) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvparm}{ returns information about the value(s) specified for a parameter when the program was run, given a parameter name. The returned information includes: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {The value(s) specified by the user or by default. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {The count, i.e. number of values specified for the parameter. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {The default flag. This flag should not be used. It is maintained for compatibility reasons, but the parameter count should be used instead. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Both the parameter name and, if it is a character string, the value may be specified as CHARACTER*n type for FORTRAN or char for C.\par For multivalued strings, the value should be a two-dimensional array of char (C) or an array of CHARACTER*n (Fortran).  For C, the length of the inner dimension must be specified via the "length" parameter. If the length is 0, or a BYTE array is passed in Fortran, then the strings will be returned in the old x/zvsptr format, which has been deprecated and should no longer be used.\par If an error occurs, such as the parameter wasn't found, then COUNT is returned as 0, and the action specified by }{\b x/zveaction}{ is taken. \par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAMARG}{: input, string\line NAMARG is the parameter name argument. It specifies the parameter name. It may be either a descriptor, if a CHARACTER (FORTRAN) type is passed, or reference (memory address), if a char (C) array is passed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALARG}{: output, string\line If integer/real: parameter value(s) returned. This may be an array of string: argument for returned string. CHARACTER*n type for FORTRAN or char for C. For multivalued strings, the value should be a two-dimensional array of char (C) or an array of CHARACTER*n (Fortran).  For C, the length of the inner dimension must be specified via the "length" parameter.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: output, integer\line COUNT gives the number of parameter values returned. If zero, the parameter was not found. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DEF}{: output, integer\line DEF is the default flag. If DEF = 0, then values are user-specified. If DEF = 1, then values are PDF defaults. This flag should not be used. It is maintained for compatibility reasons, but the parameter count should be used instead. If y o u want to have a program-supplied default, then allow the parameter to be nullable. If there are no values entered, then you can provide a default value in the program. Otherwise, the defaults in the PDF should be real default values, and it shouldn't matter whether the user entered them or not. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXCNT}{: input, integer\line MAXCNT is the maximum number of parameter values to be returned. This should be the dimension of the parameter array in the calling routine. \par {\*\bkmkstart Heading92}{\*\bkmkstart _Toc425047548}{\*\bkmkstart _Toc425048103}{\*\bkmkstart _Toc425329713}{\*\bkmkstart Heading101}{\*\bkmkstart _Toc425047557}{\*\bkmkstart _Toc425048112}{\*\bkmkstart _Toc425329722}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LENGTH}{: integer, input\line Specifies the length of each string if a string array is passed in for VALUE. Useful only from C; FORTRAN gets string lengths automatically. If the parameter is not a string, or is only a single string, set LENGTH to 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201445}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.11\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvparmd\emdash Double-precision version of x/zvparm{\*\bkmkend Heading101}{\*\bkmkend _Toc425047557}{\*\bkmkend _Toc425048112}{\*\bkmkend _Toc425329722}{\*\bkmkend _Toc453201445} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvparmd(name, value, count, def, maxcnt) \line status = zvparmd(name, value,count, def, maxcnt, length);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Double-precision version of }{\b x/zvparm}{. \par This routine is exactly like }{\b x/zvparm}{, except that if the parameter being returned is REAL, the VALUE parameter is returned in double precision format. }{\b x/zvparm}{ returns the value in single precision. Although VALUE supports integers and strings as well, }{\b x/zvparmd}{ should generally be used only for double-precision numbers. }{\b x/zvparm}{ should be used for integers and strings. \par This routine replaces the functionality of the R8FLAG parameter that was previously on }{\b x/zvparm. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: string, input\line NAME is the name of the parameter to get values from. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALUE}{: parameter\emdash value-array, output\line The value of the parameter is returned in the VALUE array. The type of the value depends on the type of the parameter, which is either INTEGER, STRING, or REAL (double-precision). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: integer, output\line Reports the number of values returned in the VALUE parameter. A COUNT of 0 means the parameter either had a null value or was not found. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DEF}{: integer, output\line Returns 1 if the parameter was defaulted, and 0 otherwise. \line NOTE: The DEF flag is obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXCNT}{: integer, input\line Specifies the maximum number of values to return. 0 means no limit. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LENGTH}{: integer, input\line Specifies the length of each string if a string array is passed in for VALUE. Useful only from C; FORTRAN gets string lengths automatically. If the parameter is not a string, or is only a single string, set LENGTH to 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201446}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.12\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvpcnt\emdash Return the count of a parameter.{\*\bkmkend Heading92}{\*\bkmkend _Toc425047548}{\*\bkmkend _Toc425048103}{\*\bkmkend _Toc425329713}{\*\bkmkend _Toc453201446} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvpcnt( namarg, count) \line status = zvpcnt( namarg, count) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvpcnt}{ returns the parameter size information for a given parameter whose name is passed in the NAMARG parameter. \par If an error occurs, such as the parameter wasn't found, then COUNT is returned as 0, and the action specified by }{\b x/zveaction}{ is taken. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAMARG}{: input, string\line The name of the parameter whose count is desired. NAMARG may be passed either by descriptor ( FORTRAN character) or by reference. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: output, integer\line The actual count of the parameter. For example, if the parameter is declared in the PDF file as having a count of up to 3, as in }{\cs33\f6 PARM I TYPE=INTEGER COUNT=1:3, }{and if the user specifies I=(4,7), then COUNT will be returned as 2. }{\b \par {\*\bkmkstart Heading94}{\*\bkmkstart _Toc425047550}{\*\bkmkstart _Toc425048105}{\*\bkmkstart _Toc425329715}{\*\bkmkstart Heading103}{\*\bkmkstart _Toc425047559}{\*\bkmkstart _Toc425048114}{\*\bkmkstart _Toc425329724}{\*\bkmkstart Heading102}{\*\bkmkstart _Toc425047558}{\*\bkmkstart _Toc425048113}{\*\bkmkstart _Toc425329723}{\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201447}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.13\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvpone\emdash Single value from a multivalued parameter{\*\bkmkend Heading102}{\*\bkmkend _Toc425047558}{\*\bkmkend _Toc425048113}{\*\bkmkend _Toc425329723}{\*\bkmkend _Toc453201447} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 status = xvpone(name, value, instance, maxlen) \line status = zvpone(name, value,instance, maxlen);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine returns a single value from a multi-valued parameter. It is most useful to get a string from a list of strings without having to mess with string arrays, but can be used for integer or real (single-precision) values as well. }{\b xvpone}{ is a FORTRAN function with a status return, which differs from most FORTRAN RTL routines}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: string, input\line NAME is the name of the parameter to get a value from. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALUE}{: parameter\emdash value, output\line The value of the parameter is returned in VALUE. The type of the value depends on the type of the parameter, which is either INTEGER, STRING, or REAL (single-precision). There is no equivalent to }{\b x/zvpone}{ for double precision floating point; use }{\b x/zvparmd}{ instead. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INSTANCE}{: integer, input\line INSTANCE specifies which value you want. INSTANCE starts counting at 1, so the fifth value would have an INSTANCE of 5. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXLEN}{: integer, input\line MAXLEN specifies the maximum length of the string buffer if the parameter is a string. It is used to avoid overflowing your buffer. If the parameter is not a string, or you don't care, set MAXLEN to 0. MAXLEN is rarely needed in FORTRAN, since string lengths are available from the strings themselves. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart _Toc453201448}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.14\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvpstat\emdash Information about a parameter{\*\bkmkend Heading103}{\*\bkmkend _Toc425047559}{\*\bkmkend _Toc425048114}{\*\bkmkend _Toc425329724}{\*\bkmkend _Toc453201448} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvpstat(name, count, def, maxlen, type) \line status = zvpstat(name, count,def, maxlen, type);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine returns information about a parameter without returning its value. It is most useful to get the maximum length of any string and the number of strings in order to allocate a buffer before calling }{\b x/zvparm}{. This routine is also the only way to determine the data type of a parameter given only its name. The program should know the type in the PDF, but there are situations where this could be useful}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: string, input\line NAME is the name of the parameter to get information about. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: integer, output\line Returns the number of items in the parameter. If 0, parameter is either not found or is null. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DEF}{: integer, output\line Returns 1 if the parameter was defaulted, and 0 otherwise. \line NOTE: The DEF flag is obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAXLEN}{: integer, output\line Returns the maximum length of any value in the parameter. For REAL and INT, it is just the size of a REAL or INT. For STRING, it is the length of the longest string in the parameter. It does not include the null terminator, so you should add one before allocating a buffer in C. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: string, output\line Returns the data type of the parameter. The possible values are \ldblquote INT\rdblquote , \ldblquote REAL\rdblquote , and \ldblquote STRING\rdblquote . \par {\*\bkmkstart _Toc453201449}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.2.15\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvptst Indicate whether key word was specified{\*\bkmkend Heading94}{\*\bkmkend _Toc425047550}{\*\bkmkend _Toc425048105}{\*\bkmkend _Toc425329715}{\*\bkmkend _Toc453201449} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 GIVEN = xvptst( key ) \line GIVEN = zvptst( key ); }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This function returns true if a key word was specified and false if not. For example, a program could check if the value \ldblquote HALF\rdblquote  was given for a key word parameter with the code: \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {logical lhalf,xviptst\line \line       lhalf = xviptst('HALF')\line       if (lhalf) then\line         .\line         .\line         .}{\cs33 \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {The key word must be a value specified for a parameter of type KEYWORD. }{\b Note:}{ Should be declared as a LOGICAL function in FORTRAN, as in the above example. \par }{\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b KEY}{: input, string\line Name of key word to be tested for. Note this is not the parameter name, but one of the valid values for the key word parameter. Passed either by descriptor in FORTRAN (if CHARACTER string is passed) or reference in C (if char* array is passed). \par {\*\bkmkstart _Toc425047560}{\*\bkmkstart _Toc425048115}{\*\bkmkstart _Toc453201450}{\*\bkmkend Parameter}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 5.3\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Examples{\*\bkmkend _Toc425047560}{\*\bkmkend _Toc425048115}{\*\bkmkend _Toc453201450}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {When using the \ldblquote vparm\rdblquote  routines to get parameter input from the user, you should always look at the count field, never the def field, to see if a value has been entered. But if there are no values, the return value is not necessarily touched... you're guaranteed "count" valid values but that might be 0.\par To allow for all possible cases, use this test:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {   if (count == 0 || strlen(value) == 0)\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This protects against null input. The user could enter a null value, in which case count is 1 but the value is empty.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\sect }\sectd \linex0\headery1440\footery706\colsx709\endnhere\sectdefaultcl {\*\bkmkstart _Ref394140865}{\*\bkmkstart _Toc425047561}{\*\bkmkstart _Toc425048116}{\*\bkmkstart _Toc453201451}{\*\bkmkend _Ref393697375}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 6.\tab}\pard\plain \s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Translation Routines{\*\bkmkend _Ref394140865}{\*\bkmkend _Toc425047561}{\*\bkmkend _Toc425048116}{\*\bkmkend _Toc453201451} \par {\*\bkmkstart _Toc425047562}{\*\bkmkstart _Toc425048117}{\*\bkmkstart _Toc453201452}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.1\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Introduction{\*\bkmkend _Toc425047562}{\*\bkmkend _Toc425048117}{\*\bkmkend _Toc453201452}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The translation routines allow conversion of data between different data types and different host representations. See }{\field{\*\fldinst { REF Heading5 \\n }}{\fldrslt {1.3}}}{ }{\field{\*\fldinst { REF Heading5 \\* MERGEFORMAT }}{\fldrslt {Data Types and Host Representations}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading5 }}{\fldrslt {\cs109\lang1024 9}}}{\cs109 )}{, for more information on when and how to call these routines. \par These routines all take a translation buffer as an argument. This is an opaque structure that is at least 12 integers (usually 48 bytes) long that will describe the translation. The internals of the buffer are unknown to the application; it is a private RTL data structure. One of five routines must be called first to set up this buffer. Then,}{\b  x/zvtrans}{ can be called as often as necessary to perform the translation. You may have several translations available at once by using different translation buffers. \par The first integer in the buffer is special. If it is NULL (0) after the setup routine has been called, then no translation is needed. }{\b x/zvtrans}{ will simply move the data in this case, but you can decide to forego calling }{\b x/zvtrans}{ if it would be more efficient. This first integer is the }{\i only }{item an application may look at in the translation buffer. Using }{\i any}{ other knowledge about the internals of the buffer may cause your program to break in the future, as the structure may change without notice. \par {\*\bkmkstart _Toc425047563}{\*\bkmkstart _Toc425048118}{\*\bkmkstart _Toc453201453}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Translation {\*\bkmkend _Toc425047563}{\*\bkmkend _Toc425048118}API{\*\bkmkend _Toc453201453}\par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\*\bkmkstart Heading104}{\*\bkmkstart _Toc425047564}{\*\bkmkstart _Toc425048119}{\*\bkmkstart _Toc425329725}{\*\bkmkstart Translate}{\field{\*\fldinst { TOC \\b "Translate" \\n}}{\fldrslt {\lang1024 6.2.1\tab x/zvhost\emdash Integer and real data representations of a host given the host type name\par 6.2.2\tab x/zvpixsize\emdash Size of a pixel in bytes given the data type and host representation\par 6.2.3\tab x/zvpixsizeb\emdash Size of a binary label value in bytes from a file\par 6.2.4\tab x/zvpixsizeu\emdash Size of a pixel in bytes from a file\par 6.2.5\tab x/zvtrans\emdash Translate pixels from one format to another\par 6.2.6\tab x/zvtrans_in\emdash Create translation buffer for input\par 6.2.7\tab x/zvtrans_inb\emdash Create translation buffer for input from binary labels of a file\par 6.2.8\tab x/zvtrans_inu\emdash Create translation buffer for input from a file\par 6.2.9\tab x/zvtrans_out\emdash Create translation buffer for output\par 6.2.10\tab x/zvtrans_set\emdash Create translation buffer for data types only\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid }}\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {{\*\bkmkstart Heading130}{\*\bkmkstart _Toc425047602}{\*\bkmkstart _Toc425048157}Below are the ten subroutines that comprise the Translation API.\par {\*\bkmkstart _Toc453201454}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvhost\emdash Integer and real data representations of a host given the host type name{\*\bkmkend Heading130}{\*\bkmkend _Toc425047602}{\*\bkmkend _Toc425048157}{\*\bkmkend _Toc453201454} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvhost(host, intfmt, realfmt, status) \line status = zvhost(host, intfmt, realfmt);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Returns the integer and real data representations of a host given the host type name. The returned values may be used with the translation routines or the INTFMT and REALFMT system label items. This routine can also return the host type name, for use with the HOST system label. \par This routine is rarely needed, as the normal case is to read any type of file (where you get INTFMT and REALFMT from the file), and to write in native format (where you don't need to specify the formats). However, this routine is useful in the rare case that a program needs to write in a non-native format. The user can select the machine type for output, and this routine will return the data representations needed for that machine type.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b HOST}{: string, input\line HOST is the type name of the host you want information about. It is not the name of a particular machine, rather, it is the name of a type of machine. HOST corresponds to the HOST system label. The HOST system label is intended for documentation only, however, the same values are valid in this parameter. Normally, the HOST parameter will come from user input. The valid values will change as VICAR is ported to more machines, so the program should allow any value as user input, then check the status from}{\b  x/zvhost}{ to see if the machine name is valid. The currently valid values are listed. See }{\field{\*\fldinst { REF _Ref393618344 \\* MERGEFORMAT }}{\fldrslt {Table 1: Valid VICAR HOST Labels and Machine Types}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618344 }}{\fldrslt {\cs109\lang1024 11}}}{\cs109 )}{. In addition, the following values are accepted: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {NATIVE : Returns the INTFMT and REALFMT for the machine currently running. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {LOCAL : Same as NATIVE. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {HOSTNAME : Special, see below. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {The value \ldblquote HOSTNAME\rdblquote  is special. If this value is given for HOST, then the return values change. The parameter INTFMT returns the host type name for the machine currently running. The parameter REALFMT is undefined on output. The value returned in INTFMT could then be used in another call to}{\b  x/zvhost}{ (which wouldn't gain much since \ldblquote NATIVE\rdblquote  or \ldblquote LOCAL\rdblquote  do the same thing), or it could be used in a HOST label. This should be needed only from FORTRAN. A C program should use the \ldblquote  NATIVE _HOST_LABEL\rdblquote  macro defined in x/zvmaininc.h instead. Similarly, \ldblquote NATIVE\rdblquote  and \ldblquote LOCAL\rdblquote  will be mainly useful in a FORTRAN program, as a C program should use the NATIVE_INTFMT and NATIVE_REALFMT macros. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b INTFMT}{: string, output\line The integral host representation for the machine in question is returned in INTFMT. It corresponds to the INTFMT label item in a file, and the related parameters to the translation routines. The returned value will be one of the supported integer data types, which are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618329 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. \line If the special host name \ldblquote HOSTNAME\rdblquote  is given, then INTFMT instead returns the host type name (HOST label) of the native machine. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b REALFMT}{: string,  output\line The floating-point host representation for the machine in question is returned in REALFMT. It corresponds to the REALFMT label item in a file, and the related parameters to the translation routines. The returned value will be one of the supported floating-point data types, which are listed. See }{\field{\*\fldinst { REF _Ref393618311 \\* MERGEFORMAT }}{\fldrslt {Table 3: Valid VICAR Real Number Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618311 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. \line If the special host name \ldblquote HOSTNAME\rdblquote  is given, then the value returned in REALFMT is undefined and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: integer, output\line The returned status value. It is an argument in FORTRAN and the function return value in C. Any value other than SUCCESS indicates that the value given for HOST was invalid. \par {\*\bkmkstart Heading131}{\*\bkmkstart _Toc425047603}{\*\bkmkstart _Toc425048158}{\*\bkmkstart _Toc453201455}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.2\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvpixsize\emdash Size of a pixel in bytes given the data type and host representation{\*\bkmkend Heading131}{\*\bkmkend _Toc425047603}{\*\bkmkend _Toc425048158}{\*\bkmkend _Toc453201455} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 status = xvpixsize(pixsize, type, ihost, rhost) \line status = zvpixsize(pixsize, type, ihost, rhost);}{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Returns the size of a pixel in bytes given the data type and host representation. One of the }{\b pixsize}{ routines should be used to figure out the size of a pixel. Do }{\i not}{ assume any particular size, like 4 bytes for a REAL. It may be different on other machines. It is valid to use }{\cs33\f6 sizeof()}{ in C to get the size of a pixel in the native representation }{\i only, }{but the }{\b pixsize}{ routines are the only valid way to get the size of a pixel on any other hosts.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b PIXSIZE}{: integer, output\line Returns the size of a pixel in bytes. If an error occurs (such as an invalid data type), PIXSIZE is returned as 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: string, input\line TYPE is the data type of the pixel. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote ,\rdblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b IHOST}{: string, input\line IHOST is the integral host representation for the pixel. It corresponds to the INTFMT label item in a file. It may be any of the supported integer data types, which are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618329 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. It may also be \ldblquote NATIVE\rdblquote  or \ldblquote LOCAL\rdblquote , both of which mean the native host INTFMT. IHOST should be given even if you are dealing with floating-point data types. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b RHOST}{: string, input\line RHOST is the floating-point host representation for the pixel. It corresponds to the REALFMT label item in a file. It may be any of the supported floating-point data types, which are listed. See }{\field{\*\fldinst { REF _Ref393618311 \\* MERGEFORMAT }}{\fldrslt {Table 3: Valid VICAR Real Number Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618311 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. It may also be \ldblquote NATIVE\rdblquote  or \ldblquote LOCAL\rdblquote , both of which mean the native host REALFMT. RHOST should be given even if you are dealing with integral datatypes. \par {\*\bkmkstart Heading132}{\*\bkmkstart _Toc425047604}{\*\bkmkstart _Toc425048159}{\*\bkmkstart _Toc453201456}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.3\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvpixsizeb\emdash Size of a binary label value in bytes from a file{\*\bkmkend Heading132}{\*\bkmkend _Toc425047604}{\*\bkmkend _Toc425048159}{\*\bkmkend _Toc453201456} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 status = xvpixsizeb(pixsize, type, unit) \line status = zvpixsizeb(pixsize, type, unit);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Return the size of a binary label value in bytes from a file. This routine is exactly like }{\b x/zvpixsize}{ except that the IHOST and RHOST values are obtained for binary labels from the file specified by UNIT, which must be open. It is provided merely as a shortcut to get the size of a binary label value for a file.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b PIXSIZE}{: integer, output\line Returns the size of a pixel in bytes. If an error occurs (such as an invalid data type), PIXSIZE is returned as 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: string, input\line TYPE is the data type of the binary label value. It corresponds to the FORMAT label item in a file, although binary label values are not restricted to FORMAT and maybe any data type. TYPE may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote ,\rdblquote FULL\rdblquote , \ldblquote REAL\rdblquote , \ldblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b UNIT}{: integer, input\line UNIT is the unit number of an open file, which is used to obtain the source BINTFMT and INTFMT. The values obtained from the file are used exactly like the }{\b x/zvpixsize}{ IHOST and RHOST. \par {\*\bkmkstart Heading133}{\*\bkmkstart _Toc425047605}{\*\bkmkstart _Toc425048160}{\*\bkmkstart _Toc453201457}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.4\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvpixsizeu\emdash Size of a pixel in bytes from a file{\*\bkmkend Heading133}{\*\bkmkend _Toc425047605}{\*\bkmkend _Toc425048160}{\*\bkmkend _Toc453201457} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 status = xvpixsizeu(pixsize, type, unit) \line status = zvpixsizeu(pixsize, type,unit);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Return the size of a pixel in bytes from a file. This routine is exactly like }{\b x/zvpixsize}{ except that the IHOST and RHOST values are obtained from the file specified by UNIT, which must be open. It is provided merely as a shortcut to get the pixel size of a file.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b PIXSIZE}{: integer, output\line Returns the size of a pixel in bytes. If an error occurs (such as an invalid data type), PIXSIZE is returned as 0. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TYPE}{: string, input\line TYPE is the data type of the pixel. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote ,\rdblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b UNIT}{: integer, input\line UNIT is the unit number of an open file, which is used to obtain the source INTFMT and REALFMT. The values obtained from the file are used exactly like the }{\b x/zvpixsize}{ IHOST and RHOST. \par {\*\bkmkstart _Toc453201458}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.5\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvtrans\emdash Translate pixels from one format to another{\*\bkmkend Heading104}{\*\bkmkend _Toc425047564}{\*\bkmkend _Toc425048119}{\*\bkmkend _Toc425329725}{\*\bkmkend _Toc453201458} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvtrans(buf, source, dest, npix) \line zvtrans(buf, source, dest, npix);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Translate pixels from one format to another. One of the translation setup routines must have been called first to set up the translation buffer. This routine is the only standard way to translate data in the VICAR system, both between host representations ( e. g. VAX to IEEE) and between data types (e.g. integer to real).\par This routine is coded to be very efficient, so it may be called inside a tight loop with very little performance penalty}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BUF}{: integer-array(12), input\line BUF is the translation buffer that describes the translation to be performed. It is initialized by one of the translation setup routines. The internals of this buffer are unknown to the application program, with one exception, described below. }{\i Any}{ other access to the internals of the buffer may cause your program to break in the future, as the structure may change without notice. \line If the first integer in the translation buffer is NULL (0), then }{\b x/zvtrans}{ merely moves the data from the source to the destination, without any conversion. This can happen often when reading a file, where you don't know ahead of time what host representation the input data is in. If it turns out to be the native representation, no translation is necessary, and the first integer of the buffer will be 0. This fact can sometimes be used to avoid copying the data, making the program more efficient. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SOURCE}{: pixel-buffer, input\line SOURCE is the source data buffer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DEST}{: pixel-buffer, output\line DEST is the destination data buffer. It may }{\i not}{ be the same as SOURCE, i.e. you can't translate in place or with overlapping buffers. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NPIX}{: integer, input\line NPIX is the number of pixels (not bytes!) to translate. Both SOURCE and DEST must be large enough to hold NPIX pixels; no checking is done}{\caps .}{ \par {\*\bkmkstart Heading105}{\*\bkmkstart _Toc425047565}{\*\bkmkstart _Toc425048120}{\*\bkmkstart _Toc425329726}{\*\bkmkstart _Toc453201459}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.6\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvtrans_in\emdash Create translation buffer for input{\*\bkmkend Heading105}{\*\bkmkend _Toc425047565}{\*\bkmkend _Toc425048120}{\*\bkmkend _Toc425329726}{\*\bkmkend _Toc453201459} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvtrans_in(buf, stype, dtype, sihost, srhost, status) \line status = zvtrans_in(buf, stype, dtype, sihost, srhost);}{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Create translation buffer for input. The data will be converted from a host representation of (SIHOST, SRHOST) and data type of STYPE into the machine's native representation and data type DTYPE. So, it converts from foreign to local format. Since all processing must be done in native format on the machine the program is running on, this translation is most often needed for input from a file}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BUF}{: integer-array(12), output\line BUF is the translation buffer that this routine will setup, describing the translation to be performed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STYPE}{: string, input\line STYPE is the source data type. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote ,\rdblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DTYPE}{: string, input\line DTYPE is the desired destination data type. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote , \ldblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SIHOST}{: string, input\line SIHOST is the host representation for the source of integral data types. It corresponds to the INTFMT label item in a file. It may be any of the supported integer data types, which are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618329 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. It may also be \ldblquote  NATIVE\rdblquote  or \ldblquote LOCAL\rdblquote , both of which mean the native host INTFMT. SIHOST should be given even if you are dealing only with floating-point data types. See also }{\b x/zvhost}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SRHOST}{: string, input\line SRHOST is the host representation for the source of floating-point data types. It corresponds to the REALFMT label item in a file. It may be any of the supported floating-point data types, which are listed. See }{\field{\*\fldinst { REF _Ref393618311 \\* MERGEFORMAT }}{\fldrslt {Table 3: Valid VICAR Real Number Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618311 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. It may also be \ldblquote NATIVE\rdblquote  or \ldblquote LOCAL\rdblquote , both of which mean the native host REALFMT. SRHOST should be given even if you are dealing only with integral data types. See also }{\b x/zvhost}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: integer, output\line The returned status value. It is an argument in FORTRAN and the function return value in C. Any value other than SUCCESS indicates that the translation is invalid for some reason, and the translation buffer should not be used. \par {\*\bkmkstart Heading106}{\*\bkmkstart _Toc425047566}{\*\bkmkstart _Toc425048121}{\*\bkmkstart _Toc425329727}{\*\bkmkstart _Toc453201460}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.7\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvtrans_inb\emdash Create translation buffer for input from binary labels of a file{\*\bkmkend Heading106}{\*\bkmkend _Toc425047566}{\*\bkmkend _Toc425048121}{\*\bkmkend _Toc425329727}{\*\bkmkend _Toc453201460} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvtrans_inb(buf, stype, dtype, unit, status) \line status = zvtrans_inb(buf,stype, dtype, unit);}{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Create translation buffer for input from the binary labels of a file. This routine is exactly like }{\b x/zvtrans_in}{ except that the SIHOST and SRHOST values are obtained for binary labels from the file specified by UNIT, which must be open. It is provided merely as a shortcut for the common case of reading binary label data from a labeled file}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BUF}{: integer-array(12), output\line BUF is the translation buffer that this routine will setup, describing the translation to be performed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STYPE}{: string, input\line STYPE is the source data type. It corresponds to the FORMAT label item in a file, although binary label values are not restricted to FORMAT and may be of any datatype. STYPE may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote ,\rdblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DTYPE}{: string, input\line DTYPE is the desired destination data type. It corresponds to the FORMAT label item in a file, although binary label values are not restricted to FORMAT and may be of any data type. DTYPE may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote , \ldblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b UNIT}{: integer, input\line UNIT is the unit number of an open file, which is used to obtain the source BINTFMT and INTFMT. The values obtained from the file are used exactly like the }{\b x/zvtrans_in}{ SIHOST and SRHOST. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: integer, output\line The returned status value. It is an argument in FORTRAN and the function return value in C. Any value other than SUCCESS indicates that the translation is invalid for some reason, and the translation buffer should not be used. \par {\*\bkmkstart Heading107}{\*\bkmkstart _Toc425047567}{\*\bkmkstart _Toc425048122}{\*\bkmkstart _Toc425329728}{\*\bkmkstart _Toc453201461}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.8\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvtrans_inu\emdash Create translation buffer for input from a file{\*\bkmkend Heading107}{\*\bkmkend _Toc425047567}{\*\bkmkend _Toc425048122}{\*\bkmkend _Toc425329728}{\*\bkmkend _Toc453201461} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvtrans_inu(buf, stype, dtype, unit, status) \line status = zvtrans_in u(buf,stype, dtype, unit);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Create translation buffer for input from a file. This routine is exactly like }{\b x/zvtrans_in}{ except that the SIHOST and SRHOST values are obtained from the file specified by UNIT, which must be open. It is provided as a shortcut for the common case of reading image data from a labeled file}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BUF}{: integer-array(12), output\line BUF is the translation buffer that this routine will setup, describing the translation to be performed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STYPE}{: string, input\line STYPE is the source data type. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote  BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote ,\rdblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DTYPE}{: string, input\line DTYPE is the desired destination data type. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote , \ldblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b UNIT}{: integer, input\line UNIT is the unit number of an open file, which is used to obtain the source INTFMT and REALFMT. The values obtained from the file are used exactly like the }{\b x/zvtrans_in}{ SIHOST and SRHOST. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: integer, output\line The returned status value. It is an argument in FORTRAN and the function return value in C. Any value other than SUCCESS indicates that the translation is invalid for some reason, and the translation buffer should not be used. \par {\*\bkmkstart Heading108}{\*\bkmkstart _Toc425047568}{\*\bkmkstart _Toc425048123}{\*\bkmkstart _Toc425329729}{\*\bkmkstart _Toc453201462}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.9\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvtrans_out\emdash Create translation buffer for output{\*\bkmkend Heading108}{\*\bkmkend _Toc425047568}{\*\bkmkend _Toc425048123}{\*\bkmkend _Toc425329729}{\*\bkmkend _Toc453201462} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvtrans_out(buf, stype, dtype, dihost, drhost, status) \line status =zvtrans_out(buf, stype, dtype, dihost, drhost);}{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Create translation buffer for output. The data will be converted from the machine's native representation and data type of STYPE into a host representation of (DIHOST, DRHOST) and data type of DTYPE. So, it converts from local to foreign format. Since all processing must be done in native format on the machine the program is running on, this translation is most often needed for output to a file. \par This routine is less commonly used than the input routines. The general rule for applications is to read any format, but write the native format. Translation on output is not needed in this case. However, }{\b x/zvtrans_out}{ is provided for special cases where the data must be written in a different host representation}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BUF}{: integer-array(12), output\line BUF is the translation buffer that this routine will create, describing the translation to be performed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STYPE}{: string, input\line STYPE is the source data type. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote ,\rdblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DTYPE}{: string, input\line DTYPE is the desired destination data type. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote , \ldblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DIHOST}{: string, input\line DIHOST is the host representation for the destination of integral data types. It corresponds to the INTFMT label item in a file. It may be any of the supported integer data types, which are listed. See }{\field{\*\fldinst { REF _Ref393618329 \\* MERGEFORMAT }}{\fldrslt {Table 2: Valid VICAR Integer Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618329 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. It may also be \ldblquote NATIVE\rdblquote  or \ldblquote LOCAL\rdblquote , both of which mean the native host INTFMT. DIHOST should be given even if you are dealing only with floating-point data types. See also }{\b x/zvhost}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DRHOST}{: string, input\line DRHOST is the host representation for the destination of floating-point data types. It corresponds to the REALFMT label item in a file. It may be any of the supported floating-point data types, which are listed. See }{\field{\*\fldinst { REF _Ref393618311 \\* MERGEFORMAT }}{\fldrslt {Table 3: Valid VICAR Real Number Formats}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393618311 }}{\fldrslt {\cs109\lang1024 12}}}{\cs109 )}{. It may also be \ldblquote NATIVE\rdblquote  or \ldblquote LOCAL\rdblquote , both of which mean the native host REALFMT. DRHOST should be given even if you are dealing only with integral data types. See also }{\b x/zvhost}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: integer, output\line The returned status value. An argument in FORTRAN or the function return value in C. Any value other than SUCCESS indicates that the translation is invalid, and the translation buffer should not be used. \par {\*\bkmkstart Heading109}{\*\bkmkstart _Toc425047569}{\*\bkmkstart _Toc425048124}{\*\bkmkstart _Toc425329730}{\*\bkmkstart _Toc453201463}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 6.2.10\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvtrans_set\emdash Create translation buffer for data types only{\*\bkmkend Heading109}{\*\bkmkend _Toc425047569}{\*\bkmkend _Toc425048124}{\*\bkmkend _Toc425329730}{\*\bkmkend _Toc453201463} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvtrans_set(buf, stype, dtype, status)\line status = zvtrans_set(buf, stype, dtype);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Create translation buffer for data types only. Both the source and the destination must be in the native host representation. It is useful for converting internal buffers from one data type to another. Don't use it with data direct from a file, however, as files are not guaranteed to be in the native host representation}{\b . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments: }{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b BUF}{: integer-array(12), output\line BUF is the translation buffer that this routine will setup, describing the translation to be performed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STYPE}{: string, input\line STYPE is the source data type. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote ,\rdblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DTYPE}{: string, input\line DTYPE is the desired destination data type. It corresponds to the FORMAT label item in a file. It may be one of the standard VICAR data types: \ldblquote BYTE\rdblquote , \ldblquote HALF\rdblquote , \ldblquote FULL\rdblquote , \ldblquote REAL\rdblquote , \ldblquote DOUB\rdblquote , or \ldblquote COMP\rdblquote . The types \ldblquote WORD\rdblquote , \ldblquote LONG\rdblquote , and \ldblquote COMPLEX\rdblquote  are also accepted, but are obsolete and should not be used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: integer, output\line The returned status value. It is an argument in FORTRAN and the function return value in C. Any value other than SUCCESS indicates that the translation is invalid for some reason, and the translation buffer should not be used. \par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\sect }\sectd \marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\guttersxn0\linex0\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\bkmkstart _Ref396018425}{\*\bkmkstart _Ref396018463}{\*\bkmkstart _Toc425047570}{\*\bkmkstart _Toc425048125}{\*\bkmkstart _Toc453201464}{\*\bkmkend Translate}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 7.\tab}\pard\plain \s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {FORTRAN String Conversion Routines{\*\bkmkend _Ref396018425}{\*\bkmkend _Ref396018463}{\*\bkmkend _Toc425047570}{\*\bkmkend _Toc425048125}{\*\bkmkend _Toc453201464}\par {\*\bkmkstart _Toc425047571}{\*\bkmkstart _Toc425048126}{\*\bkmkstart _Toc453201465}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.1\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Introduction{\*\bkmkend _Toc425047571}{\*\bkmkend _Toc425048126}{\*\bkmkend _Toc453201465}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {These routines allow C-language subroutines to use character strings passed in from a FORTRAN routine (CHARACTER*n data type). FORTRAN-callable subroutines written in C must use these routines to handle character strings. The passing of strings between FORTRAN and C varies widely among different machine architectures. Attempting to do your own without using these routines practically guarantees that your code will not be portable.\par These routines are most useful in the FORTRAN interface to SUBLIB routines, but they could be useful within a single application program if it uses both languages.\par All of these routines are callable from C only. Do not\} attempt to call them from FORTRAN. Writing a FORTRAN routine that accepts C strings is much more difficult. See }{\field{\*\fldinst { REF Heading37 \\n }}{\fldrslt {2.6}}}{ }{\field{\*\fldinst { REF Heading37 \\* MERGEFORMAT }}{\fldrslt {Mixing FORTRAN and C}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF Heading37 }}{\fldrslt {\cs109\lang1024 28}}}{\cs109 )}{.\par These routines have much in common in their calling sequences, so the common features and rules are described only once in the Common Features section below.\par Two of the routines apply only to strings being sent out of a C routine, back to the FORTRAN caller. They are marked \ldblquote output\rdblquote  below. The other four apply only to strings being passed in to a C routine, from a FORTRAN caller. They are marked \ldblquote input''.\par {\*\bkmkstart _Toc425047572}{\*\bkmkstart _Toc425048127}{\*\bkmkstart _Ref425062348}{\*\bkmkstart _Ref425062355}{\*\bkmkstart _Ref425062385}{\*\bkmkstart _Toc425329731}{\*\bkmkstart _Toc453201466}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.1.1\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Common Features: Rules and arguments common to all string routines{\*\bkmkend _Toc425047572}{\*\bkmkend _Toc425048127}{\*\bkmkend _Ref425062348}{\*\bkmkend _Ref425062355}{\*\bkmkend _Ref425062385}{\*\bkmkend _Toc425329731}{\*\bkmkend _Toc453201466}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {All the string conversion routines place great emphasis on the argument list of the C routine that is directly called by FORTRAN. Certain rules apply to that argument list, and many of the common parameters reference it. All of these apply to the routine called directly\} by FORTRAN. Suppose a FORTRAN routine calls routine a(), which then calls routine b(), and b() wants to call one of these string conversion routines. All of the parameters and rules will apply only to a()'s argument list. Routine b() will need much of the information passed in from a() in order to call the string conversion routines, but all the information is relative to a()'s argument list. In general, it's usually easier to have a() do all the conversion and let b() deal only with C strings, but sometimes that is impractical.\par {\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.1.1.1\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Include file\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {In order to use any of the routines, you must include the file \ldblquote ftnbridge.h\rdblquote . As with other RTL includes, you must include xvmaininc.h first, the names must be enclosed in double quotes and end in the \ldblquote .h\rdblquote  extension (you don't need xvmaininc.h if \ldblquote vicmain_c\rdblquote  is included). Example:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {#include "xvmaininc.h"\line #include "ftnbridge.h"\par {\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.1.1.2\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Imakefile\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The flag FTN_STRING must be defined in the imakefile for the program unit if any C routine accepts FORTRAN strings. This applies to both the direct-called routine, and the routine that ultimately calls one of the conversion routines. The FTN_STRING flag causes the compiler to use a lower level of optimization, which is required on some machines in order to access the argument list.\par \par {\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.1.1.3\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {FORSTR_PARAM and FORSTR_DEF macros\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {In most routines (see below for exception), include the macro FORSTR_PARAM in the argument list of the directly called routine, FORSTR_DEF at the end of the formal parameter declaration list, just before the opening brace of the procedure and FORSTR_BLOCK immediately after the opening brace of the function with no other declarations or statements before it.\par FORSTR_DEF and FORSTR_BLOCK should not have semicolons after them, as the semicolon (if needed) is included in the macro definition. These macros are no-ops on many machines, but are required on some in order to get at the FORTRAN string lengths.\par The exception is routines that use the <varargs.h> variable argument mechanism. User subroutines should not normally use varargs, but it is used fairly extensively inside the RTL to handle the keyword-value argument pairs. If you use <varargs.h>, follow all the standard C rules for that mechanism, and you should not use the FORSTR_PARAM, FORSTR_BLOCK or FORSTR_DEF macros. For example:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {FTN_NAME(text)(inbuf, inchr, line, outbuf, size, dn, FORSTR_PARAM)\line char *inbuf;\line int *inchr, *line;\line unsigned char outbuf[];\line int *size, *dn;\line FORSTR_DEF\line \{\line    FORSTR_BLOCK\line    char *c_string;\line    int  length,i;\line    ...\line \par {\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.1.1.4\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Argument restrictions\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {All arguments to the direct-called routine must be the size of a generic pointer. Since FORTRAN passes everything by reference anyway, all of your arguments will be pointers, so this should not cause a problem.\par {\listtext\pard\plain\s4 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.1.1.5\tab}}\pard\plain \s4\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\f4\fs28\cgrid {Arguments to FORTRAN string conversion routines\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The arguments to the FORTRAN string conversion routines all apply to the argument list of the routine that is directly called by FORTRAN, not to any intermediary routines.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b FOR_STRING:  pointer to char, input/output}{\line FOR_STRING should be the name of the argument that contains the FORTRAN string. It should be declared as type \ldblquote char *\rdblquote  in the argument list. Simply pass in the name of the argument, without any extra \\&'s or *'s or anything. The FORTRAN routine must declare the string as CHARACTER*n. String arrays (handled with the routines  }{\b sc2for_array}{\} and  }{\b sfor2c}{_array\} must be declared as single-dimension arrays of CHARACTER*n, but are still declared as \ldblquote char *\rdblquote  in the C routine.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ARGPTR:  generic pointer, input}{\line ARGPTR should be the address of the first argument, whatever it is. It does not matter what the data type of the first argument is, or if it is already a pointer to something else. Simply put an ampersand (\\&) followed by the name of the first argument in the argument list.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NARGS:  integer, input}{\line NARGS is simply the total number of arguments passed in to the routine. Do not\} count FORSTR_PARAM as one of the arguments. If you are using <varargs.h>, pass in the actual number of arguments sent to the routine.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ARGNO:  integer, input}{\line ARGNO is the number of the argument that contains the string to be converted. If the string is the first argument in the list, ARGNO would be 1. If it is the fifth argument, ARGNO would be 5.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STRNO:  integer, input}{\line STRNO is the string count for the string to be converted. It is similar to ARGNO, but counts only strings. So, if the string you are converting is the third argument, but only the second string in the argument list (because the first one is an integer), then ARGNO would be 3 but STRNO would be 2.\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Some examples may help to clarify things. The routine  }{\b sfor2c}{ is used in these examples, but the principles apply to all the string conversion routines. The calling sequence for  }{\b sfor2c}{\} is }{\b sfor2c}{(c_string, max_length, for_string, argptr, nargs, argno, strno).\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {int constargs(a, s1, s2, b, FORSTR_PARAM)\line   int *a, *b;\line   char *s1, *s2;\line   FORSTR_DEF\line \{ char cs1[11], cs2[20];\line   sfor2c(cs1, 10, s1, &a, 4, 2, 1);\line   sfor2c(cs2, 19, s2, &a, 4, 3, 2);\line \}\line \line int constargs2(s1, s2, a, s3, b, s4, FORSTR_PARAM)\line   char *s1, *s2, *s3, *s4;\line   int *a, *b;\line \{ char cs1[101], cs2[31], cs3[80], cs4[5];\line   sfor2c(cs1, 100, s1, &s1, 6, 1, 1);\line   sfor2c(cs2, 30,  s2, &s1, 6, 2, 2);\line   sfor2c(cs3, 79,  s3, &s1, 6, 4, 3);\line   sfor2c(cs4, 4,   s4, &s1, 6, 6, 4);\line \}\line \line int varargs(va_alist)\line   va_dcl\line \{ char cs[11];\line  /* nargs = number of arguments, argno=argument #, and strno=string # */\line  /* which all come from knowing what to expect in the argument list */\line   forstr = va_arg(ap, char *);\line   sfor2c(cs, 10, forstr, &va_alist, nargs, argno, strno);\line \}\par {\*\bkmkstart _Toc425047573}{\*\bkmkstart _Toc425048128}{\*\bkmkstart _Toc453201467}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.2\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {String Conversion {\*\bkmkend _Toc425047573}{\*\bkmkend _Toc425048128}API{\*\bkmkend _Toc453201467}\par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\*\bkmkstart _Toc425047574}{\*\bkmkstart _Toc425048129}{\*\bkmkstart _Toc425329732}{\*\bkmkstart Conversion}{\field{\*\fldinst { TOC \\b "Conversion" \\n}}{\fldrslt {\lang1024 7.2.1\tab sc2for\emdash C null-terminated string to an output FORTRAN string\par 7.2.2\tab sc2for_array\emdash C null-terminated array of strings to FORTRAN string array\par 7.2.3\tab sfor2c\emdash FORTRAN input string to a standard C null-terminated string\par 7.2.4\tab sfor2c_array\emdash FORTRAN string array to C null-terminated array of strings\par 7.2.5\tab sfor2len\emdash Length of a FORTRAN string\par 7.2.6\tab sfor2ptr\emdash Pointer to actual characters in FORTRAN string\par {\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.2.1\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid }}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc453201468}sc2for{\*\bkmkend _Toc425047574}{\*\bkmkend _Toc425048129}{\*\bkmkend _Toc425329732}\emdash C null-terminated string to an output FORTRAN string{\*\bkmkend _Toc453201468}\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {sc2for(c_string, max_length, for_string, argptr, nargs, argno, strno);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine converts a standard C null-terminated string to an output FORTRAN string. It is used to send strings back to a FORTRAN caller.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments}{:\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b C_STRING}{: string, input\line String to convert in standard null-terminated C format.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAX_LENGTH}{: integer, input.\line Alternate maximum length of the FORTRAN string. Normally the maximum length is obtained from the output FORTRAN string itself (the \ldblquote n\rdblquote  in the CHARACTER*n declaration. If MAX_LENGTH is passed in as 0, then this natural length is used. MAX_LENGTH is an alternate maximum string length in case one is provided as a parameter to the routine. The actual maximum FORTRAN length used is the minimum of the passed in MAX_LENGTH (if not 0) and the natural FORTRAN string length. The output string will be truncated if the FORTRAN string is not long enough. Any extra space at the end of the FORTRAN string will be padded with blanks in the standard FORTRAN style.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FOR_STRING, ARGPTR, NARGS, ARGNO, STRNO}{\line See }{\field{\*\fldinst { REF _Ref425062348 \\n }}{\fldrslt {7.1.1}}}{ }{\field{\*\fldinst { REF _Ref425062355 \\* MERGEFORMAT }}{\fldrslt {Common Features: Rules and arguments common to all string routines}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref425062385 }}{\fldrslt {\cs109\lang1024 112}}}{\cs109 )}{ above.\par {\*\bkmkstart _Toc425047575}{\*\bkmkstart _Toc425048130}{\*\bkmkstart _Toc425329733}{\*\bkmkstart _Toc453201469}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.2.2\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {sc2for_array{\*\bkmkend _Toc425047575}{\*\bkmkend _Toc425048130}{\*\bkmkend _Toc425329733}\emdash C null-terminated array of strings to FORTRAN string array{\*\bkmkend _Toc453201469}\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {sc2for_array(c_string,len,nelements,for_string,max_length,argptr,nargs, argno,strno);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine converts a standard C null-terminated array of strings into an output FORTRAN string array. The C string array must be a two-dimensional array of characters, not\} an array of pointers to strings. The FORTRAN string should be declared as a single-dimensional array of CHARACTER*n in the calling routine.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b C_STRING}{: string array, input\line String array to convert in standard null-terminated C format. It must be a two-dimensional array of char, not an array of pointers to strings. Each string should have its own null terminator.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LEN}{: integer, input\line LEN is the size of the inner dimension of the C string array. If the array is declared as \ldblquote char x[10][81];+\rdblquote  (10 strings of 80 characters each plus terminator), then LEN would be 81.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NELEMENTS}{: integer, input\line NELEMENTS is the number of strings in the array to convert.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAX_LENGTH}{:  integer, input/output\line On input, MAX_LENGTH is the alternate maximum length of each FORTRAN string. Normally the maximum length is obtained from the output FORTRAN string array itself (the \ldblquote n\rdblquote  in a CHARACTER*n declaration). If MAX_LENGTH is passed in as 0, then this natural length is used. MAX_LENGTH is an alternate maximum string length in case one is provided as a parameter to the routine. The actual maximum FORTRAN length used is the minimum of the passed in MAX_LENGTH (if not 0) and the natural FORTRAN string length. The output string will be truncated if the FORTRAN string is not long enough. Any extra space at the end of the FORTRAN string will be padded with blanks in the standard FORTRAN style. MAX_LENGTH should normally be passed in as 0, as it makes little sense to override the natural FORTRAN string length. However, it is possible, and might be useful in some unusual cases.\line On output, MAX_LENGTH returns the actual FORTRAN string length used by the routine.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FOR_STRING, ARGPTR, NARGS, ARGNO, STRNO\line }{See }{\field{\*\fldinst { REF _Ref425062348 \\n }}{\fldrslt {7.1.1}}}{ }{\field{\*\fldinst { REF _Ref425062355 \\* MERGEFORMAT }}{\fldrslt {Common Features: Rules and arguments common to all string routines}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref425062385 }}{\fldrslt {\cs109\lang1024 112}}}{\cs109 )}{ above.\par {\*\bkmkstart _Toc425047576}{\*\bkmkstart _Toc425048131}{\*\bkmkstart _Toc425329734}{\*\bkmkstart _Toc453201470}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.2.3\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {sfor2c{\*\bkmkend _Toc425047576}{\*\bkmkend _Toc425048131}{\*\bkmkend _Toc425329734}\emdash FORTRAN input string to a standard C null-terminated string{\*\bkmkend _Toc453201470}\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {sfor2c(c_string, len, for_string, argptr, nargs, argno, strno);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine converts FORTRAN input string to a standard C null-terminated string. It is used to receive string parameters from a FORTRAN caller.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid { }{\b C_STRING}{: string, output\line Buffer to hold the output C string. The string will be truncated if the buffer is not big enough. It will always be null terminated, even if it was truncated. Any trailing blanks in the FORTRAN string will be removed.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LEN}{: integer, input\line Maximum length of the output C string. This parameter defines the size of the C string buffer. It is expressed in terms of the maximum length\} of the string, which means it does not include the terminator byte. The buffer should actually be declared to be one byte larger than LEN to allow room for the null terminator. So, if the declaration is \ldblquote char buffer[80];\rdblquote , then LEN should be 79.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FOR_STRING, ARGPTR, NARGS, ARGNO, STRNO\line }{See }{\field{\*\fldinst { REF _Ref425062348 \\n }}{\fldrslt {7.1.1}}}{ }{\field{\*\fldinst { REF _Ref425062355 \\* MERGEFORMAT }}{\fldrslt {Common Features: Rules and arguments common to all string routines}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref425062385 }}{\fldrslt {\cs109\lang1024 112}}}{\cs109 )}{ above.\par {\*\bkmkstart _Toc425047577}{\*\bkmkstart _Toc425048132}{\*\bkmkstart _Toc425329735}{\*\bkmkstart _Toc453201471}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.2.4\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {sfor2c_array{\*\bkmkend _Toc425047577}{\*\bkmkend _Toc425048132}{\*\bkmkend _Toc425329735}\emdash FORTRAN string array to C null-terminated array of strings{\*\bkmkend _Toc453201471}\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {sfor2c_array(c_string, max_length, nelements, for_string, argptr, nargs, argno, strno);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine converts a FORTRAN string array to a standard C null-terminated array of strings. The returned C string array is a two-dimensional array of characters, not\} an array of pointers to strings. The FORTRAN string should be declared as a single-dimensional array of CHARACTER*n in the calling routine.\par This routine is somewhat unusual in that it actually allocates the memory for the C string for you. You pass in the address of a character pointer, not the address of a buffer for the characters. }{\b sfor2c}{_array calls malloc()\}to allocate the required memory, and returns the address of that memory in the pointer. It is your responsibility to call free()to free up that memory when you are done with it.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {C_STRING: pointer to string array, output\line C_STRING is the address of a pointer that will be filled in to point at the string array. The returned array will be a two-dimensional array of characters, not an array of pointers to strings. Each string will have its own null terminator.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {This routine actually allocates the memory for the C string for you. C_STRING is the address of a character pointer, not the address of a buffer for the characters. }{\b sfor2c}{_array\} calls sub malloc() to allocate the required memory, and returns the address of that memory in C_STRING. It is your responsibility to call free() to free up that memory when you are done with it.\par The inner dimension of the array is returned via the MAX_LENGTH parameter. Since you don't know this size at compile time, you can't access the strings like a normal two-dimensional array. It is easy enough to do your own addressing, however. For example:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f6\fs20\cgrid {char *array;\line int maxlen=0;\line ...\line sfor2c_array(&array, &maxlen, ...);\line ...\line process_string(array+(i*maxlen));       /* to get at the i'th string */\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid { MAX_LENGTH: integer, input/output\line On input, MAX_LENGTH is the alternate maximum length of each FORTRAN string. Normally the maximum length is obtained from the input FORTRAN string array itself (the \ldblquote n\rdblquote  in a CHARACTER*n declaration). If MAX_LENGTH is passed in as 0, then this natural length is used. MAX_LENGTH is an alternate maximum string length in case one is provided as a parameter to the routine. The actual maximum FORTRAN length used is the minimum of the passed in MAX_LENGTH (if not 0) and the natural FORTRAN string length. MAX_LENGTH should almost always be passed in as 0, as it makes little sense to override the natural FORTRAN string length, especially on an array. However, it is possible, and might be useful in some unusual cases.\par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {On output, MAX_LENGTH returns the size of the inner dimension of the C string array that was allocated by  }{\b sfor2c}{_array\}. To access the i'th string in the array, simply add i*maxlen to the returned array pointer.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {NELEMENTS: integer, input\line The number of strings in the array to convert.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {FOR_STRING, ARGPTR, NARGS, ARGNO, STRNO\line See }{\field{\*\fldinst { REF _Ref425062348 \\n }}{\fldrslt {7.1.1}}}{ }{\field{\*\fldinst { REF _Ref425062355 \\* MERGEFORMAT }}{\fldrslt {Common Features: Rules and arguments common to all string routines}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref425062385 }}{\fldrslt {\cs109\lang1024 112}}}{\cs109 )}{ above.\par {\*\bkmkstart _Toc425047578}{\*\bkmkstart _Toc425048133}{\*\bkmkstart _Toc425329736}{\*\bkmkstart _Toc453201472}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.2.5\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {sfor2len{\*\bkmkend _Toc425047578}{\*\bkmkend _Toc425048133}{\*\bkmkend _Toc425329736}\emdash Length of a FORTRAN string{\*\bkmkend _Toc453201472}\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {length = }{\b sfor2len}{(for_string, argptr, nargs, argno, strno);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine returns the length of a FORTRAN string. It does not get a pointer to the characters, nor does it convert them to a C string. It is most useful to get the length of a string in order to allocate a buffer for it before calling  }{\b sfor2c}{. Note that the length returned is the \ldblquote n\rdblquote  in the CHARACTER*n declaration, not the number of characters currently in the string.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {FOR_STRING, ARGPTR, NARGS, ARGNO, STRNO\line See }{\field{\*\fldinst { REF _Ref425062348 \\n }}{\fldrslt {7.1.1}}}{ }{\field{\*\fldinst { REF _Ref425062355 \\* MERGEFORMAT }}{\fldrslt {Common Features: Rules and arguments common to all string routines}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref425062385 }}{\fldrslt {\cs109\lang1024 112}}}{\cs109 )}{ above.\par {\*\bkmkstart _Toc425047579}{\*\bkmkstart _Toc425048134}{\*\bkmkstart _Toc425329737}{\*\bkmkstart _Toc453201473}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 7.2.6\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {sfor2ptr{\*\bkmkend _Toc425047579}{\*\bkmkend _Toc425048134}{\*\bkmkend _Toc425329737}\emdash Pointer to actual characters in FORTRAN string{\*\bkmkend _Toc453201473}\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {ptr = }{\b sfor2ptr}{(for_string);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine returns a pointer to the actual characters in an input FORTRAN string. It does not get the FORTRAN string length, nor does it copy the string to an output C string. It merely returns a pointer to the characters. No guarantee is made that any of the characters are valid, since that depends on the FORTRAN string length. You can be sure that there will not be a null terminator. Some machines may have one, but you may not depend on a null terminator being there.\par This routine should be used sparingly; use  }{\b sfor2c}{ for most FORTRAN string conversion. }{\b sfor2ptr}{ is mainly intended for use in scanning a variable-length argument list to find the end-of-list marker. It is used extensively inside the RTL for this purpose. It should only rarely if ever be used in application code.\par Note that only the FOR_STRING standard argument is required. This is because the FORTRAN string length is ignored. All the other parameters are used to find the length.\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b FOR_STRING}{\line See }{\field{\*\fldinst { REF _Ref425062348 \\n }}{\fldrslt {7.1.1}}}{ }{\field{\*\fldinst { REF _Ref425062355 \\* MERGEFORMAT }}{\fldrslt {Common Features: Rules and arguments common to all string routines}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref425062385 }}{\fldrslt {\cs109\lang1024 112}}}{\cs109 )}{ above.\par {\*\bkmkstart _Ref395881470}{\*\bkmkstart _Ref395881507}{\*\bkmkstart _Ref395881608}{\*\bkmkstart _Ref395932107}{\*\bkmkstart _Ref395932140}{\*\bkmkstart _Ref395949244}{\*\bkmkstart _Ref395949276}{\*\bkmkstart _Ref396017873}{\*\bkmkstart _Ref396017955}{\*\bkmkstart _Toc425047580}{\*\bkmkstart _Toc425048135}{\*\bkmkstart _Toc453201474}{\*\bkmkend Conversion}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 8.\tab}}\pard\plain \s1\li360\sb60\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Utility Routines{\*\bkmkend _Ref396017873}{\*\bkmkend _Ref396017955}{\*\bkmkend _Toc425047580}{\*\bkmkend _Toc425048135}{\*\bkmkend _Toc453201474} \par {\*\bkmkstart _Toc425047581}{\*\bkmkstart _Toc425048136}{\*\bkmkstart _Toc453201475}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.1\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Introduction{\*\bkmkend _Toc425047581}{\*\bkmkend _Toc425048136}{\*\bkmkend _Toc453201475}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This Section describes the miscellaneous utility subroutines and functions available in the VICAR run-time library. The subroutines described in this Section may not conform to all the software standards established in the rest of the manual. In particular, some routines require either FORTRAN or C formatted strings. Those requirements are indicated on a routine by routine basis. \par The routines }{\b x/zvfilpos}{, }{\b x/zvtpinfo}{, }{\b x/zvtpmode}{, and }{\b x/zvtpset}{ are used to directly manipulate 9-track tapes from within a program. The use of tapes in this way directly from a program is problematic under UNIX, so it is discouraged. While this method of access is allowed, the underlying implementation is not portable. It currently only runs on Sun-4s with one brand of tape drive. All processing should be done from disk files, with only operating system or special-purpose utilities accessing the tape (these utilities would only transfer files to/from tape, with no processing). \par {\*\bkmkstart _Ref424702506}{\*\bkmkstart _Ref424714787}{\*\bkmkstart _Toc425047582}{\*\bkmkstart _Toc425048137}{\*\bkmkstart _Toc453201476}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Utility {\*\bkmkend _Ref424702506}{\*\bkmkend _Ref424714787}{\*\bkmkend _Toc425047582}{\*\bkmkend _Toc425048137}API{\*\bkmkend _Toc453201476}\par }\pard\plain \s47\li475\sa60\nowidctlpar\tx1440\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\*\bkmkstart Heading111}{\*\bkmkstart _Toc425047583}{\*\bkmkstart _Toc425048138}{\*\bkmkstart _Toc425329738}{\field{\*\fldinst { TOC \\b "Utility" \\n}}{\fldrslt {\lang1024 8.2.1\tab abend/zabend\emdash Terminate processing abnormally\par 8.2.2\tab x/zmove\emdash Move bytes from one buffer to another\par 8.2.3\tab x/zvbands\emdash Return band usage information\par 8.2.4\tab x/zvcmdout\emdash Sends a command string to TAE to be executed\par 8.2.5\tab x/zvcommand\emdash Execute a VICAR command string\par 8.2.6\tab x/zvfilename\emdash Returns a filename suitable for use with a system open() call\par 8.2.7\tab x/zvfilpos\emdash Return the current tape position\par 8.2.8\tab x/zvmessage\emdash Log a user message\par 8.2.9\tab x/zvselpi\emdash Selects the file to use as the primary input\par }\pard \s47\li475\sa60\nowidctlpar\tqr\tldot\tx8640\adjustright }}\pard\plain \s47\li475\sa60\nowidctlpar\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\par {\*\bkmkstart Utility}{\*\bkmkstart _Toc453201477}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.1\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {abend/zabend\emdash Terminate processing abnormally{\*\bkmkend Heading111}{\*\bkmkend _Toc425047583}{\*\bkmkend _Toc425048138}{\*\bkmkend _Toc425329738}{\*\bkmkend _Toc453201477} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call abend() \line zabend() }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b abend}{ issues a message indicating that }{\b abend}{ was called, and then calls }{\b x/zvend}{ with a status of zero to indicate a program failure. Any open VICAR files are closed and write buffers flushed before termination. \par {\*\bkmkstart Heading115}{\*\bkmkstart _Toc425047587}{\*\bkmkstart _Toc425048142}{\*\bkmkstart _Toc425329739}{\*\bkmkstart Heading127}{\*\bkmkstart _Toc425047599}{\*\bkmkstart _Toc425048154}{\*\bkmkstart _Toc453201478}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.2\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zmove\emdash Move bytes from one buffer to another{\*\bkmkend Heading127}{\*\bkmkend _Toc425047599}{\*\bkmkend _Toc425048154}{\*\bkmkend _Toc453201478} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xmove(from, to, len) \line zmove(from, to, len);}{\cs18 \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Move bytes from one buffer to another. Overlapping moves are handled correctly, unlike the C routine }{\cs33\f6 memcpy()}{.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b FROM}{: pixel-array, input\line FROM is the buffer to move the bytes from (the source). It may }{\i not}{ be a FORTRAN CHARACTER*n variable. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TO}{: pixel-array, input\line TO is the buffer to move the bytes to (the destination). It may }{\i not}{ be a FORTRAN CHARACTER*n variable. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LEN}{: integer, input\line The number of bytes to move. There is no restriction on how many bytes can be moved, except  available memory. LEN is measured in }{\i bytes}{, not }{\i pixels. }{\par {\*\bkmkstart _Toc453201479}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.3\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvbands\emdash Return band usage information{\*\bkmkend Heading115}{\*\bkmkend _Toc425047587}{\*\bkmkend _Toc425048142}{\*\bkmkend _Toc425329739}{\*\bkmkend _Toc453201479} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvbands(sb, nb, nbi)\line zvbands(sb, nb, nbi);}{\cs33 \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvbands}{ is analogous to }{\b x/zvsize}{ in its usage. It returns information from the command line given in either the BANDS or the SB, NB parameters, or, if the parameters were not specified, from the input file size. \par }{\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b SB}{: output, integer\line The starting band for processing. If the BANDS parameter (BANDS = (SB, NB))was given, the first element of BANDS is used. If BANDS was not given, and the SB parameter was given, SB is used. Otherwise, the default is 1. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NB}{: output, integer\line The number of bands for processing. If the BANDS parameter was given, the second element of BANDS is used. If BANDS was not given, and the NB parameter was given, NB is used. Otherwise, the default value is the number of bands in the primary input. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NBI}{: output, integer\line The number of bands in the primary input file. \par {\*\bkmkstart Heading116}{\*\bkmkstart _Toc425047588}{\*\bkmkstart _Toc425048143}{\*\bkmkstart _Toc425329740}{\*\bkmkstart Heading128}{\*\bkmkstart _Toc425047600}{\*\bkmkstart _Toc425048155}{\*\bkmkstart _Toc453201480}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.4\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvcmdout\emdash Sends a command string to TAE to be executed{\*\bkmkend Heading128}{\*\bkmkend _Toc425047600}{\*\bkmkend _Toc425048155}{\*\bkmkend _Toc453201480} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvcmdout(command, status) \line status = zvcmdout(command);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Sends a command string to TAE to be executed, and returns output values in the interactive parblock, accessible by the }{\b x/zviparm}{ family of routines. The command must be a TAE intrinsic command, or a procedure PDF that uses only intrinsic commands, i.e. no processes, no DCL or shell. This is mainly intended for running VIDS procedures from within a program, but it may have other applications as well. \par This routine is quite similar to }{\b x/zvcommand}{. The only difference is that }{\b x/zvcmdout}{ makes any output variables accessible. This is most useful with the VIDS JGET command, which returns values to the caller in TAE variables. These variables are placed in the interactive parblock. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b COMMAND}{: string, input\line The command string to execute. It may be a TAE intrinsic command or a procedure PDF which uses intrinsic commands only ( this includes almost all VIDS PDF's). All potential outputs from the executed command will be in the form of NAME parameters. The values you wish returned should be declared as local variables in the PDF for the program (the one you're writing, not the one being called). These local variables should then be passed in the COMMAND string as values for the NAME parameters in the executed command. The variables can then be accessed from the interactive parblock via the }{\b x/zviparm }{family of routines. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: integer, output\line The returned status value. It is an argument in FORTRAN and the function return value in C. Any value other than SUCCESS indicates that the command didn't execute or the outputs didn't get returned correctly, and the returned values should not be used.\par {\*\bkmkstart _Toc453201481}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.5\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvcommand\emdash Execute a VICAR command string{\*\bkmkend Heading116}{\*\bkmkend _Toc425047588}{\*\bkmkend _Toc425048143}{\*\bkmkend _Toc425329740}{\*\bkmkend _Toc453201481} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvcommand(command,status) \line status =zvcommand(command,status) }{\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvcommand}{ passes a command string on to the VICAR supervisor (TAE) for execution. \par The command may be a VICAR intrinsic command or a procedure PDF that uses only VICAR intrinsic commands (or other procedure PDF's). Process PDF's and DCL commands are not allowed. Examples of commands that are allowed are VIDS commands and tape mounting commands (but NOT tape initialization since it uses DCL commands). \par }{\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b COMMAND}{: input, string\line The command string is passed in exactly as the user would type it on the command line. It may be either a FORTRAN or a C string. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error code may be XVCOMMAND_ERROR ( meaning an internal error with interprocess communications) or it will be a success/failure indicator (either it's equal to SUCCESS or it's not). The actual error code from the command may be returned for some types of commands, but all you can count on is a success/fail indication. \line If an error occurs, the action specified by }{\b x/zveaction}{ is performed. Even if 'S' is not specified in the}{\b  x/zveaction}{ call (which tells VICAR not to print system messages), the executed program will still print error messages from the executed command. The only message that 'S' controls is the message from VICAR saying that }{\b x/zvcommand}{ failed. \par {\*\bkmkstart Heading118}{\*\bkmkstart _Toc425047590}{\*\bkmkstart _Toc425048145}{\*\bkmkstart _Toc425329742}{\*\bkmkstart Heading129}{\*\bkmkstart _Toc425047601}{\*\bkmkstart _Toc425048156}{\*\bkmkstart _Toc453201482}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.6\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvfilename\emdash Returns a filename suitable for use with a system open() call{\*\bkmkend Heading129}{\*\bkmkend _Toc425047601}{\*\bkmkend _Toc425048156}{\*\bkmkend _Toc453201482} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvfilename(in_name, out_name, status) \line status = zvfilename(in_name,out_name, out_len);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Given a filename as input by the user, this function returns a filename suitable for use with a system }{\cs33\f6 open()}{ call or other non-VICAR file operation. For UNIX, this means that environment variables and }{\cs33\f6 ~username}{ are expanded. For VMS, this means the old-style temporary filename suffix. Z }{\i xx}{ is added. For both systems, the \ldblquote }{\cs33\f6 +}{ \ldblquote  form of temporary file is expanded. \par This function does not need to be called if the RTL is used for I/O (it is called internally by }{\b x/zvopen}{). But, any program that gets a filename from the user for use in non-RTL I/O should make use of this function. \par Because this function is only intended for use with non-VICAR I/O, only diskfile names are supported. Names specifying tape files or memory files will be treated as if they were disk files, which could provide surprising results. \ldblquote }{\cs33\f6 *}{\rdblquote  as a wildcard character is legal in this function, and is passed through unchanged (so the output has a \ldblquote }{\cs33\f6 *}{\rdblquote  in it). \par For UNIX, the expansions are as follows: \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\cs33\b\f6 $var}{:Expand environment variable \ldblquote }{\cs33\f6 var}{\rdblquote . \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 $\{var\}}{:Expand environment variable \ldblquote }{\cs33\f6 var}{\rdblquote . \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 ~user}{: Expand to home directory of user\rdblquote }{\cs33\f6 user}{\rdblquote . \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 ~}{: Expand to home directory of current user (}{\cs33\f6 $HOME}{). \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 $$}{: Insert a single }{\cs33\f6 $}{ (no environment variable). \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\cs33\b\f6 +}{: Expand to translation of }{\cs33\f6 \rdblquote $VTMP/}{\rdblquote  for temporary files. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {For VMS, the expansions are as follows: \par {\pntext\pard\plain\s57 \cs33\f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\cs33\b\f6 +}{: Expand to \ldblquote }{\cs33\f6 vtmp:}{\rdblquote  (if subdirectory present) or \ldblquote }{\cs33\f6 vtmp:[000000]}{\rdblquote (if no subdirectory) for temporary files. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b no }{\cs33\b\f6 +}{\b  and no suffix}{: Append \ldblquote . Z }{\i xx}{\rdblquote  (where }{\i xx}{ comes from }{\cs33\f6 v2$pidcode}{) for old-style temporary names. \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {Under VMS, both expansions may occur on the same name. \par The temporary filename locations (}{\cs33\f6 $VTMP}{ and }{\cs33\f6 vtmp}{) are set up in vicset2.\par }\pard\plain \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b IN_NAME:}{ string, input\line IN_NAME is the input filename that you want converted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OUT_NAME:}{ string, output\line The resultant converted string is returned in OUT_NAME. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OUT_LEN:}{ integer, input\line This argument specifies the length of the output string buffer OUT_NAME (to avoid overflow). A length of 0 means the buffer is unlimited, and it is the caller's responsibility to make sure there is no overflow. OUT_LEN is only present in the C interface. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: integer, output\line The returned status value. It is an argument in FORTRAN and the function return value in C. Any value other than SUCCESS indicates that the filename did not translate properly, and the returned value should not be used. \par {\*\bkmkstart _Toc453201483}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.7\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvfilpos\emdash Return the current tape position{\*\bkmkend Heading118}{\*\bkmkend _Toc425047590}{\*\bkmkend _Toc425048145}{\*\bkmkend _Toc425329742}{\*\bkmkend _Toc453201483} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 POSITION = x/zvfilpos(UNIT) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvfilpos}{ looks up the current file position of the given unit if it is a tape, and returns it in POSITION. If the file is not on tape, -1 is returned. \par This routine assumes that file UNIT has already been opened with }{\b x/zvopen}{. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line The unit number of the tape from }{\b x/zvunit}{. UNIT must have already been opened with a call to }{\b x/zvopen}{. \par {\*\bkmkstart Heading119}{\*\bkmkstart _Toc425047591}{\*\bkmkstart _Toc425048146}{\*\bkmkstart _Toc425329743}{\*\bkmkstart _Toc453201484}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.8\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvmessage\emdash Log a user message{\*\bkmkend Heading119}{\*\bkmkend _Toc425047591}{\*\bkmkend _Toc425048146}{\*\bkmkend _Toc425329743}{\*\bkmkend _Toc453201484} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvmessage(message, key) \line zvmessage(message, key) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvmessage}{ is the primary subroutine to be used to print messages on the user terminal or in log files. It will work whether or not the program is under the VICAR supervisor, and allows the specification of a \ldblquote key\rdblquote  for help on the message. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b MESSAGE}{: input, string\line The message to be logged. May be either a C or FORTRAN string.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b KEY}{: input, string\line KEY is an optional argument used to give a }{\i message key}{. A message key is used to look up help information for an error message. It consists of a string of the form \ldblquote }{\i facility-key}{\rdblquote , where }{\i facility}{ is the same for all error messages described in one package, and }{\i key}{ is a unique identifier for that error messages. \line For example, a program named COPY could have a series of error messages, all of which would begin with the facility name \ldblquote COPY\rdblquote , using keys such as \ldblquote COPY-NO INPUT\rdblquote  or \ldblquote COPY-END OFFILE\rdblquote . The error messages would then be stored in a file called COPYFAC. MSG in the standard TAE error message file format. The user could then use HELP-MESSAGE or the \ldblquote ?\rdblquote  command to get help on any error messages received. Details on the use of message files can be found in the }{\i TAE Application Programmer's Reference Manual}{. \line A null value (empty string) or a single blank given for KEY is equivalent to not specifying the argument. \par {\*\bkmkstart Heading134}{\*\bkmkstart _Toc425047606}{\*\bkmkstart _Toc425048161}{\*\bkmkstart _Toc453201485}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.9\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvselpi\emdash Selects the file to use as the primary input{\*\bkmkend Heading134}{\*\bkmkend _Toc425047606}{\*\bkmkend _Toc425048161}{\*\bkmkend _Toc453201485} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvselpi(instance) \line zvselpi(instance);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Selects the file to use as the primary input. The primary input is normally the first file given in the INP parameter. It is used for several purposes. If file attributes like size, type, etc. aren\rquote t specified when opening a file, defaults are taken from the primary input. When creating a new output file, history and property labels for it are copied from the primary input, in order to maintain the processing history and file attributes. \par In the rare cases where the first INP file is not appropriate for the primary input, calling }{\b x/zvselpi}{ allows you to change the file that is used as the primary input, or to disable the primary input altogether. The file selected must still be one of the files in the INP parameter. For example, you might be taking }{\i n}{ input files and creating }{\i n}{ output files after doing the same processing to each. You would want to set the primary input for each output file to the corresponding input file, in order to preserve the history labels. Or, you may want to create a file with no history labels whatsoever (except for the current task). \par This routine should be called before the }{\b x/zvopen}{ of the output file you want associated with the input. The only routines that use the primary input directly are }{\b x/zvopen}{, }{\b x/zvsize}{, and }{\b x/zvbands}{. The primary input in effect at the time each of these routines is called determines which input file is used. You may change }{\b x/zvselpi}{ after the }{\b x/zvopen}{ statement, even if you do more processing to the file. It will still use the primary input in effect at the time the file was opened. \par It is slightly more efficient to call }{\b x/zvselpi}{ before you open the primary input file for other reasons, because it avoids an extra file open. However, this should not have a big impact. \par There is no status return from this routine.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b INSTANCE}{: integer, input\line Determines which instance of the INP parameter to use as the primary input. Numbering starts at one, so you may restore the default behavior by calling }{\b x/zvselpi}{ with an INSTANCE of 1. An INSTANCE of 4 would mean the fourth item in the INP parameter, etc. \line If INSTANCE is zero, then the primary input is disabled. Provide all necessary file size and type parameters to }{\b x/zvopen}{, since there are no defaults. The history labels also will not be copied, so the current task will be the first (and only) task in the new file's label. This is the primary reason for disabling the primary input. \par {\*\bkmkstart _Toc425047607}{\*\bkmkstart _Toc425048162}{\*\bkmkstart Heading122}{\*\bkmkstart _Toc423428559}{\*\bkmkstart _Toc453201486}{\*\bkmkend Utility}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.10\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvselpiu\emdash Selects the file to use as primary input{\*\bkmkend _Toc453201486} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvselpiu(unit) \line zvselpiu(unit);\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Selects the file to use as the primary input. The primary input is normally the first file given in the INP parameter. It is used for several purposes. If file attributes like size, type, etc. aren\rquote t specified when opening a file, defaults are taken from the primary input. When creating a new output file, history and property labels for it are copied from the primary input, in order to maintain the processing history and file attributes. \par In the rare cases where the first INP file is not appropriate for the primary input, calling }{\b x/zvselpiu}{ allows you to change the file that is used as the primary input. This unit then becomes the primary input.  This allows any file, not just one associated with the INP parameter, to be the primary input.  The file associated with the unit may be open or closed,but you should not free the unit (CLOS_ACT, FREE) as long as it is the primary input. A primary input unit of 0 is valid.  To disable the primary input completely, call }{\b x/zvselpi}{(0); do not use }{\b x/zvselpiu}{() for this case.\par This routine should be called before the }{\b x/zvopen}{ of the output file you want associated with the input. The only routines that use the primary input directly are }{\b x/zvopen}{, }{\b x/zvsize}{, and }{\b x/zvbands}{. The primary input in effect at the time each of these routines is called determines which input file is used. You may change }{\b x/zvselpiu}{ after the }{\b x/zvopen}{ statement, even if you do more processing to the file. It will still use the primary input in effect at the time the file was opened. \par It is slightly more efficient to call }{\b x/zvselpiu}{ before you open the primary input file for other reasons, because it avoids an extra file open. However, this should not have a big impact. \par There is no status return from this routine.\par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer \line Unit number of file from }{\b x/zvunit}{. \par {\*\bkmkstart _Toc453201487}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 8.2.11\tab}}\pard\plain \s3\li360\sb60\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {x/zvsize\emdash Return image size values{\*\bkmkend Heading122}{\*\bkmkend _Toc423428559}{\*\bkmkend _Toc453201487} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvsize(sl, ss, nl, ns, nli, nsi)\line zvsize(sl, ss, nl, ns, nli, nsi);}{\cs33  \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvsize}{ searches the user parameters and the first input file for image size values. The values are returned as described below under \ldblquote arguments\rdblquote . If there is an input file, it must be opened before calling }{\b x/zvsize}{. \par For 3 dimensional files }{\b x/zvsize}{ must be supplimented with }{\b x/zvbands}{, which returns infomation about bands.. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b SL}{: output, integer\line SL is the starting line which should be used when reading the input. If the SIZE parameter was given, SL is taken from the first element in the size field. If SIZE was not given, but the SL parameter was, SL is taken from the SL parameter. Otherwise, SL defaults to a value of one. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SS}{: output, integer\line SS is the starting sample which should be used when reading the input. If the SIZE parameter was given, SS is taken from the second element in the size field. If SIZE was not given, but the SS parameter was, SS is taken from the SS parameter. Otherwise, SS defaults to a value of one. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NL}{: output, integer\line NL is the number of lines which should be read from the input and written to the output. If the SIZE parameter was given, NL is taken from the third element in the size field. If SIZE was not given, but the NL parameter was, NL is taken from the NL parameter. Otherwise, NL defaults to the size of the primary input. \line  a value of zero for NL is treated as if no value was given. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NS}{: output, integer\line NS is the number of samples per line which should be read from the input and written to the output. If the SIZE parameter was given, NS is taken from the fourth element in the size field. If SIZE was not given, but the NS parameter was, NS is taken from the NS parameter. Otherwise, NS defaults to the size of the primary input. A value of zero for NS is treated as if no value was given. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NLI}{: output, integer\line NLI is the number of lines in the primary input. It is obtained from the NL optional to }{\b x/zvget}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NSI}{: output, integer\line NSI is the number of samples per line in the primary input. It is obtained from the NS optional to }{\b x/zvget}{. \par {\*\bkmkstart _Toc453201488}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 9.\tab}}\pard\plain \s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Appendix A: Summary of Calling Sequences{\*\bkmkend _Toc425047607}{\*\bkmkend _Toc425048162}{\*\bkmkend _Toc453201488}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This section contains a brief synopsis of the calling sequences for all the RTL routines, in alphabetical order.\par For routines that take optional arguments (keyword-value pairs), the allowed keywords are listed. You must have an argument list terminator on every routine that lists optional arguments, even if you don't use them. Some of the keywords listed are not implemented or not useful, but they are allowed by the parameter parsing mechanism.\par The actual data type declarations for the data types below are listed. See }{\field{\*\fldinst { REF _Ref393695036 \\* MERGEFORMAT }}{\fldrslt {Table 8: FORTRAN declarations for Run-Time Library arguments}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393695036 }}{\fldrslt {\cs109\lang1024 26}}}{\cs109 )}{. Also See }{\field{\*\fldinst { REF _Ref393619550 \\* MERGEFORMAT }}{\fldrslt {Table 6: C Declarations for Run-Time Library Arguments}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref393619550 }}{\fldrslt {\cs109\lang1024 25}}}{\cs109 )}{. Keep in mind that a value listed as \ldblquote output\rdblquote  or \ldblquote in/out\rdblquote  in a C call must be passed by address, not value.\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx360\tx1980\tx3150\tx9000\adjustright \f6\fs20\cgrid {\b abend/zabend\line \line }{call abend}{\b \line }{zabend();\line \line }{\b qprint/zqprint\line }{\line call qprint(message, length)\line zqprint(message, length);\line \tab message\tab input\tab string\line \tab length\tab input\tab integer}{\b \line \line sc2for\line \line }{sc2for(c_string, max_length, for_string, argptr, nargs, argno, strno);\line \tab c_string\tab input\tab string\line \tab max_length\tab input\tab integer\line \tab for_string\tab output\tab fortran string\line \tab argptr\tab input\tab void pointer\line \tab nargs\tab input\tab integer\line \tab argno\tab input\tab integer\line \tab strno\tab input\tab integer}{\b \line \line sc2for_array\line \line }{sc2for_array(c_string, len, nelements, for_string, max_length, argptr, nargs, argno, strno);\line \tab c_string\tab input\tab string array, size nelements\line \tab len\tab input\tab integer\line \tab nelements\tab input\tab integer\line \tab for_string\tab output\tab fortran string array, size nelements\line \tab max_length\tab in/out\tab integer\line \tab argptr\tab input\tab void pointer\line \tab nargs\tab input\tab integer\line \tab argno\tab input\tab integer\line \tab strno\tab input\tab integer\line \line }{\b sfor2c\line \line }{sfor2c(c_string, len, for_string, argptr, nargs, argno, strno);\line \tab c_string\tab output\tab string\line \tab len\tab input\tab integer\line \tab for_string\tab input\tab fortran string\line \tab argptr\tab input\tab void pointer\line \tab nargs\tab input\tab integer\line \tab argno\tab input\tab integer\line \tab strno\tab input\tab integer}{\b \line \line sfor2c_array\line \line }{sfor2c_array(c_string, max_length, nelements, for_string, argptr, nargs, argno, strno);\line \tab c_string\tab output\tab pointer to string array, size nelements\line \tab max_length\tab in/out\tab integer\line \tab nelements\tab input\tab integer\line \tab for_string\tab input\tab fortran string array, size nelements\line \tab argptr\tab input\tab void pointer\line \tab nargs\tab input\tab integer\line \tab argno\tab input\tab integer\line \tab strno\tab input\tab integer}{\b \line \line sfor2len\line \line }{sfor2len(for_string, argptr, nargs, argno, strno);\line \tab for_string\tab input\tab fortran string\line \tab argptr\tab input\tab void pointer\line \tab nargs\tab input\tab integer\line \tab argno\tab input\tab integer\line \tab strno\tab input\tab integer}{\b \line \line sfor2ptr\line \line }{ptr = sfor2ptr(for_string);\line \tab for_string\tab input\tab fortran string\line \tab ptr\tab output\tab string pointer}{\b \line \line xladd/zladd\line \line }{call xladd(unit, type, key, value, status, <optionals>, ' ')\line status = zladd(unit, type, key, value, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab type\tab input\tab string\line \tab key\tab input\tab string\line \tab value\tab input\tab value array, size NELEMENT\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab ELEMENT\tab input\tab integer\line \tab ERR_ACT\tab input\tab string\line \tab ERR_MESS\tab input\tab string\line \tab FORMAT\tab input\tab string\line \tab HIST\tab input\tab string\line \tab INSTANCE\tab input\tab integer\line \tab LEVEL\tab input\tab integer\line \tab MODE\tab input\tab string\line \tab NELEMENT\tab input\tab integer\line \tab PROPERTY\tab input\tab string\line \tab ULEN\tab input\tab integer}{\b \line \line xldel/zldel\line \line }{call xldel(unit, type, key, status, <optionals>, ' ')\line status = zldel(unit, type, key, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab type\tab input\tab string\line \tab key\tab input\tab string\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab ELEMENT\tab input\tab integer\line \tab ERR_ACT\tab input\tab string\line \tab ERR_MESS\tab input\tab string\line \tab HIST\tab input\tab string\line \tab INSTANCE\tab input\tab integer\line \tab NELEMENT\tab input\tab integer\line \tab NRET\tab output\tab integer\line \tab PROPERTY\tab input\tab string}{\b \line \line xlget/zlget\line \line }{call xlget(unit, type, key, value, status, <optionals>, ' ')\line status = zlget(unit, type, key, value, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab type\tab input\tab string\line \tab key\tab input\tab string\line \tab value\tab output\tab value array, size NELEMENT\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab ELEMENT\tab input\tab integer\line \tab ERR_ACT\tab input\tab string\line \tab ERR_MESS\tab input\tab string\line \tab FORMAT\tab input\tab string\line \tab HIST\tab input\tab string\line \tab INSTANCE\tab input\tab integer\line \tab LENGTH\tab output\tab integer\line \tab LEVEL\tab output\tab integer\line \tab NELEMENT\tab input\tab integer\line \tab NRET\tab output\tab integer\line \tab PROPERTY\tab input\tab string\line \tab ULEN\tab input\tab integer}{\b \line \line xlgetlabel/zlgetlabel\line \line }{call xlgetlabel(unit, buf, bufsize, status)\line status = zlgetlabel(unit, buf, bufsize);\line \tab unit\tab input\tab integer\line \tab buf\tab output\tab string\line \tab bufsize\tab in/out\tab integer\line \tab status\tab output\tab integer}{\b \line \line xlhinfo/zlhinfo\line \line }{call xlhinfo(unit, tasks, instances, nhist, status, <optionals>, ' ')\line status = zlhinfo(unit, tasks, instances, nhist, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab tasks\tab output\tab string array, size nhist\line \tab instances\tab output\tab integer array, size nhist\line \tab nhist\tab in/out\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab ERR_ACT\tab input\tab string\line \tab ERR_MESS\tab input\tab string\line \tab NRET\tab output\tab integer\line \tab ULEN\tab input\tab integer}{\b \line \line xlinfo/zlinfo\line \line }{call xlinfo(unit,type,key,format,maxlen,nelement,status,<optionals>,' ')\line status = zlinfo(unit,type,key,format,maxlen,nelement,<optionals>, 0);\line \tab unit\tab input\tab integer\line \tab type\tab input\tab string\line \tab key\tab input\tab string\line \tab format\tab output\tab string\line \tab maxlen\tab output\tab integer\line \tab nelement\tab output\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab ERR_ACT\tab input\tab string\line \tab ERR_MESS\tab input\tab string\line \tab HIST\tab input\tab string\line \tab INSTANCE\tab input\tab integer\line \tab MOD\tab output\tab integer\line \tab PROPERTY\tab input\tab string\line \tab STRLEN\tab output\tab integer}{\b \line \line xlninfo/zlninfo\line \line }{call xlninfo(unit, key, format, maxlength, nelement, status, <optionals>, ' ')\line status = zlninfo(unit, key, format, maxlength, nelement,<optionals>, 0);\line \tab unit\tab input\tab integer\line \tab key\tab output\tab string\line \tab format\tab output\tab string\line \tab maxlength\tab output\tab integer\line \tab nelement\tab output\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab ERR_ACT\tab input\tab string\line \tab ERR_MESS\tab input\tab string\line \tab MOD\tab output\tab integer\line \tab STRLEN\tab output\tab integer}{\b \line \line xlpinfo/zlpinfo\line \line }{call xlpinfo(unit, properties, nprop, status, <optionals>, ' ')\line status = zlpinfo(unit, properties, nprop, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab properties\tab output\tab string array, size nprop\line \tab nprop\tab in/out\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab ERR_ACT\tab input\tab string\line \tab ERR_MESS\tab input\tab string\line \tab NRET\tab output\tab integer\line \tab ULEN\tab input\tab integer}{\b \line }{\tab INST_NUM\tab input\tab integer array}{\b \line \line xmove/zmove\line \line }{call xmove(from, to, len)\line zmove(from, to, len);\line \tab from\tab input\tab pixel buffer, size len (bytes)\line \tab to\tab output\tab pixel buffer, size len (bytes)\line \tab len\tab input\tab integer}{\b \line \line xvadd/zvadd\line \line }{call xvadd(unit, status, <optionals>, ' ')\line status = zvadd(unit, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab BHOST\tab input\tab string\line \tab BIN_CVT\tab input\tab string\line \tab BINTFMT\tab input\tab string\line \tab BLTYPE\tab input\tab string\line \tab BREALFMT\tab input\tab string\line \tab CLOS_ACT\tab input\tab string\line \tab COND\tab input\tab string\line \tab CONVERT\tab input\tab string\line \tab FORMAT\tab input\tab string\line \tab HOST\tab input\tab string\line \tab I_FORMAT\tab input\tab string\line \tab INTFMT\tab input\tab string\line \tab IO_ACT\tab input\tab string\line \tab IO_MESS\tab input\tab string\line \tab LAB_ACT\tab input\tab string\line \tab LAB_MESS\tab input\tab string\line \tab METHOD\tab input\tab string\line \tab OP\tab input\tab string\line \tab O_FORMAT\tab input\tab string\line \tab OPEN_ACT\tab input\tab string\line \tab OPEN_MES\tab input\tab string\line \tab REALFMT\tab input\tab string\line \tab TYPE\tab input\tab string\line \tab U_DIM\tab input\tab integer\line \tab U_FILE\tab input\tab integer\line \tab U_FORMAT\tab input\tab string\line \tab U_NB\tab input\tab integer\line \tab U_NBB\tab input\tab integer\line \tab U_NL\tab input\tab integer\line \tab U_NLB\tab input\tab integer\line \tab U_NS\tab input\tab integer\line \tab U_N1\tab input\tab integer\line \tab U_N2\tab input\tab integer\line \tab U_N3\tab input\tab integer\line \tab U_ORG\tab input\tab string\line \tab UPD_HIST\tab input\tab string}{\b \line \line xvbands/zvbands\line \line }{call xvbands(sb, nb, nbi)\line zvbands(sb, nb, nbi);\line \tab sb\tab output\tab integer\line \tab nb\tab output\tab integer\line \tab nbi\tab output\tab integer}{\b \line \line xvclose/zvclose\line \line }{call xvclose(unit, status, <optionals>, ' ')\line status = zvclose(unit, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab CLOS_ACT\tab input\tab string}{\b \line \line xvcmdout/zvcmdout\line \line }{call xvcmdout(command, status)\line status = zvcmdout(command);\line \tab command\tab input\tab string\line \tab status\tab output\tab integer}{\b \line \line xvcommand/zvcommand\line \line }{call xvcommand(command, status)\line status = zvcommand(command);\line \tab command\tab input\tab string\line \tab status\tab output\tab integer}{\b \line \line xveaction/zveaction\line \line }{status = xveaction(action, message)\line status = zveaction(action, message);\line \tab action\tab input\tab string\line \tab message\tab input\tab string\line \tab status\tab output\tab integer}{\b \line \line xvend/zvend\line \line }{call xvend(status)\line zvend(status);\line \tab status\tab input\tab integer}{\b \line \line xvfilpos/zvfilpos\line \line }{position = xvfilpos(unit)\line position = zvfilpos(unit);\line \tab unit\tab input\tab integer\line \tab position\tab output\tab integer}{\b \line \line xvget/zvget\line \line }{call xvget(unit, status, <optionals>, ' ')\line status = zvget(unit, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab BHOST\tab output\tab string\line \tab BINTFMT\tab output\tab string\line \tab BLTYPE\tab output\tab string\line \tab BREALFMT\tab output\tab string\line \tab BUFSIZ\tab output\tab integer\line \tab DIM\tab output\tab integer\line \tab FLAGS\tab output\tab integer\line \tab FORMAT\tab output\tab string\line \tab HOST\tab output\tab string\line \tab IMG_REC\tab output\tab integer\line \tab INTFMT\tab output\tab string\line \tab LBLSIZE\tab output\tab integer\line \tab NAME\tab output\tab string\line \tab NB\tab output\tab integer\line \tab NBB\tab output\tab integer\line \tab NL\tab output\tab integer\line \tab NLB\tab output\tab integer\line \tab NS\tab output\tab integer\line \tab N1\tab output\tab integer\line \tab N2\tab output\tab integer\line \tab N3\tab output\tab integer\line \tab ORG\tab output\tab string\line \tab PIX_SIZE\tab output\tab integer\line \tab REALFMT\tab output\tab string\line \tab RECSIZE\tab output\tab integer\line \tab TYPE\tab output\tab string\line \tab VARSIZE\tab output\tab integer}{\b \line }{\tab UPD_HIST\tab input\tab string}{\b \line \line xvhost/zvhost\line \line }{call xvhost(host, intfmt, realfmt, status)\line status = zvhost(host, intfmt, realfmt);\line \tab host\tab input\tab string\line \tab intfmt\tab output\tab string\line \tab realfmt\tab output\tab string\line \tab status\tab output\tab integer}{\b \line \line xvintract/zvintract\line \line }{call xvintract(subcmd, prompt)\line zvintract(subcmd, prompt);\line \tab subcmd\tab input\tab string\line \tab prompt\tab input\tab string}{\b \line \line xvip/zvip\line \line }{call xvip(name, value, count)\line status = zvip(name, value, count);\line \tab name\tab input\tab string\line \tab value\tab output\tab value array, size count\line \tab count\tab output\tab integer\line \tab status\tab output\tab integer}{\b \line \line xviparm/zviparm\line \line }{call xviparm(name, value, count, def, maxcnt)\line status = zviparm(name, value, count, def, maxcnt, length);\line \tab name\tab input\tab string\line \tab value\tab output\tab value array, size count\line \tab count\tab output\tab integer\line \tab def\tab output\tab integer\line \tab maxcnt\tab input\tab integer\line \tab length\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xviparmd/zviparmd\line \line }{call xviparmd(name, value, count, def, maxcnt)\line status = zviparmd(name, value, count, def, maxcnt, length);\line \tab name\tab input\tab string\line \tab value\tab output\tab value array, size count\line \tab count\tab output\tab integer\line \tab def\tab output\tab integer\line \tab maxcnt\tab input\tab integer\line \tab length\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvipcnt/zvipcnt\line \line }{call xvipcnt(name, count)\line status = zvipcnt(name, count);\line \tab name\tab input\tab string\line \tab count\tab output\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvipone/zvipone\line \line }{status = xvipone(name, value, instance, maxlen)\line status = zvipone(name, value, instance, maxlen);\line \tab name\tab input\tab string\line \tab value\tab output\tab value\line \tab instance\tab input\tab integer\line \tab maxlen\tab input\tab integer}{\b \line \line xvipstat/zvipstat\line \line }{call xvipstat(name, count, def, maxlen, type)\line status = zvipstat(name, count, def, maxlen, type);\line \tab name\tab input\tab string\line \tab count\tab output\tab integer\line \tab def\tab output\tab integer\line \tab maxlen\tab output\tab integer\line \tab type\tab output\tab string\line \tab status\tab output\tab integer}{\b \line \line xviptst/zviptst\line \line }{GIVEN = xviptst(key)\line GIVEN = zviptst(key);\line \tab key\tab input\tab string\line }{\b \line xvmessage/zvmessage\line \line }{call xvmessage(message, key)\line zvmessage(message, key);\line \tab message\tab input\tab string\line \tab key\tab input\tab string}{\b \line \line xvopen/zvopen\line \line }{call xvopen(unit, status, <optionals>, ' ')\line status = zvopen(unit, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab ADDRESS\tab output\tab pixel pointer\line \tab BHOST\tab input\tab string\line \tab BIN_CVT\tab input\tab string\line \tab BINTFMT\tab input\tab string\line \tab BLTYPE\tab input\tab string\line \tab BREALFMT\tab input\tab string\line \tab CLOS_ACT\tab input\tab string\line \tab COND\tab input\tab string\line \tab CONVERT\tab input\tab string\line \tab FORMAT\tab input\tab string\line \tab HOST\tab input\tab string\line \tab I_FORMAT\tab input\tab string\line \tab INTFMT\tab input\tab string\line \tab IO_ACT\tab input\tab string\line \tab IO_MESS\tab input\tab string\line \tab LAB_ACT\tab input\tab string\line \tab LAB_MESS\tab input\tab string\line \tab METHOD\tab input\tab string\line \tab OP\tab input\tab string\line \tab O_FORMAT\tab input\tab string\line \tab OPEN_ACT\tab input\tab string\line \tab OPEN_MES\tab input\tab string\line \tab REALFMT\tab input\tab string\line \tab TYPE\tab input\tab string\line \tab U_DIM\tab input\tab integer\line \tab U_FILE\tab input\tab integer\line \tab U_FORMAT\tab input\tab string\line \tab U_NB\tab input\tab integer\line \tab U_NBB\tab input\tab integer\line \tab U_NL\tab input\tab integer\line \tab U_NLB\tab input\tab integer\line \tab U_NS\tab input\tab integer\line \tab U_N1\tab input\tab integer\line \tab U_N2\tab input\tab integer\line \tab U_N3\tab input\tab integer\line \tab U_ORG\tab input\tab string}{\b \line }{\tab UPD_HIST\tab input\tab string}{\b \line \line xvp/zvp\line \line }{call xvp(name, value, count)\line status = zvp(name, value, count);\line \tab name\tab input\tab string\line \tab value\tab output\tab value array, size count\line \tab count\tab output\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvparm/zvparm\line \line }{call xvparm(name, value, count, def, maxcnt)\line status = zvparm(name, value, count, def, maxcnt, length);\line \tab name\tab input\tab string\line \tab value\tab output\tab value array, size count\line \tab count\tab output\tab integer\line \tab def\tab output\tab integer\line \tab maxcnt\tab input\tab integer\line \tab length\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvparmd/zvparmd\line \line }{call xvparmd(name, value, count, def, maxcnt)\line status = zvparmd(name, value, count, def, maxcnt, length);\line \tab name\tab input\tab string\line \tab value\tab output\tab value array, size count\line \tab count\tab output\tab integer\line \tab def\tab output\tab integer\line \tab maxcnt\tab input\tab integer\line \tab length\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvpblk/zvpblk\line \line }{call xvpblk(parblk)\line zvpblk(parblk);\line \tab parblk\tab output\tab void pointer}{\b \line \line xvpclose/zvpclose\line \line }{call xvpclose(status)\line status = zvpclose();\line \tab status\tab output\tab integer}{\b \line \line xvpcnt/zvpcnt\line \line }{call xvpcnt(name, count)\line status = zvpcnt(name, count);\line \tab name\tab input\tab string\line \tab count\tab output\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvpixsize/zvpixsize\line \line }{status = xvpixsize(pixsize, type, ihost, rhost)\line status = zvpixsize(pixsize, type, ihost, rhost);\line \tab pixsize\tab output\tab integer\line \tab type\tab input\tab string\line \tab ihost\tab input\tab string\line \tab rhost\tab input\tab string\line \tab status\tab output\tab integer}{\b \line \line xvpixsizeb/zvpixsizeb\line \line }{status = xvpixsizeb(pixsize, type, unit)\line status = zvpixsizeb(pixsize, type, unit);\line \tab pixsize\tab output\tab integer\line \tab type\tab input\tab string\line \tab unit\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvpixsizeu/zvpixsizeu\line \line }{status = xvpixsizeu(pixsize, type, unit)\line status = zvpixsizeu(pixsize, type, unit);\line \tab pixsize\tab output\tab integer\line \tab type\tab input\tab string\line \tab unit\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvpone/zvpone\line \line }{status = xvpone(name, value, instance, maxlen)\line status = zvpone(name, value, instance, maxlen);\line \tab name\tab input\tab string\line \tab value\tab output\tab value\line \tab instance\tab input\tab integer\line \tab maxlen\tab input\tab integer}{\b \line \line xvpopen/zvpopen\line \line }{call xvpopen(status, n_par, max_parm_size, filename, error_act, unit)\line status = zvpopen(filename, error_act, unit);\line \tab status\tab output\tab integer\line \tab n_par\tab input\tab integer (obsolete)\line \tab max_parm_size\tab input\tab integer (obsolete)\line \tab filename\tab input\tab string\line \tab error_act\tab input\tab string\line \tab unit\tab output\tab integer}{\b \line \line xvpout/zvpout\line \line }{call xvpout(status, name, value, format, count)\line status = zvpout(name, value, format, count, length);\line \tab status\tab output\tab integer\line \tab name\tab input\tab string\line \tab value\tab input\tab value array, size count\line \tab format\tab input\tab string\line \tab count\tab input\tab integer\line \tab length\tab input\tab integer}{\b \line \line xvpstat/zvpstat\line \line }{call xvpstat(name, count, def, maxlen, type)\line status = zvpstat(name, count, def, maxlen, type);\line \tab name\tab input\tab string\line \tab count\tab output\tab integer\line \tab def\tab output\tab integer\line \tab maxlen\tab output\tab integer\line \tab type\tab output\tab string\line \tab status\tab output\tab integer}{\b \line \line xvptst/zvptst\line \line }{GIVEN = xvptst(key)\line GIVEN = zvptst(key);\line \tab key\tab input\tab string\line }{\b \line xvread/zvread\line \line }{call xvread(unit, buffer, status, <optionals>, ' ')\line status = zvread(unit, buffer, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab buffer\tab output\tab pixel buffer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab BAND\tab input\tab integer\line \tab IO_MESS\tab input\tab string\line \tab LINE\tab input\tab integer\line \tab METHOD\tab input\tab string\line \tab NBANDS\tab input\tab integer\line \tab NLINES\tab input\tab integer\line \tab NSAMPS\tab input\tab integer\line \tab OP\tab input\tab string\line \tab OPEN_ACT\tab input\tab string\line \tab SAMP\tab input\tab integer\line \tab U_FORMAT\tab input\tab string}{\b \line \line xvselpi/zvselpi\line \line }{call xvselpi(instance)\line zvselpi(instance);\line \tab instance\tab input\tab integer}{\b \line \line xvsfile/zvsfile\line \line }{status = xvsfile(unit, file)\line status = zvsfile(unit, file);\line \tab unit\tab input\tab integer\line \tab file\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvsignal/zvsignal\line \line }{call xvsignal(unit, status, abend_flag)\line zvsignal(unit, status, abend_flag);\line \tab unit\tab input\tab integer\line \tab status\tab input\tab integer\line \tab abend_flag\tab input\tab integer}{\b \line \line xvsize/zvsize\line \line }{call xvsize(sl, ss, nl, ns, nli, nsi)\line zvsize(sl, ss, nl, ns, nli, nsi);\line \tab sl\tab output\tab integer\line \tab ss\tab output\tab integer\line \tab nl\tab output\tab integer\line \tab ns\tab output\tab integer\line \tab nli\tab output\tab integer\line \tab nsi\tab output\tab integer}{\b \line \line xvsptr/zvsptr\line \line }{call xvsptr(value, count, offsets, lengths)\line zvsptr(value, count, offsets, lengths);\line \tab value\tab input\tab string\line \tab count\tab input\tab integer\line \tab offsets\tab output\tab integer array, size count\line \tab lengths\tab output\tab integer array, size count}{\b \line \line xvtpinfo/zvtpinfo\line \line }{status = xvtpinfo(sym_name, dev_name, tfile, trec)\line status = zvtpinfo(sym_name, dev_name, tfile, trec);\line \tab sym_name\tab input\tab string\line \tab dev_name\tab output\tab string\line \tab tfile\tab output\tab integer\line \tab trec\tab output\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvtpmode/zvtpmode\line \line }{call xvtpmode(unit, istape)\line istape = zvtpmode(unit);\line \tab unit\tab input\tab integer\line \tab istape\tab output\tab integer}{\b \line \line xvtpset/zvtpset\line \line }{status = xvtpset(name, tfile, trec)\line status = zvtpset(name, tfile, trec);\line \tab name\tab input\tab string\line \tab tfile\tab input\tab integer\line \tab trec\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvtrans/zvtrans\line \line }{call xvtrans(buf, source, dest, npix)\line zvtrans(buf, source, dest, npix);\line \tab buf\tab input\tab integer array, size 12\line \tab source\tab input\tab pixel buffer, size npix\line \tab dest\tab output\tab pixel buffer, size npix\line \tab npix\tab input\tab integer}{\b \line \line xvtrans_in/zvtrans_in\line \line }{call xvtrans_in(buf, stype, dtype, sihost, srhost, status)\line status = zvtrans_in(buf, stype, dtype, sihost, srhost);\line \tab buf\tab output\tab integer array, size 12\line \tab stype\tab input\tab string\line \tab dtype\tab input\tab string\line \tab sihost\tab input\tab string\line \tab srhost\tab input\tab string\line \tab status\tab output\tab integer}{\b \line \line xvtrans_inb/zvtrans_inb\line \line }{call xvtrans_inb(buf, stype, dtype, unit, status)\line status = zvtrans_inb(buf, stype, dtype, unit);\line \tab buf\tab output\tab integer array, size 12\line \tab stype\tab input\tab string\line \tab dtype\tab input\tab string\line \tab unit\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvtrans_inu/zvtrans_inu\line \line }{call xvtrans_inu(buf, stype, dtype, unit, status)\line status = zvtrans_inu(buf, stype, dtype, unit);\line \tab buf\tab output\tab integer array, size 12\line \tab stype\tab input\tab string\line \tab dtype\tab input\tab string\line \tab unit\tab input\tab integer\line \tab status\tab output\tab integer}{\b \line \line xvtrans_out/zvtrans_out\line \line }{call xvtrans_out(buf, stype, dtype, dihost, drhost, status)\line status = zvtrans_out(buf, stype, dtype, dihost, drhost);\line \tab buf\tab output\tab integer array, size 12\line \tab stype\tab input\tab string\line \tab dtype\tab input\tab string\line \tab dihost\tab input\tab string\line \tab drhost\tab input\tab string\line \tab status\tab output\tab integer}{\b \line \line xvtrans_set/zvtrans_set\line \line }{call xvtrans_set(buf, stype, dtype, status)\line status = zvtrans_set(buf, stype, dtype);\line \tab buf\tab output\tab integer array, size 12\line \tab stype\tab input\tab string\line \tab dtype\tab input\tab string\line \tab status\tab output\tab integer}{\b \line \line xvunit/zvunit\line \line }{call xvunit(unit, name, instance, status, <optionals>, ' ')\line status = zvunit(unit, name, instance, <optionals>, 0);\line \tab unit\tab output\tab integer\line \tab name\tab input\tab string\line \tab instance\tab input\tab integer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab U_NAME\tab input\tab string}{\b \line \line xvwrit/zvwrit\line \line }{call xvwrit(unit, buffer, status, <optionals>, ' ')\line status = zvwrit(unit, buffer, <optionals>, 0);\line \tab unit\tab input\tab integer\line \tab buffer\tab input\tab pixel buffer\line \tab status\tab output\tab integer\line Optionals allowed:\line \tab BAND\tab input\tab integer\line \tab LINE\tab input\tab integer\line \tab NBANDS\tab input\tab integer\line \tab NLINES\tab input\tab integer\line \tab NSAMPS\tab input\tab integer\line \tab SAMP\tab input\tab integer\line \tab U_NL\tab input\tab integer}{\b \line \line xvzinit\line \line }{call xvzinit(lun, flag, debug)\line \tab lun\tab input\tab integer\line \tab flag\tab output\tab integer\line \tab debug\tab output\tab integer}{\b \line \line zvpinit\line \line }{zvpinit(parb);\line \tab parb\tab input\tab void pointer}{\b \line \line zv_rtl_init\line \line }{status = zv_rtl_init();\line \tab status\tab output\tab integer\par {\*\bkmkstart _Ref395971271}{\*\bkmkstart _Toc425047608}{\*\bkmkstart _Toc425048163}{\*\bkmkstart _Toc453201489}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 10.\tab}}\pard\plain \s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Appendix B: Error Messages{\*\bkmkend _Ref395881470}{\*\bkmkend _Ref395881507}{\*\bkmkend _Ref395881608}{\*\bkmkend _Ref395932107}{\*\bkmkend _Ref395932140}{\*\bkmkend _Ref395949244}{\*\bkmkend _Ref395949276}{\*\bkmkend _Ref395971271}{\*\bkmkend _Toc425047608}{\*\bkmkend _Toc425048163}{\*\bkmkend _Toc453201489} \par {\*\bkmkstart Heading145}{\*\bkmkstart _Toc425047609}{\*\bkmkstart _Toc425048164}{\*\bkmkstart _Toc453201490}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 10.1\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Error message format{\*\bkmkend Heading145}{\*\bkmkend _Toc425047609}{\*\bkmkend _Toc425048164}{\*\bkmkend _Toc453201490} \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {This Section describes the meaning of the VICAR error messages. VICAR error messages are given in the following form: \par }\pard \li360\sb120\sa120\nowidctlpar\adjustright {[VIC2-\emdash }{\i key}{] }{\i message}{ \par }\pard \li360\sb60\sa60\nowidctlpar\adjustright {where VIC2 indicates that the message was issued from the VICAR2 package, and }{\i key}{ is the specific key or identifier for the message given. The message key may be used to ask for help with the HELP-MESSAGE command in the VICAR supervisor or to look up a message in this Section. In addition, the key is stored internally by the supervisor, so that by simply typing a question mark (?) to the prompt, help on the last error message given is received. \par {\*\bkmkstart Heading146}{\*\bkmkstart _Toc425047610}{\*\bkmkstart _Toc425048165}{\*\bkmkstart _Toc453201491}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 10.2\tab}}\pard\plain \s2\li360\sb60\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Messages by key{\*\bkmkend Heading146}{\*\bkmkend _Toc425047610}{\*\bkmkend _Toc425048165}{\*\bkmkend _Toc453201491} \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {This Section lists VICAR2 error messages in alphabetical order by key. The accompanying message, the numerical value, and the symbolic name by which the error may be referenced in a program are given, followed by a detailed description of what the message means, and the action required to correct the error. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b ALROPN Symbolic Name}{: FILE_IS_ALREADY_OPEN\line [VIC2-ALROPN] Attempt to open an open file; program error\line Explanation: }{\b x/zvopen}{ has been called on a file which is already open. Program error. User action: Please notify the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADBAND Symbolic Name}{: IMPROPER_BAND_SIZE_PARAM\line [VIC2-BADBAND] Improper band size parameter; program error\line Explanation: A band size argument (BAND, NBANDS, U_NB) was provided to the indicated routine and was not in an allowable range (usually less than zero).\line User action: Check all the parameters which could have led to the bad sample size. If they are good, it is probably a program error and the cognizant programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADBINSIZ Symbolic Name}{: IMPROPER_ BINARY _SIZE_PARAM\line [VIC2-BADBINSIZ] Improper binary size parameter; program error\line Explanation: A binary size argument (U_NBB or U_NLB) was provided to the indicated routine and was not in an allowable range (usually less than zero).\line User action: Check all the parameters which could have led to the bad binary size. If they are good, it is probably a program error and the cognizant programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADDIM Symbolic Name}{: BAD_DIM_NAME\line [VIC2-BADDIM] Bad name for an image dimension (DIM1etc.). \line Explanation:\line A bad name was given for one of the dimensions in a multi-dimensional file. This error is the result of a call to }{\b x/zvopen}{ or }{\b x/zvadd}{ in which the DIM1.. DIM4 or the U_DIM1.. U_DIM4 optional arguments were given with a value which was not one of: SAMP, LINE, BAND, or TIME. \line User Action: If you specified the name for the dimension on the command line, re-specify it with one of the above names. If not, this error represents a program error, so notify the cognizant programmer. If there is a need to add a new name to the list, notify the MIPL system engineer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADELEM Symbolic Name}{: IMPROPER_ELEMENT_NUMBER\line [VIC2-BADELEM] Improper element number; program error\line Explanation: A value for ELEMENT or NELEMENTS was provided to a label routine that was not in the allowable range (usually less than zero).\line User action: Check all the parameters which could have led to the bad element number. If they are good, it is probably a program error and the cognizant programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADFILE Symbolic Name}{: IMPROPER_FILE_NUMBER\line [VIC2-BADFILE] Bad file number for tape\line Explanation: The U_FILE optional is less than zero.\line User action: this is a program error. Please consult the cognizant programmer. Programmer action: Check the value of U_FILE. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADFOR Symbolic Name}{: IMPROPER_FORMAT_STRING\line [VIC2-BADFOR] Improper FORMAT string; program error\line Explanation: The pixel format being passed to the indicated routine is not one of the valid values. This is a program error. \line User action: Please consult the cognizant programmer to verify that a valid format string is being passed. Programmer action: make sure that the FORMAT argument to the indicated routine is one of following values: BYTE, HALF, FULL, REAL, DOUB, or COMP. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADINST Symbolic Name}{: ILLEGAL_INSTANCE\line [VIC2-BADINST] Illegal instance; program error\line Explanation: In a call to }{\b x/zvunit}{, the value given to the INSTANCE argument is greater than the actual number of files given. User action: Verify that all the proper parameters have been input. If they have then this message indicates that a program error has occurred and the cognizant programmer should be consulted. Programmer action: Modify the PDF to require that the user input the appropriate number of files. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADLBL Symbolic Name}{: BAD_ INPUT_LABEL\line [VIC2-BADLBL] Bad input label; check file contents\line Explanation: An error occurredwhile parsing the input label. Either the file has no valid VICAR2 label, or the label is corrupted. User action: If the file has no label, LABEL-CREATE may be used to create one. If the file has a label but this error still occurs, then the label has probably been corrupted, which could indicate an executive error. In the latter case, consult the system programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADLBLTP Symbolic Name}{: BAD_LABEL_TYPE\line [VIC2-BADLBLTP] Bad label type; check file contents\line Explanation: A label type other than HISTORY or SYSTEM has been input to the indicated routine, or neither has been specified. User action: The validity of the label type must be checked. Please consult the cognizant programmer\line Programmer action: Verify that the call to the indicated routine contains a SYSTEM or HISTORY label, or that a valid label type was specified. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADLEN Symbolic Name}{: IMPROPER_LENGTH\line [VIC2-BADLEN] Improper length; program error\line Explanation:\line ULEN was either required for the indicated routine and not given, or it was given an invalid value. User action: The size and existence of the value given to ULEN must be checked. Please consult the cognizant programmer. \line Programmer action:\line The value of ULEN must be positive and less than the maximum string size. It is required to be given for multi-valued string items passed from C, and all string items (multi-valued or single value) passed from FORTRAN declared with a BYTE or LOGICAL*1. Strings passed from FORTRAN declared asCHARACTER do not require the ULEN optional. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADLINE Symbolic Name}{:IMPROPER_LINE_SIZE_PARAM\line [VIC2-BADLINE] Improper line size parameter; program error\line Explanation: A line size argument (LINE, NLINES, U_NL) was provided to the indicated routine and was not in an allowable range (usually less than zero). User action: Check all the parameters which could have led to the bad sample size. If they are good, it is probably a program error and the cognizant programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADLINST Symbolic Name}{:IMPROPER_LABEL_INSTANCE\line [VIC2-BADLINST] Improper label instance number; program error\line Explanation: An INSTANCE number was provided to a label routine that was not in the allowable range (usually less than zero). User action: Check all the parameters whichcould have led to the bad instance. If they are good, it is probably a program error and the cognizant programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADMETH Symbolic Name}{: IMPROPER_METHOD_STRING\line [VIC2-BADMETH] Improper METHOD string; program error\line Explanation: The METHOD optionalargument contained an invalid value for the routine indicated. This is a program error. The valid values for METHOD are RANDOM, SEQ. User action: Please consult the cognizant programmer so that the value of METHOD can be checked. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADMODESTR Symbolic Name}{:IMPROPER_MODE_STRING\line [VIC2-BADMODESTR] Improper MODE string; program error\line E xplanation: The MODE optional parameter had an invalid value associated with it in the indicated routine. This is a program error. \line User action: Please consult the cognizant programmer so that the value of MODE can be checked. \line Programmer action: The only valid values for MODE are \ldblquote ADD\rdblquote , \ldblquote INSERT\rdblquote , and \ldblquote REPLACE\rdblquote . Check that the call to }{\b x/zvopen}{ uses one of these values. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADNAM Symbolic Name}{: BAD_FILE_PARAM_NAME\line [VIC2-BADNAM] Bad file parameter name; program error\line Explanation: An error was encountered when }{\b x/zvunit}{ tried to look up a file name in the command line. This error probably indicates a mismatch between the program and the PDF file associated withit. User action: Please consult the cognizant programmer so that any disparity between the program and the PDF can be corrected. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADOPR Symbolic Name}{: IMPROPER_OPERATION\line [VIC2-BADOPR] Operation conflicts with open attributes; program error\line Explanation:Improper operation. The program tried to perform an operation on the indicated file which is forbidden in the mode in which the file has been opened. For instance, trying to writeto a file which has been opened for READ. User action: this is generally a program error. Consult the cognizant programmer for the program in question. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADOPSTR Symbolic Name}{: IMPROPER_OP_STRING\line [VIC2-BADOPSTR] Improper OP string; program error\line Explanation: The OP optional parameter had an invalid value associated with it in the indicated routine. This is a program error.  User action: Please consult the cognizant programmer so that the value of OP can be checked. Programmer action: The only valid values for OP are \ldblquote READ\rdblquote ,\rdblquote WRITE\rdblquote , and \ldblquote UPDATE\rdblquote . Check that the call to }{\b x/zvopen}{ uses one of these values. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADORG Symbolic Name}{: BAD_ORG\line [VIC2-BADORG]ORG key word (file organization) is not valid. \line Explanation:\line The file organizationkey word-ORG -passed to the indicated routine is not one of the valid values. The valid file organizations are BSQ (band sequential), BIL (Band interleaved by line), and BIP(Band interleaved by pixel). User Action: Notify the cognizant programmer of the program which failed or MIPL. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADSAMP Symbolic Name}{:IMPROPER_SAMP_SIZE_PARAM\line [VIC2-BADSAMP] Improper sample size parameter; program error\line Explanation: A sample size argument (SAMP, NSAMPS, U_NS) was provided to the indicated routine and was not in an allowable range (usually less than zero). User action: Check all the parameters which could have led to the bad sample size. If they are good, it is probably a program error and the cognizant programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADSIZ Symbolic Name}{:IMPROPER_IMAGE_SIZE_PARAM\line [VIC2-BADSIZ] Improper image size parameter; program error\line Explanation: A size argument (U_N1, U_N2, U_N3, or U_N4) was provided to the indicated routine and was not in an allowable range (usually less than zero). User action: Check all the parameters which could have led to the bad size. If they are good, it is probably a program error and the cognizant programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BADTRANS Symbolic Name}{:INVALID_FORMAT_TRANSLATION\line [VIC2-BADTRANS] Invalid format translation\line Explanation:\line The data format translation specified with U_FORMAT is not legal. Currently no translations are allowed for DOUB data formats. User action: make sure you specified the correct file. \line Programmer action: Don't allow conversions to/from DOUBle format. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BUG Symbolic Name}{: INTERNAL_ERROR\line [VIC2-BUG]Internal VICAR bug check failure \emdash Notify system programmer\line Explanation: An internal bug check in the VICAR run-time library failed, indicating a bug in the run-time library. User Action: this error should never occur, hence please notify the VICAR system programmer immediately. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b CONVERR Symbolic Name}{: CONVERSION_ERROR\line [VIC2-CONVERR] Conversion error; program error\line Explanation: The data item passed to the indicated routine is incompatible with the FORMAT parameter. For example, an integer is expected and a real is passed. User action: If the parameter is user specified check to see that the data item being passed to the routine is in the expected format. If the problem is still not obvious, consult the cognizant programmer. Programmer action: Check the value of the item passed to the the indicated routine. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DUPKEY Symbolic Name}{: DUPLICATE_KEY\line [VIC2-DUPKEY] Duplicate key; program error\line Explanation: An attempt has been made to add a label item with the label routine, }{\b x/zladd}{, for a key that already exists. A duplicate item cannot be added under the same HISTORY subset. User action: If the item is user specified a new subset must be created to accept the item. If the item is not user specified and this message is displayed consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b END OFVOL Symbolic Name}{: END_OF_VOLUME\line [VIC2-END OFVOL] End of volume (double tape mark) reached\line Explanation: The end of volume mark (double tape mark or double end of file) was hit when trying to open a file on an input tape. User action: Scan the tape to determine the actual number of files on it, and make sure that the program does not try to access a file beyond that number. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b EOF Symbolic Name}{: END_OF_FILE\line [VIC2-EOF] End of file\line Explanation: The end of file was reached. For input disk files, this error probably indicates an attempt to read beyond the number of lines in the image. Otherwise, this error indicates that the physical end of file was reached on an I/O operation. User action: this could be either a user or a programmer error. Verify that all the parameters to the program in question are good values, and if so, consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b EOLAB Symbolic Name}{: END_OF_LABEL\line [VIC2-EOLAB] End of label\line Explanation: you have reached the end of the label on an}{\b  x/zlninfo}{. This is an informational message which is used as a flag within a routine. User action: If this message is displayed consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ERRACT Symbolic Name}{: BAD_ERR_ACT_ VALUE\line [VIC2-ERRACT] Bad IO_ACT, OPEN_ACT, or ERR_ACT; program error\line Explanation: Arguments IO_ACT, OPEN_ACT, and ERR_ACT must contain the characters: 'U', 'A', or 'S', or any combination thereof. User action: The contents of the arguments must be checked. Please consult the cognizant programmer. Programmer action: Verify that the arguments IO_ACT, ERR_ACT, and OPEN_ACT contain the characters 'U', 'S', 'A', alone or in any combination. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FILETYPE Symbolic Name}{: BAD_FILE_TYPE\line [VIC2-FILETYPE] Invalid file type\line Explanation:\line The file type (the TYPE optionalto the indicated routine) was not a supported type. Currently the types supported are'IMAGE', 'PARM', and 'PARAM', and the IBIS types 'GRAPH1', 'GRAPH2', 'GRAPH3', and'TABULAR'. User action: If the file type was specified on the command line (eg, you tried to use LABEL-REPLACE to change it), then use one of the valid types. Otherwise, it may be a program error. Programmer action: Use only the valid types listed above. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FNDKEY Symbolic Name}{: CANNOT_FIND_KEY\line [VIC2-FNDKEY] Cannot find key; program error\line Explanation: The indicated routine is unable to find the specified key in the label.\line User action: If the key is user specified, check the label to verify that the label item exists. If, after checking, the problem is not obvious, consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORREQ Symbolic Name}{: FORMAT_ OPTIONAL_REQUIRED\line [VIC2-FORREQ] The FORMAT optional is required with xladd\line Explanation: The FORMAT optional cannot be defaulted.\line User action: Enter the desired FORMAT. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b HSTNTASC Symbolic Name}{: HIST_NAME_HAS_NON_ASCII_CHAR\line [VIC2-HSTNTASC] History name has non-ASCII characters;program error\line Explanation: HIST name has a non-ASCII character. The HIST optional for the label processing routines was given a name which contains a character  which is not a valid ASCII character. The HIST item (TASK name) must be a valid ASCII string, less than 8 characters long. User action: this is most likely a program error. Please consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ILLFOREQ Symbolic Name}{: ILLEGAL_FORMAT_REQUEST\line [VIC2-ILLFOREQ] Illegal format request; program error\line Explanation: Type is not STRING, INT, or REAL. User action: Consult the cognizant programmer so that the validity of the type specified can be checked. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b INSUFMEM Symbolic Name}{: INSUFFICIENT_MEMORY\line [VIC2-INSUFMEM] Insufficient memory; consult system programmer\line Explanation: Insufficient memory for operation. VICAR2 was not able to allocate sufficient memory foran internal function. User action: this error probably indicates a memory quota was exceeded. See the system manager or system programmer to determine the exact cause and perhaps increase the amount of memory available. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LBLIO Symbolic Name}{: LABEL_IO_ERROR\line [VIC2-LBLIO] Label I/O error; check file contents\line Explanation: Usually a system error or VICAR2 bug. User action: Inform VICAR2 system programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LNGACT Symbolic Name}{: ACT_STRING_TOO_LONG\line [VIC2-LNGACT] ACT string too long; program error\line Explanation: The argument CLOS_ACT is longer than the maximum number of allowed characters.\line User action: The size of, CLOS_ACT must be checked. Please consult the cognizant programmer. Programmer action: Verify that the string passed is the proper length. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LNGCOND Symbolic Name}{: COND_STRING_TOO_LONG\line [VIC2-LNGCOND] COND string too long; program error\line Explanation: COND string has exceeded maximum number of allowable characters. User action: The size of the string, COND, must be checked. Please consult the cognizant programmer. Programmer action: Check COND argument in indicated routine and verify that it is within the allowable stringlength. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LNGHST Symbolic Name}{: HISTORY_NAME_TOO_LONG\line [VIC2-LNGHST] History name too long; program error\line Explanation: The history NAME is too long. The HIST optional for the label processing routines was given a name which contains more than eight characters. The HIST item (TASK name) must be a valid ASCII string, less than 8 characters long. User action: Most likely a program error. Consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LNGMES Symbolic Name}{: ERROR_MESS_TOO_LONG\line [VIC2-LNGMES] Error message too long; program error. Not used. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LNGMESS Symbolic Name}{: ERR_MESS_TOO_LONG\line [VIC2-LNGMESS] Error message too long; program error\line Explanation: Error message has exceeded the maximum string size allowed (132 characters). User action: Consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MODINPLBL Symbolic Name}{:CAN_NOT_MODIFY_AN_ INPUT_LABEL\line [VIC2-MODINPLBL] Attempt to modify input label; program error\line Explanation: An attempt was made to modify a read only file. User action:Consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MODOPNUN Symbolic Name}{: CANNOT_MOD_OPEN_UNIT\line [VIC2-MODOPNUN] An open unit cannot be modified; call }{\b x/zvclose}{ first \line Explanation: An attempt to call the routine }{\b x/zvadd}{ was made after a unit was already open. In order to prevent the internal table from being corrupted, this operation is defined as illegal. User action: Consult the cognizant programmer. Programmer action: Prevent the calling of }{\b x/zvadd}{ after a unit has been opened. NL may be updated by using only }{\b x/zladd}{, and other fields may not be modified after a unit is opened. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MULTPARMFILE Symbolic Name}{:MULTIPLE_PARAMETER_FILES\line [VIC2-MULTPARMFILE] Multiple parameter files cannot be open at once\line Explanation: An attempt was made to open a parameter file before the previous one was closed}{\caps . o}{nly one parameter file can be open at a time. User action: this is a program error. Consult the cognizant programmer. Programmer action: Finish processing one parameter file before using another. Make sure that all parameter files are closed using }{\b x/zvpclose}{. }{\b x/zvclose}{ will not properly close a parameter file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOARRAY Symbolic Name}{: ARRAY_IO_NOT_ALLOWED\line [VIC2-NOARRAY] Array I/O not allowed to non-disk device\line Explanation: An attempt was made to open a non-disk file for array I/O. The program being used was designed only to work on disk files. User action: Use a disk file for the file on which the program failed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOBINTRAN Symbolic Name}{:NO_TRANSLATION_WITH_ BINARY \line [VIC2-NOBINTRAN] binary labels not allowed with dataformat conversions\line Explanation: binary labels may not be accessed (via'COND',' BINARY ') when data format translation is needed. User action: make sure you specified the correct file. Programmer action: Don't use 'COND',' BINARY' unless you are reading from the file in its \ldblquote natural\rdblquote  format. If  extract the labels ( binary header or binary prefix), open it once with binary access, get the labels, then close it and re-open it with a different U_FORMAT. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOEFLG Symbolic Name}{:UNABLE_TO_ACQUIRE_AN_EVENT_FLAG\line [VIC2-NOEFLG] Unable to get EF; re-try or consultsystem programmer\line Explanation: Unable to acquire an event flag. VICAR2 I/O needs event flags to control the different file units. This error generally means that the system provided event flags are all being used. \line User action: this is probably a program error, caused by having too many files open at once or by using event flags for some other purpose. Consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOFREUN Symbolic Name}{: NO_FREE_UNITS\line [VIC2-NOFREUN] No free units available\line No free units. Explanation: The maximum number of units has been reached. This error generally means that too many files are opened at once. User action: Consult the cognizant programmer for the progra m in which the error occurred and determine whether or not it is a programe rror. If not, consult the system programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOKEY Symbolic Name}{: NO_SUCH_KEY\line [VIC2-NOKEY]No such key in the indicated task\line Explanation: The indicated routine is unable to find the specified key in the label. This can be either a user or programmer error. User action: If the key is user specified, check the label to verify that the label item exists. If, after checking, the pr oblem is not obvious, consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOLAB Symbolic Name}{: FILE_HAS_NO_LABEL\line [VIC2-NOLAB] File has no label; check file contents\line Explanation: input file does not contain a valid VICAR2 label. User action: Check file to verify that a label does exists. LABEL-CREATE may be used to create a label. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOLBL Symbolic Name}{: NO_SYSTEM_LABEL\line [VIC2-NOLBL] No system label; check file contents\line Explanation: Unlabeled file. User action: Use the program LABEL to create a label for the file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOMEM Symbolic Name}{:NO_MEMORY_FOR_LABEL_PROCESS\line [VIC2-NOMEM] No memory for label process; consult system programmer\line Explanation: Memory required for label processing is dynamically allocated. There is insufficient memory for operation. User action: this is a system error which probably indicates a memory quot a was exceeded. See the system manager or system programmer to determine the exact cause and perhaps increase the amount of memory available. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NONASC Symbolic Name}{:STRING_HAS_NON_ASCII_CHARS\line [VIC2-NONASC] String has non-ASCII characters\line Explanation: A string was passed to the indicated routine which contained characters which are not valid ASCII characters. This generally indicates a program error. User action: The contents of the string should be checked. Please consult the cognizant programmer. Programmer action: Use the debugger or a print statement to determine what the indicated string contains. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NONSEQWRITSymbolic Name}{:NON_SEQUENTIAL_WRITE\line [VIC2-NONSEQWRIT] A non-sequential write was attempted on a sequential\emdash only device\line Explanation: Some devices, such as tapes, only allow sequential access on writes. The program attempted to either back up and re-write a recordor write only part of a record to a file on a sequential device.  User action: If the program requires a file, use a disk or memory file. If the problem is not obvious consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOSCHTSK Symbolic Name}{: NO_SUCH_TASK\line [VIC2-NOSCHTSK] No such task in label\line Explanation: The requested task was not in the history label of the image file. This could be either a program or user error. User action: Use \ldblquote LABEL-LIST 'TASK\rdblquote  on the image file to determine the tasks contained in the label. If a task name is being given on the command line, check the detailed help for the program being used to verify that the correct syntax is being used. If the problem is still not evident, consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOSCHUN Symbolic Name}{: NO_SUCH_UNIT\line [VIC2-NOSCHUN] No such unit; probable error in unit number\line Explanation: An action was requested on a nonexistent unit. This error generally indicates that the program failed tocall }{\b x/zvunit}{ before using a unit number, or that the variable which contains the unit number has been inadvertantly written over. User action: Verify that the unit number being used is valid. If this is not the problem then consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOT ASK Symbolic Name}{: NO_TASKS_IN_LABEL\line [VIC2-NOT ASK] No tasks in label;check file contents or create new label\line Explanation:The history label of the indicated file does not contain any history subsets, denoted bythe TASK key word. This situation is usually caused by the user deleting the history label. User action: Use the program LABEL or the DCL DUMP facility to examine the label of the image file in question. If the label contains any TASK key words, there is probably an executive bug, so consult the system programmer. If not, and a history label is desired, use LABEL-REMOVE to remove the system label, and LABEL-CREATE to create a new one. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOT AVAIL Symbolic Name}{: NOT_IMPLEMENTED\line [VIC2-NOT AVAIL] Function is not yet implemented; Program error. \line Explanation: The indicated routine was called with an optional argument which although listed in the programmer's reference manual has not yet been implemented. User Action: this indicates a program error, so consult the cognizant programmer or inform MIPL of the bug. Programmer Action: Find another way to accomplish the same function if possible. If the function is not indicated as being unimplemented in the VICAR RTL programmer reference manual, inform MIPL of the problem. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOTERM Symbolic Name}{: NO_IO_TO_TERMINAL\line [VIC2-NOTERM] Terminal not allowed for file name, use another name\line Explanation: Terminal not allowed for I/O operation. The file name given to a program points to the user's terminal (for example the logical name TT). Data can not be written to the terminal. User action: Use another file name. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOTEXTEND Symbolic Name}{:CANNOT_EXTEND_ARRAY_FILE\line [VIC2-NOTEXTEND] Cannot extend array file, consult cognizant programmer\line Explanation: An attempt was made by the executive to extend an array file. Array files currently may not be extended. User action: this is an executive error and the system programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOTEXTMEM Symbolic Name}{:CANNOT_EXTEND_MEMORY_FILE\line [VIC2-NOTEXTMEM] Cannot extend memory file, consult cognizant programmer\line Explanation: An attempt was made by the executive to extend a memory file. Memory files currently may not be extended. User action: this is an executive error and the system programmer should be consulted. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOTMOUNTED Symbolic Name}{: DEVICE_NOT_MOUNTED\line [VIC2-NOTMOUNTED] A file open was attempted on a tape device that is not mounted\line Explanation: Magnetic tape devices must be mounted prior to use with the MOUNT command. \line User action: Mount the tape with the MOUNT command, and try opening the file again. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOTMULT Symbolic Name}{: BUF_NOT_MULT_OF_REC\line [VIC2-NOTMULT] Tape blocksize is not an integral number of records\line Explanation: For a tape which is being blocked, the block size for the tape (usually given by BLOCKINGin the mount command) is not an integral number of records. This case is not allowed because it makes reading the tape difficult and puts da ta in a non-standard format. Asecond possibility is that the record size is greater than 65,534 bytes. If this is thecase,  default the block size on the mount, and  not use the NOBLOCK option in the }{\b x/zvopen}{ call, or you will get this error. User action: Verify that block size you gave on the MOUNT command is a multiple number of records. The record size for a band-sequential (BSQ) or band-interleaved by line (BIL) image is NS *(bytes per pixel), and for a band interleaved by pixel (BIP) image is NB * (bytes per pixel). If your record size is greater than 65,534 bytes, then do not specify the blocksize on the MOUNT command, and do not use the NOBLOCK option from }{\b x/zvopen}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOTOPN Symbolic Name}{: FILE_NOT_OPEN\line [VIC2-NOTOPN] File not open; program error\line Explanation: The indicated routine triedto operate on an unopened file. User action: this indicates a program error. See the cognizant programmer. Programmer action: make sure that x/zvopen is called prior to the indicated operation. If so, make sure that the program checks the status of the open. The status checking can be achieved automatically with the OPEN_ACT option in }{\b x/zvopen}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NOTPARMFILE Symbolic Name}{: NOT_PARAMETER_FILE\line [VIC2-NOTPARMFILE] File specified in PARMS is not a parameter file\line Explanation: The file given with PARMS must be a parameter file created by another program with}{\b  x/zvpopen}{, }{\b x/zvpout}{, etc. and not an image file. \line User action: Check that the filename you gave is correct. If it is, then consult the cognizant programmer for the program that created the file.  Programmer action: Parameter files must be created using }{\b x/zvpopen}{, }{\b x/zvpout}{, and}{\b  x/zvpclose}{. Normal image files cannot be used as parameter files. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NULLREQ Symbolic Name}{: NULL_REQUEST\line [VIC2-NULLREQ] Null request; program error\line Explanation: The NHIST argument passed to the routine }{\b x/zlhinfo}{ is either zero or negative. No information is being requested. User action: The value of the argument passed to the indicated routine must be checked. Please consult the cognizant programmer. Programmer action: Check the argument NHIST being passed to the routine }{\b x/zlhinfo}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ODDOPT Symbolic Name}{: ODD_NUMBER_OF_ OPTIONALS\line [VIC2-ODDOPT] Unpaired optionals; program error\line Explanation: the number of optional arguments to the indicated routine is odd. Since the optional arguments are given in pairsas KEY WORD, VALUE, an odd number is not allowed. User action: Please consult the cognizant programmer to check that the calling sequence is valid. Programmer action: Check the indicated routine call and verify that the calling sequence is legitimate. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OPNINP Symbolic Name}{:UNABLE_TO_OPEN_PRIMARY_ INPUT\line [VIC2-OPNINP] Unable to open primary input; check filespecification\line Explanation: In the course of opening a file other that the primary input, an attempt was made to open the primary input to get label/control information which failed. User action: Check the file specification of the primary input. Also, if it is on tape, make sure that it is not on the same tape as the output file which is being processed. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ORGMSMTCH Symbolic Name}{: ORG_MISMATCH\line [VIC2-ORGMSMTCH] File organization is not that required by this program\line Explanation: The program being used requires a specific file organization (BSQ, BIL, or BIP), and the image file in question is not in that organization. User Action: Check the documentation of the program in question to find out what organization the file should be in, and convert the file to the proper organization. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b OUTLBL Symbolic Name}{:UNABLE_TO_CREATE_OUTPUT_LABEL\line [VIC2-OUTLBL] Unable to create output label; consult system programmer\line Explanation: An error occurred while trying to create the system label for the output file indicated. User action: Consult the system programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b PARBLKERR Symbolic Name}{: PARBLK_ERROR\line [VIC2-PARBLKERR] Internal error in GET_PARM\line Explanation: An invalid type was found in a variable in the parblk passed from TAE. \line User action: Notify the VICAR system programmer. \line Programmer action: The VARIABLE structure for the parameter requested in a call to GET_PARM had an invalid type. It was not V_INTEGER, V_REAL, or V_STRING. Check the parblk passed from TAE for vailidity. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b PARNOTFND Symbolic Name}{: PARAM_NOT_FOUND\line [VIC2-PARNOTFND] A program parameter was not found in the PDF\line Explanation: A call to }{\b x/zvparm}{ or a related routine requested a parameter that is not in the PDF. \line User action: this is a program error. Consult the cognizant programmer.  Programmer action: A parameter in an }{\b x/zvparm}{ call (or another parameter routine such as }{\b x/zvp}{) was not found in the par block passed to the program from TAE. Check both the }{\b x/zvparm}{ call and the PDF to make sure the parameter exists in both places and that the spellings match. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b QUALNOTFND Symbolic Name}{: QUAL_NOT_FOUND\line [VIC2-QUALNOTFND] A parameter qualifier was not found in the PDF\line Explanation: A call to }{\b x/zvparm}{ or a related routine requested a parameter qualifier that is not in the PDF. User action: this is a program error. Consult the cognizant programmer. \line Programmer action: A parameter qualifier in an }{\b x/zvparm}{ call (or another parameter routine such as }{\b x/zvp}{) was not found in the par blockpassed to the program from TAE. Check both the }{\b x/zvparm}{ call and the PDF to make sure the qualifier exists in both places and that the spellings match. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b RECPARFAIL Symbolic Name}{: }{\b x/zvrecpar}{_FAIL\line [VIC2-RECPARFAIL] }{\b x/zvrecpar}{ could not retrieve thepar block from TAE\line Explanation:}{\b  x/zvrecpar}{ was unable to get thepar block from TAE that contains the RECVAR parameters. User action: this is most likely a program error. Make sure your inputs to the program were correct, then notify the cognizant programmer. Programmer action: Check that you executed a RECVAR statement before calling }{\b x/zvrecpar}{. If you did, it is most likely a communication problem between TAE and the application. Check your quotas (especially BYTLIM) and if they are ok, then consult the VICAR system programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SECDEL Symbolic Name}{: CANNOT_DELETE_SECTION \line [VIC2-SECDEL] Unable to free array file, consult system programmer\line Explanation: The area of memory allocated for an array file, called a mapped Section, cannot be deleted.  User action: this is an executive error. Consult the cognizant programmer for the VICAR executive. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SIZREQ Symbolic Name}{: IMAGE_SIZE_REQUIRED\line [VIC2-SIZREQ] Image size required ; re-enter command\line Explanation: }{\b x/zvopen}{ was asked to process a file with incomplete information, such as creating an output filewhere no input file is present and no size information was supplied by the user. User action: Use size field to work around the problem, and notify the cognizant programmer of the failure of the program to either calculate the size or require its input. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STOROPT Symbolic Name}{:UNABLE_TO_STORE_ OPTIONAL\line [VIC2-STOROPT] Unable to store optional; consult system programmer\line Explanation: An internal error occurred, preventing the storage of an optional argument to the routine indicated. User action: this error probably indicates an internal error. Please consult the system programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STRTELEM Symbolic Name}{: BAD_STARTING_ELEMENT\line [VIC2-STRTELEM] Bad starting element; program error\line Explanation: Cannot delete a multi-valued element starting out of range. User action: Check to see if the parameter could have tried to delete a label item. If the problem is still not obvious, consult the cognizant programmer. Programmer action: Verify that the proper values are being passed to the routine }{\b x/zldel}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STRTREC Symbolic Name}{: START_REC_ERROR\line [VIC2-STRTREC] Bad starting record for read or write operation; program error. \line Explanation: The starting record for a read or write operation, given by the LINE, BAND, or SAMP optional arguments, is only partially specified. This conditi on a rises whenan image file has a third dimension which is greater than one unit in size (for example, a band-sequential image with more than one band), and the starting value in either thesecond or third dimension was defaulted (for example, you have a band-sequential image and you specify BAND but not LINE). The error condition was raised because the record being requested is ambiguous. User Action: this is a program error. Notify the cognizant programmer. Programmer Action: Either completely specify the record in the call to }{\b x/zvread}{ or }{\b x/zvwrit}{(for band-sequential images, giveboth LINE and BAND), or completely default it (give neither). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TAPMETH Symbolic Name}{: ILLEGAL_TAPE_METHOD\line [VIC2-TAPMETH] Tape cannot be opened for random access. \line Explanation: An attempt has been made to open a tape file for random access. User action: If the program requires a file, use a disk or memory file. If the problem is not obvious consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TAPOPR Symbolic Name}{: ILLEGAL_TAPE_OPERATION\line [VIC2-TAPOPR] Tape cannot be opened for update. \line Explanation: An attempt has been made to open a tape file for update. User action: If the program requires a file, use a disk ormemory file. If the problem is not obvious consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TAPPOS Symbolic Name}{: TAPE_POSITIONING_ERROR\line [VIC2-TAPPOS] Tape positioning error; check drive status\line Explanation: Bad device status. Failed to position tape. User action: Check to see that the tape drive isfunctioning properly. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b TOOLATE Symbolic Name}{: TOO_LATE\line [VIC2-TOOLATE] Attempt to modify tape label after write; program error\line Explanation: Occurs when label processing to a tape file happens after first tape I/O. User action: Program may require file to be on disk. Write desired file to disk. If the problem is still not obvious consult the cognizant programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b UNDEFOPT Symbolic Name}{: UNDEFINED_ OPTIONAL\line [VIC2-UNDEFOPT] Undefined optional argument; program error\line Undefined optional. Explanation: An optional argument given to a VICAR2 routine is not recognized as a valid optional argument. User action: this error is usually a program error and the cognizant programmer should be notified. Programmer action: Check the appropriate document to determine what optional parameters are allowed for the subroutine call in question, ornotify the system programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VARREC Symbolic Name}{: VARREC_ERROR\line [VIC2-VARREC] COND=VARREC must have NOLABELS, NOBLOCK and tape\line Explanation: If the vARREC option is given to COND, NOLABELS, NOBLOCK, and a tape file must be specified as well. User action: this is a program error. Please consult the cognizant program mer. Programmer action: If VARREC is specified, verify that NOLABELS, NOBLOCK, and a tape file is also specified. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b WAITFL Symbolic Name}{: IO_WAIT_FAIL\line [VIC2-WAITFL] I/O wait fail; consult system programmer\line Explanation: I/O wait fail. A wait for asynchronous I/O returned a bad status.  User action: this is an executive error and the system programmer should be notified. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b x/zvcmderr Symbolic Name}{: }{\b x/zvcommand}{_ERROR\line [VIC2-XVCMDERR] Internal error in }{\b x/zvcommand}{\line Explanation: An internal error occurred in }{\b x/zvcommand}{ having to do withmessage-passing to the TAE host. Either the PARBLK could not be built, or it could not besent or received.  User action: Notify the VICAR system programmer. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b x/zvcmdfail SymbolicName}{: }{\b x/zvcommand}{_FAIL\line [VIC2-XVCMDFAIL] The command submitted via }{\b x/zvcommand}{ had an error\line Explanation: The command submitted with a call to}{\b  x/zvcommand}{ returned an error status. \line User action: this is most likely a program error. Make sure your inputs to the program were correct, then notify the cognizant programmer.  Programmer action:\line Check the command submitted with}{\b  x/zvcommand}{\caps . o}{nly intrinsic commands and procedures using intrinsic commands may be used with }{\b x/zvcommand}{, i.e. no processes or DCL commands. The failure may be a syntax error, an error in the parameters, or an execution error. The commandshould have printed an error message; use this to find the problem. \par {\*\bkmkstart _Toc425047611}{\*\bkmkstart _Toc425048166}{\*\bkmkstart _Toc453201492}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 11.\tab}}\pard\plain \s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Appendix C: Deprecated and Obsolete Subroutines{\*\bkmkend _Toc453201492}\par }\pard\plain \s46\li245\sa60\nowidctlpar\tx960\tqr\tldot\tx8640\adjustright \f4\fs20\cgrid {\*\bkmkstart Heading76}{\*\bkmkstart _Toc425047535}{\*\bkmkstart _Toc425048090}{\*\bkmkstart _Toc425329703}{\field{\*\fldinst { TOC \\b "Obsolete" \\n}}{\fldrslt {\lang1024 11.1\tab qprint/zqprint\emdash (Obsolete) Print a message to the terminal\par 11.2\tab vic1lab\emdash (Obsolete) Return IBM VICAR72 byte labels in a buffer x/zvpblk\emdash Return the address of the parameter block. FOR SPECIAL APPLICATIONS ONLY.\par 11.3\tab x/zlgetlabel\emdash (Obsolete) Read labels into local memory\par 11.4\tab x/zvend\emdash (Do Not Use) Terminate processing\par 11.5\tab x/zvpclose\emdash Close parameter data set NOT RECOMMENDED\par 11.6\tab x/zvpopen\emdash Open a parameter data set for output. NOT RECOMMENDED\par 11.7\tab x/zvpout\emdash Write parameter to parameter file. NOT RECOMMENDED.\par 11.8\tab x/zvsfile\emdash Skip files on a tape. USE x/zvadd INSTEAD.\par 11.9\tab x/zvsptr\emdash String parameter processing subroutine.\par }\pard \s46\li245\sa60\nowidctlpar\tx1200\tqr\tldot\tx8640\adjustright {\lang1024 11.10\tab x/zvtpinfo\emdash Return tape drive information\par 11.11\tab x/zvtpmode\emdash Indicate whether an image file is on tape\par 11.12\tab x/zvtpset\emdash Set tape drive position globals\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid }}\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The following twelve subroutines are listed only for reference. They should not be used in new programs.\par The PARMS files created by }{\b x\\zvpopen}{, }{\b x\\zvpout}{, and }{\b x\\zvpclose}{ should be avoided if possible. PARMS files are used to communicate parameters between programs (the receiver has a PARMS parameter to receive the file). They work and are portable, but the internal implementation is necessarily non-standard. Other communication methods, such as TCL variables or IBIS interface files, are recommended instead.\par {\*\bkmkstart Heading114}{\*\bkmkstart _Toc425047586}{\*\bkmkstart _Toc425048141}{\*\bkmkstart Heading113}{\*\bkmkstart _Toc425047585}{\*\bkmkstart _Toc425048140}{\*\bkmkstart Obsolete}{\*\bkmkstart _Toc453201493}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.1\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {qprint/zqprint\emdash (Obsolete) Print a message to the terminal{\*\bkmkend Heading113}{\*\bkmkend _Toc425047585}{\*\bkmkend _Toc425048140}{\*\bkmkend _Toc453201493} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call qprint(message, nbytes) \line zqprint(message, nbytes) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Obsolete. Use }{\b x/zvmessage}{. }{\b qprint/zqprint}{ will print a message to the standard output, with some carriage control. If the program is run interactively, then the output will appear on the user terminal, and any session logs which are active. Otherwise, it will appear in the job log. \par For new VICAR software, }{\b x/zvmessage}{ is to be preferred to }{\b qprint/zqprint}{ because it uses a standard message format, allowing the user to build help for error messages, and it works both with and without the VICAR supervisor. QPRINT will function only within the VICAR supervisor. \par }{\b qprint/zqprint}{ uses the first character in the MESSAGE buffer for FORTRAN-style carriage control. Read the description of the MESSAGE argument carefully to understand how this first character is used. \par }{\b qprint/zqprint}{ calls the subroutine PRINT with editing turned on, so that non-printable characters are replaced with the character \ldblquote |\rdblquote . \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b MESSAGE}{: input, string, maximum length 132\line MESSAGE contains the message to be given to the user. It may be passed by descriptor ( FORTRAN character type) or reference (C char array). If the string is passed by descriptor or is a NULL terminated C-type string, the NBYTES argument is optional. \line The first character in MESSAGE is used to perform a limited FORTRAN style carriage control, controlling output as follows. If the leading character is a \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {0, then a blank line is generated before the message is printed. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {1, then a form-feed is generated if the job is not interactive, and a blank line is inserted if the job is interactive. \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {blank, then normal output starts on the next line. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {If the leading character is one of the three above, then after the carriage control is performed, printing starts with the second character of the buffer. Otherwise, printing starts with the first character of the buffer. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NBYTES}{: input, integer\line NBYTES is the number of bytes to be printed. If MESSAGE is of type CHARACTER, then the smaller of the NBYTES and the declared length of the string is used. Likewise, if a NULL ( binary 0) character is encountered before NBYTES characters are printed, printing terminates at the NULL. \line If the string is not NULL terminated or a FORTRAN CHARACTER type, then NBYTES is required. \par {\*\bkmkstart _Toc453201494}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.2\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {vic1lab\emdash (Obsolete) Return IBM VICAR72 byte labels in a{\*\bkmkend _Toc453201494} {\*\bkmkstart _Toc453201495}buffer{\*\bkmkend Heading114}{\*\bkmkend _Toc425047586}{\*\bkmkend _Toc425048141} x/zvpblk\emdash Return the address of the parameter block. FOR SPECIAL APPLICATIONS ONLY.{\*\bkmkend _Toc453201495} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvpblk(parb) \line status = zvpblk(parb) }{\par }\pard\plain \li360\sb60\sa60\keepn\nowidctlpar\adjustright \f4\fs20\cgrid {\b Not for general use. }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\keepn\nowidctlpar\adjustright \f4\fs20\cgrid {The routine }{\b xvpblk}{ is not portable and should not be used. It has been moved to the P2 library. It is retained only for backwards compatibility. The reason it is not portable is the same as the reason array I/O is not portable \emdash the lack of pointers in FORTRAN. The C routine, }{\b zvpblk, }{is portable and can be used. It could be used in a FORTRAN program in a manner similar to that used for array I/O.\par }{\b x/zvpblk}{ is not needed by most VICAR applications. It is used in the MAIN portion of the application program to obtain the address of the parameter block containing all of the parameters received from the supervisor portion of the executive. The parameter block is a special structure, and should never be looked at directly by the application. Use }{\b x/zvparm}{ to fetch values out of the parameter block. \par }\pard\plain \li360\sb60\sa60\keepn\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b PARB}{: output, pointer to integer\line The address of the parameter block. \par {\*\bkmkstart _Toc453201496}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.3\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zlgetlabel\emdash (Obsolete) Read labels into local memory{\*\bkmkend Heading76}{\*\bkmkend _Toc425047535}{\*\bkmkend _Toc425048090}{\*\bkmkend _Toc425329703}{\*\bkmkend _Toc453201496} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xlgetlabel (unit,buf,bufsize,status) \line status = zvlgetlabel (unit,buf,bufsize,status) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Replace with explicit calls to the other label routines to retrieve only the labels of interest. Reading the entire label buffer and searching through it for a key word (the common usage of }{\b xlgetlabel}{) is prone to error as the given key word might exist as part of some other, unrelated label. It is permissible (if the label contents are set up this way) to read a set of labels into a buffer and search that buffer, but do not use }{\b xlgetlabel}{ for this. \par }{\b x/zlgetlabel}{ returns the entire VICAR label in a single buffer as it exists in the file, except that the LBLSIZE key word for the part of the label which exists at the end of the file (if the label is in two parts) is not written into the buffer. \par The BUFSIZE argument puts a ceiling on the number of bytes returned. That is, the actual number of bytes written into the buffer is the smaller of the entire label size and BUFSIZE. If BUFSIZE is zero on input, then nothing is copied into the buffer, but the en tire label size will be return ed in BUFSIZE (instead of 0). \par The user can thus use a BUFSIZE of zero to find out how much space is needed before calling to get the actual label. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line Unit of associated file. A valid VICAR unit number (returned from }{\b x/zvunit}{) of an open file. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BUF}{: output, byte array\line Buffer to contain labels. The buffer in which the VICAR label is to be returned. Should be large enough to hold the entire label, although BUFSIZE may be used to inhibit too large a transfer. Type HELP ARGUMENTS BUFSIZE for further information. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b BUFSIZ}{: input/output, integer\line The size of the internal buffer being used for the I/O operations. If the file is a tape, BUFSIZ will be equivalent to the block size of the tape in bytes. \line On input, BUFSIZE specifies the maximum number of bytes to be returned in the buffer. On output, it gives the actual number of bytes returned. \line If BUFSIZE is zero on input, then nothing is copied into BUFFER, and the total size of the label is returned (instead of zero). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b STATUS}{: output, integer\line Error status code. A value of one indicates success. The error codes are listed in }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ }{\cs109 (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395932140 }}{\fldrslt {\cs109\lang1024 118}}}{\cs109 )}{. \par {\*\bkmkstart Heading95}{\*\bkmkstart _Toc425047551}{\*\bkmkstart _Toc425048106}{\*\bkmkstart _Toc425329716}{\*\bkmkstart Heading93}{\*\bkmkstart _Toc425047549}{\*\bkmkstart _Toc425048104}{\*\bkmkstart _Toc425329714}{\*\bkmkstart Heading91}{\*\bkmkstart _Toc425047547}{\*\bkmkstart _Toc425048102}{\*\bkmkstart _Toc425329712}{\*\bkmkstart Heading117}{\*\bkmkstart _Toc425047589}{\*\bkmkstart _Toc425048144}{\*\bkmkstart _Toc425329741}{\*\bkmkstart _Toc453201497}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.4\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvend\emdash (Do Not Use) Terminate processing{\*\bkmkend Heading117}{\*\bkmkend _Toc425047589}{\*\bkmkend _Toc425048144}{\*\bkmkend _Toc425329741}{\*\bkmkend _Toc453201497} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvend(status) \line zvend(status) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Use}{\b  abend/zabend }{instead. }{\b x/zvend}{ is used to terminate a program. It may be called from any location in the program, making it possible to terminate processing from subroutines, similar to the FORTRAN STOP statement. \par Use of }{\b x/zvend}{ should normally be avoided, for the following reasons: \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {When processing terminates because of an unrecoverable error, }{\b abend/zabend}{ should be used, because }{\b abend/zabend}{ has certain checks which }{\b x/zvend}{ does not supply, and }{\b abend/zabend}{ prints out a standard message which is familiar to the users. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {When terminating processing normally, it is a better practice to return control systematically back to the main portion of the program (in our case to subroutine MAIN44) in order to make the software more easily maintainable. \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {A FORTRAN \ldblquote STOP\rdblquote  statement or a C \rdblquote exit\rdblquote  call should never be used in a VICAR program. \par }\pard \li360\sb60\sa60\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b STATUS}{: input, integer\line The status with which processing should be terminated}{\caps . o}{nly two values are allowed: a status of 1 means successful completion, while a status of 0 means abnormal termination. The status is passed back up to the supervisor portion of the executive where it may be entered into logs, etc. \par {\*\bkmkstart _Toc453201498}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.5\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvpclose\emdash Close parameter data set{\*\bkmkend Heading91}{\*\bkmkend _Toc425047547}{\*\bkmkend _Toc425048102}{\*\bkmkend _Toc425329712} NOT RECOMMENDED{\*\bkmkend _Toc453201498}\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvpclose(status) \line status =zvpclose() \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvpclose}{ gets the unit number of the parameter data set which is currently open and closes it with a call to }{\b x/zvclose}{. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b STATUS}{: output, integer\line VICAR status indicator. See }{\field{\*\fldinst { REF _Ref395971271 \\n }}{\fldrslt {10}}}{ }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{\cs109  (page }{\field{\*\fldinst {\cs109  PAGEREF _Ref395971271 }}{\fldrslt {\cs109\lang1024 140}}}{\cs109 )}{ for values. \par {\*\bkmkstart _Toc453201499}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.6\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvpopen\emdash Open a parameter data set for output. NOT RECOMMENDED{\*\bkmkend Heading93}{\*\bkmkend _Toc425047549}{\*\bkmkend _Toc425048104}{\*\bkmkend _Toc425329714}{\*\bkmkend _Toc453201499} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvpopen( status, npar, max_len, filenam,error_act, unit ) \line status = zvpopen( npar, max_len, filenam, error_act,unit ) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvpopen}{ opens a new parameter data set for output. The file created is a labeled VICAR file of type PARM, with fixed length 512 byte records. \par }{\b x/zvpopen}{ uses }{\b x/zvopen}{ to open the file. The file unit number is maintained internally for reference by }{\b x/zvpout}{ and }{\b x/zvpclose}{\caps . o}{nly one parameter data set may be opened for writing at a time. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b STATUS}{: output, integer\line VICAR return status. Possible values are listed in }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ (page }{\field{\*\fldinst { PAGEREF _Ref395971271 }}{\fldrslt {\lang1024 140}}}{). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NPAR}{: input, integer\line  this parameter is ignored, and is kept only to maintain compatibility with old programs. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b MAX_LEN:}{ input, integer\line  this parameter is ignored, and is kept only to maintain compatibility with old programs. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FILENAM}{: input, string\line The name of the parameter file to be opened. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b ERROR_ACT:}{ input, string\line The action to be taken if an error occurs either in the opening of the file or in a subsequent call to }{\b x/zvpout}{ or }{\b x/zvpclose}{. The string is a combination of any of three letters: A, S, and U. The appearance of one of these letters in the string causes the following action to take place in the event of an error: \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright \f4\fs20\cgrid {\b A}{: Abort the program \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b S}{: Issue a system error message \par {\pntext\pard\plain\s58 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s58\fi-360\li1080\sb120\sa120\nowidctlpar\tx900{\*\pn \pnlvlblt\ilvl0\ls3\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls3\adjustright {\b U}{: Issue a user message \par }\pard\plain \li360\sb120\sa120\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright \f4\fs20\cgrid {If ERROR_ACT is not given, the error action will default to the action specified by }{\b x/zveaction}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: output, integer\line If given, UNIT will contain the VICAR I/O unit number being used for the parameter data set. It may then be used in conjunction with other VICAR I/O routines for operations such as adding label information (}{\b x/zladd}{). \line Non-label I/O (i.e., }{\b x/zvread}{ or }{\b x/zvwrit}{) should not be performed on a parameter data set, as it is possible to destroy the data contained in it. \par {\*\bkmkstart _Toc453201500}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.7\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvpout\emdash Write parameter to parameter file. NOT RECOMMENDED.{\*\bkmkend Heading95}{\*\bkmkend _Toc425047551}{\*\bkmkend _Toc425048106}{\*\bkmkend _Toc425329716}{\*\bkmkend _Toc453201500} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvpout( status, name, value, format, count, length ) \line status = zvpout( name, value, format, count, length ) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvpout}{ takes a parameter which exists as a valid TAE parameter in some other program and writes it to a parameter file for passing to that program. The information given is formatted and written out to the parameter file, which has already been opened with a call to }{\b x/zvpopen}{. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b STATUS}{: output, integer\line VICAR return status indicator. Possible values are listed in }{\field{\*\fldinst { REF _Ref395971271 \\* MERGEFORMAT }}{\fldrslt {Appendix B: Error Messages}}}{ (page }{\field{\*\fldinst { PAGEREF _Ref395971271 }}{\fldrslt {\lang1024 140}}}{). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NAME}{: input, string\line Name of the parameter in the PDF of the receiving program. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b VALUE}{: input, any type\line  value of parameter to be written out. The type of argument used for VALUE depends on the value of FORMAT given. The two }{\i must}{ match. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FORMAT}{: input, string\line Data format of VALUE. Valid values are STRING, INT, REAL, REAL8. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: input, integer\line The actual count of the parameter. This value may exceed the allowable count in the receiving PDF. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LENGTH}{: input, integer\line zvpout only. For string parameters, the maximum string length in bytes that occurs in the parameter value vector. For the other formats, this argument is ignored. Since the string length can be obtained from the FORTRAN string itself, it is not needed for the FORTRAN }{\b xvpout}{ call. \par {\*\bkmkstart NUtility}{\*\bkmkstart Heading121}{\*\bkmkstart _Toc425047593}{\*\bkmkstart _Toc425048148}{\*\bkmkstart _Toc453201501}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.8\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvsfile\emdash Skip files on a tape. USE x/zvadd INSTEAD.{\*\bkmkend Heading121}{\*\bkmkend _Toc425047593}{\*\bkmkend _Toc425048148}{\*\bkmkend _Toc453201501} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvsfile(unit, number) \line status =zvsfile(unit, number) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This routine is not needed. Call }{\b x/zvadd}{ with the U_FILE optional instead, which is completely equivalent. \par }{\b x/zvsfile}{ will skip to the file number specified on a tape. If the file number is 0, it skips the tape to the next file. \par }{\b x/zvsfile}{ requires that the tape file be closed, but it still requires a unit number. If the file has not yet been opened, the unit number can be obtained from}{\b  x/zvunit}{. If the file has been opened, it must be closed (with }{\b x/zvclose}{) before }{\b x/zvsfile}{ is called, and re-opened afterwards. The unit number obtained from the first call to }{\b x/zvunit}{ should be used. \par }{\b x/zvsfile}{ sets the U_FILE entry in the control block for the specified unit number. The same effect may be achieved by passing the U_FILE optional to }{\b x/zvopen}{ directly. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line The unit number from }{\b x/zvunit}{ of the tape. The file may not be open. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NUMBER}{: input, integer\line The file number. The same rules apply for NUMBER as for the U_FILE optional to }{\b x/zvopen}{ or }{\b x/zvadd}{. If NUMBER=0, the tape is advanced to the next file. If NUMBER > 0, the tape is moved to the absolute file specified by NUMBER (the first file is file number 1). NUMBER may not be less than zero. \par {\*\bkmkstart Heading123}{\*\bkmkstart _Toc425047595}{\*\bkmkstart _Toc425048150}{\*\bkmkstart Heading96}{\*\bkmkstart _Toc425047552}{\*\bkmkstart _Toc425048107}{\*\bkmkstart _Toc425329717}{\*\bkmkstart _Toc453201502}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.9\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvsptr\emdash String parameter processing subroutine.{\*\bkmkend Heading96}{\*\bkmkend _Toc425047552}{\*\bkmkend _Toc425048107}{\*\bkmkend _Toc425329717}{\*\bkmkend _Toc453201502} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvsptr( val, count, ptr, len ) \line status = zvsptr( val, count, ptr, len ) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Deprecated. The parameter processing routines ( }{\b xvparm}{ }{\i et al}{) will, in the absence of string length information, return multi valued string arrays in a packed format which must be unpacked using }{\b x/zvsptr}{. This packed format (and }{\b x/zvsptr}{) should not be used. Provide the parameter processing routine with a CHARACTER*n array in FORTRAN, or a two-dimensional array of characters with a non-zero LENGTH parameter in C, instead. A normal array of strings will then be returned, and }{\b x/zvsptr}{ will not be needed. \par }{\b x/zvsptr}{ returns pointers to multiple strings returned by }{\b x/zvparm}{. This function is needed when a multi-valued string parameter has been declared to be a BYTE array or CHARACTER (non-array) constant in the application program. \par On return from }{\b x/zvsptr}{, PTR(I) contains the sequence number of the first byte of the Ith string. (i.e., PTR(1) should always be 1.) \par If specified, LEN(I) will contain the length of the Ith string. The indices in PTR are FORTRAN type; that is, the first element is 1. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b VAL}{: input, string\line The array of string values returned from }{\b x/zvparm}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b COUNT}{: input, integer\line COUNT is the number of strings to search for. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b PTR}{: output, integer array, size count\line PTR is an array in which to return the indices to the strings found. The indices are FORTRAN type; i.e., the first element is element 1. }{\b \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b LEN}{: output, integer array, size count\line LEN is an array in which to return the lengths of the strings found. \par {\*\bkmkstart _Toc453201503}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.10\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvtpinfo\emdash Return tape drive information{\*\bkmkend Heading123}{\*\bkmkend _Toc425047595}{\*\bkmkend _Toc425048150}{\*\bkmkend _Toc453201503} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvtpinfo(name,device,file,rec) \line status= zvtpinfo(name,device,file,rec) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvtpinfo}{ is not for use by normal VICAR applications. It is used by certain specialized applications which need to access the tape drive directly without using the VICAR I/O. \par Given the symbolic name of the tape drive from the VICAR MOUNT command, }{\b x/zvtpinfo}{ will return the physical device name and the current position on the tape. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: input, string\line NAME is the symbolic name which was provided to VICAR when the MOUNT or ALLOC command was issued (the NAME parameter). \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b DEVICE}{: output, string\line DEVICE is the physical name of the tape drive as supplied to the MOUNT or ALLOC command via the DEVICE parameter. This name may be used in calls to host routines (such as VMS system services) to manipulate the drive. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FILE}{: output, integer\line FILE is the current file position on the tape, as stored in the VICAR global $TFILE. If }{\b x/zvtpinfo}{ is used with non-VICAR I/O to manipulate the drive, after the program is done}{\b  x/zvtpset}{ should be called to ensure that the file number and record number are accurate. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b REC}{: output, integer\line REC is the current record number of the current file on the tape, as stored in the VICAR global $TREC. If }{\b x/zvtpinfo}{ is used with non-VICAR I/O to manipulate the drive, after the program is finished with its task }{\b x/zvtpset}{ should be called to ensure that the file number and record number are accurate. \par {\*\bkmkstart Heading124}{\*\bkmkstart _Toc425047596}{\*\bkmkstart _Toc425048151}{\*\bkmkstart _Toc453201504}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.11\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvtpmode\emdash Indicate whether an image file is on tape{\*\bkmkend Heading124}{\*\bkmkend _Toc425047596}{\*\bkmkend _Toc425048151}{\*\bkmkend _Toc453201504} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {\cs33 call xvtpmode(unit,ind) \line status =zvtpmode(unit,ind) }{\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvtpmode}{ is used to indicate to the calling program whether or not a given unit number is actually on tape. It should be used by programs which absolutely require a file to be on tape to verify that it is. Normally the device a file resides on should not matter. \par The given unit must have been opened with a call to }{\b x/zvopen}{ before }{\b x/zvtpmode}{ may be called. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b UNIT}{: input, integer\line The VICAR unit number of the file. The unit must have already been opened with a call to }{\b x/zvopen}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b IND}{: output, integer\line If the unit is not a tape, IND will be set to zero, or FALSE. If the output is a tape, then IND should indicate the current density of the drive (800, 1600, or 6250). If an error occurs determining the drive density, then IND will be set to one. \par {\*\bkmkstart Heading125}{\*\bkmkstart _Toc425047597}{\*\bkmkstart _Toc425048152}{\*\bkmkstart _Toc453201505}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 11.12\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {x/zvtpset\emdash Set tape drive position globals{\*\bkmkend Heading125}{\*\bkmkend _Toc425047597}{\*\bkmkend _Toc425048152}{\*\bkmkend _Toc453201505} \par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {call xvtpset(name,file,rec) \line status =zvtpset(name,file,rec) \par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {\b x/zvtpset}{ is a special purpose routine which should not be used by normal VICAR applications. It is intended to be used ONLY as a companion to the non-standard routine }{\b x/zvtpinfo}{. \par }{\b x/zvtpset}{ will save the tape position given by the FILE and REC arguments for the drive NAME in the VICAR supervisor global variables $TFILE and $TREC so that the next program to execute will know the proper tape position. \par }\pard\plain \li360\sb60\sa60\nowidctlpar\adjustright \f4\fs20\cgrid {\b Arguments:}{ \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NAME}{: input, string\line NAME is the symbolic name which was used in the VICAR MOUNT command to mount the tape. It is the same as the NAME parameter for }{\b x/zvtpinfo}{. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b FILE}{: input, integer\line FILE is the current file number of the tape (the first file is file 1). If the true file number is not passed in for FILE, then the next VICAR program will most likely read the wrong file on the tape. \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b REC}{: input, integer\line REC is the current record number in the current file on the tape (the first record is record 1). \par {\*\bkmkstart _Toc453201506}{\*\bkmkend Obsolete}{\*\bkmkend NUtility}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 12.\tab}}\pard\plain \s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Apprendix D{\*\bkmkend _Toc425047611}{\*\bkmkend _Toc425048166}: Unavailable Optional Arguments{\*\bkmkend _Toc453201506}\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {There are a number of "unavailable" optional arguments. These are in the optional argument table, but the validation routine returns a NOT_IMPLEMENTED error. They are:\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {\b NLINES}{: input, integer \line Indicates the number of lines to be accessed in a single operation. Defaults to 1.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SLICE1}{: input, integer \line Indicates the starting pixel in the first dimension of the image. Thus this argument may refer to the LINE, SAMP, or BAND dimension depending on the file organization. It defaults to a starting value of 1and increments per read by 1. (NOT YET AVAILABLE)\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SLICE2}{: input, integer \line As in SLICE1 but for the second file dimension. It defaults to 1 and remains at 1 unless explicitly changed. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b SLICE3}{: input, integer \line As in SLICE2 but for the third file dimension. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NSLICE1}{: input, integer \line Indicates the number of pixels to be accessed in the first dimension of the file. Defaults to the length of the first file dimension. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NSLICE2}{: input, integer \line As in NSLICE1 except for the second file dimension. Defaults, however, to 1. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b NSLICE3}{: input, integer \line As in NSLICE2 except for the third file dimension. (NOT YET AVAILABLE) \par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b U_N4}{: input, integer\line Indicate that the Executive is to ensure that the output file will have its fourth dimension specified by this value This argument is useful for the program which does not care about the file organization, and simply wants to deal with records and pixels.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {\b N4}{: output, integer \line The number of pixels in the fourth dimension of the image. The value returned refers to the physical dimensions of the file and is independent of file organization. \par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {See the table in $V2TOP/rtl/source/global.c for details.\par There are more of these arguments that were (are?) planned for but were never implemented. The SLICE things should give you access to dimensions 1,2,3,(4) regardless of the order (BSQ/BIL/BIP). Right now, you have to jump through some hoops for order-independent reading. And there were apparently plans to have 4-dimensional files, but they were never realized. NLINES was for multi-line reads (e.g. read a tile), which would be quite useful but has not been implemented either.\par {\*\bkmkstart _Ref428698875}{\*\bkmkstart _Ref428698880}{\*\bkmkstart _Ref428698881}{\*\bkmkstart _Toc453201507}{\listtext\pard\plain\s1 \b\fs36 \hich\af4\dbch\af0\loch\f4 13.\tab}}\pard\plain \s1\li360\sb240\sa240\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\outlinelevel0\adjustright \b\f4\fs36\cgrid {Appendix E: About This Document{\*\bkmkend _Ref428698875}{\*\bkmkend _Ref428698880}{\*\bkmkend _Ref428698881}{\*\bkmkend _Toc453201507}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This manual combines material from two previous manuals: \ldblquote VICAR Run-Time Library Reference Manual\rdblquote  JPL D-4311, 1988 and \ldblquote VICAR Porting Guide\rdblquote  JPL D-9395, 1994,\~}{\cs26\ul\cf2 http://www\_mipl.jpl.nasa.gov/portguide/portguide.html}{. Both were written by Robert G. Deen, Robert.G.Deen@jpl.nasa.gov.\par {\*\bkmkstart _Toc453201508}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 13.1\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Document Source{\*\bkmkend _Toc453201508}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {This document was written in the Microsoft Word program. Any changes or additions to it must be made in the original Word document. This is available in two versions: Word native (binary):\~}{\cs26\ul\cf2 http://www\_mipl.jpl.nasa.gov/RTL/RTL_Manual.wrd}{ and Microsoft RTF (Rich Text Format):\~}{\cs26\ul\cf2 http://www\_mipl.jpl.nasa.gov/RTL/RTL_Manual.rtf}{. RTF documents are ASCII text with embedded formatting commands, and can be imported by many word processing programs.\par An Adobe PDF version of this document  at:\~}{\cs26\ul\cf2 http://www\_mipl.jpl.nasa.gov/RTL/RTL_Manual.pdf}{ is available for easy printing or viewing using the Adobe Acrobat Reader from: \~}{\cs26\ul\cf2 http://www.adobe.com/prodindex/acrobat/readstep.html}{.\par {\*\bkmkstart _Toc453201509}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 13.2\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Generating HTML Version{\*\bkmkend _Toc453201509}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The HTML version of this manual is generated automatically from the RTF version by the RTFtoHTML filter program, available from:\~}{\cs26\ul\cf2 http://www.sunpack.com/RTF/}{. You must have a modified version of the html\_trn parameter file:\~}{\cs26\ul\cf2 http://rushmore.JPL.NASA.GOV/RTL/html\_trn}{ in the directory containing the RTFtoHTML program. \par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Use this command line to generate the HTML version of the manual:\par }\pard\plain \s92\sb120\sa120\keep\nowidctlpar\tx1320\tx2280\tx3240\tx4200\tx5180\tx6140\tx7100\tx8060\tx9000\adjustright \f6\fs20\cgrid {./rtftohtml -x -c -h2 -T "VICAR RTL Manual" RTL_Manual_Draft.rtf\par {\*\bkmkstart _Toc453201510}{\listtext\pard\plain\s2 \b\fs28 \hich\af4\dbch\af0\loch\f4 13.3\tab}}\pard\plain \s2\li360\sb120\sa120\keepn\nowidctlpar\brdrb\brdrs\brdrw15 \ls1\ilvl1\outlinelevel1\adjustright \b\f4\fs28\cgrid {Changing or Adding to this Document{\*\bkmkend _Toc453201510}\par }\pard\plain \s39\fi432\li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Any editing done in this document may result in page numbers or section numbers changing. These changes are made automatically only if you use cross-references. If you don\rquote t undertand how to use cross-references, please consult the manual or the online help.\par The HTML generation step can only be successful if you use one of a limited number of styles RTFtoHTML understands.The RTFtoHTML manual:\~}{\cs26\ul\cf2 http://www.sunpack.com/RTF/guide.htm}{ has complete information. \par Since page number references are not useful in HTML, all references of the form: }{\cs109 (page 233) }{must be formatted with the small caps attribute. The html-trn file is modified so that RTFtoHTML will not translate any text in small caps.\par {\*\bkmkstart _Toc453201511}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 13.3.1\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Styles used in this Document{\*\bkmkend _Toc453201511}\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {Below is a list of styles used in this manual. If you use any other styles, please consult the  RTFtoHTML manual:\~}{\cs26\ul\cf2 http://www.sunpack.com/RTF/guide.htm}{ and examine the html\_trn parameter file to make sure the additional styles will not break the HTML generation process.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {Heading 1 \emdash top level heading\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Heading 2 \emdash second level heading\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Heading 3 \emdash third level heading\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Normal \emdash text in Times font without first-line indent\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Normal Indent \emdash text in Times font with first-line indent, no indent in HTML\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {bullet list \emdash first level item list, not numbered\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {bullet list 1 \emdash second level item list, not numbered\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {pre \emdash preformatted text in Courier font, used for code or computer file names\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {glossary \emdash acronym or definition lists\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Caption \emdash table caption\par {\*\bkmkstart _Toc453201512}{\listtext\pard\plain\s3 \b\fs28 \hich\af4\dbch\af0\loch\f4 13.3.2\tab}}\pard\plain \s3\li360\sb120\sa120\keepn\nowidctlpar\ls1\ilvl2\outlinelevel2\adjustright \b\f4\fs28\cgrid {Formatting Hints and Kinks{\*\bkmkend _Toc453201512}\par }\pard\plain \li360\sb120\sa120\nowidctlpar\adjustright \f4\fs20\cgrid {The html-trn is modified for HTML generation to:\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard\plain \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright \f4\fs20\cgrid {Discard any text that is has the text format \ldblquote small caps\rdblquote . This can be found in the Fonts menu item in the Format menu.\par {\pntext\pard\plain\s57 \f3\fs20 \loch\af3\dbch\af0\hich\f3 \u-3913\'b7\tab}}\pard \s57\fi-187\li547\sb120\sa120\nowidctlpar\tx540{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent180\pnhang{\pntxtb \'b7}}\ls2\adjustright {Add extra line breaks (<BR>) after paragraphs and list items.\par }}
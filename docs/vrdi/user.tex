\documentstyle[12pt,twoside,sp_head]{article}
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
\setlength{\headsep}{4ex}
\setlength{\topmargin}{0ex}
\pagestyle{barheading}
\begin{document}
\pagenumbering{roman}
\tableofcontents
\newpage
\pagenumbering{arabic}
\setcounter{page}{1}
\section{Introduction}
This document describes the Virtual Raster Display Interface, (VRDI).  
The document contains an overview of the basics behind this package,
an overview of display processors, guidelines for effective use of
the package, and a detailed description of each routine that is
available to an applications programmer.

The MIPL Virtual Raster Display Interface is a software package that
allows display oriented application programs to be written for a
variety of display devices using a set of common routines.  Its goal
is to provide a uniform operating environment not only for an
application programmer, but for the user as well.  The programmer is
able to write programs without being concerned with the
specifics of the device for which the application is intended.
\cleardoublepage
\section{VRDI Overview}
\subsection{Allocation of Display Hardware}
MIPL is expected to have a variety of image processing hardware.
Resources are allocated and
deallocated by functions of the VRDI.  The variety of MIPL image
processing hardware allows for flexibility in meeting the MIPL users
needs.  The user will be able to query the system about
available resources and the current configuration of hardware
allocated to the user.

Allocation commands may be issued at any time after a MIPL user has
logged onto the system.  Only physical display devices may be
allocated.  A user gets all the resources associated with a display device.
\subsection{Workstations}
A workstation is a physical location where a MIPL user
works.  At that location is a table, chair, terminal,
monitor and interactive IO devices.  A MIPL user may allocate
a display device in a standard configuration by allocating that 
particular workstation.  
Interactive IO devices are associated with particular
display devices.
The user accesses the device by a unique unit number determined at
allocation time.
\subsection{Display Devices}
A standard display device may be allocated by a MIPL user.
When a standard display device is allocated, the allocated
hardware is configured into one of the standard configurations (full
color, pseudo-color or monochrome).  The standard configuration
includes the following:
\begin{itemize}
\item A number of image memory planes are assigned to the display device.
\item The access window of all image memory planes is set to the complete
image memory plane.
\item The display window of all image memory planes is moved to
the upper left hand corner of each image memory plane, coordinates (1,1).
\item All cursors are set to type 1, autotracking, and turned off.
\item The alphanumeric font generator is cleared and turned off.
\item For full color devices, image memory planes are connected 1 to LUT 1
(red), 2 to LUT 2 (green) and 3 to LUT 3 (blue).  Image memory plane
4 is connected to the graphics overlay plane LUT.  All LUTs are set
to no bypass and LUT section 1.
\item For pseudo-color devices, image memory plane 1 is connected to LUT 1
(red), LUT 2 (green) and LUT 3 (blue).  Image memory plane 2 is
connected to the graphics overlay LUT.  All LUTs are set to no bypass
and LUT section 1.
\item For monochrome devices, image memory plane 1 is connected to LUT 1.
Image memory plane 2 is
connected to the graphics overlay plane LUT.  All LUTs are set to
nobypass and LUT section 1.
\item Display of the graphics overlay plane is turned off.
\end{itemize}
\subsection{Coordinate System}
There are two different coordinate systems used by the VRDI.  The
first is raw, or screen, coordinates; the second is image memory
plane coordinates.  In both cases, the coordinate system is the
standard line/sample convention currently used for IPL images.  The
upper left corner of the display device is coordinates (1,1) in
raw coordinates, just as the upper left corner of the image memory
plane is coordinates (1,1) in image memory plane coordinates.
Coordinates increase downward and to the right.  Coordinates are
integer values corresponding to individual pixels on the screen or
in the image memory plane.  We provide further discussion of the
two coordinate systems and translation between the two in
section~\ref{coordinates}.
\subsection{Image Memory Planes}
An image memory plane (IMP) in a display device is a two-dimensional
array of 8-bit pixels.  This limits the number of different pixel
values that may be displayed to 256 (0 to 255).  Image memory planes
are logical entities having a given size and are numbered starting
with one (1).  The display software maintains the connection between
logical and physical image memory planes.  A user may query the
system to obtain information about the number and size of the image
memory planes allocated to a display device.  Some display devices
allow the image memory planes to be configured into several sizes.
Whatever the configuration, all image memory planes in the display
device are the same size.
\subsection{Look-Up Tables}
Image memory planes can be connected to Look-Up Tables (LUTs) which
in turn are connected to Digital to Analog Converters (DACs) that
output video signals to monitors.  By convention, LUT 1 is assumed to
output the RED signal for full color and pseudo-color images.  LUT 2
outputs GREEN and LUT 3 outputs BLUE.

LUTs may be bypassed (pixel values sent directly to the DAC) or the
pixel value may be passed through the LUT for conversion to another value
before being sent to the DAC.  LUTs may also have more than one
section or conversion table.  Although each section or table in a LUT
has 256 entry points (one for each possible pixel value) it may have
more than an 8-bit output value.  This difference is sometimes used
to load the LUT with a more accurate gamma correction curve than 8
bits will provide.  The user may query the system to obtain
information about the number of sections in each LUT and the size of
the output value.  Sections are numbered starting with one (1).
\subsection{Graphics Overlay Plane}
The displaying of graphics overlay data is logically the same as
displaying data in any image memory plane.  Any image memory plane
may be used as a graphics overlay plane by connecting it to the
graphics overlay LUT.  The graphics overlay LUT consists of three
tables (red, green and blue) that look and act exactly like the
regular LUT tables.  The overlay process is accomplished by replacing
output pixels with overlay pixels.  This takes place only if the
graphics pixel has a non-zero value.  The display of graphics overlay
data may be turned on or off under software control.
\subsection{Cursors}
A cursor in a display device is a group of pixels which overlay
the data on the image memory planes.  Cursors work by pixel
substitution and are written on top of the graphics overlay
data.  Each cursor has a number of forms and blink rates, which
are device-dependent.  The center of the cursor pattern may be
moved over any pixel in any image memory plane.  The location
of the cursor may be set or read (in either screen coordinates
or image memory plane coordinates) by the VRDI cursor routines.
In addition, the size and color of the cursor may be
changed (for some devices) by the VRDI cursor routines.
\subsection{Subroutine Naming Convention}
Each of the display interface routines contains both a C interface
and a FORTRAN interface.  The first two letters in the name of each
C routine are ``ZD''.  The first two letters in the name of each
FORTRAN routine are ``XD''.  The remaining letters are the same for
each of the interfaces.  The third letter in the name of each routine
indicates the major function or hardware component with which the
routine is  concerned.  The letters correspond to the following:
\begin{itemize}
\item A  -  Alphanumeric Font Generator
\item C  -  Cursor Generator
\item D  -  Device Configuration
\item E  -  Error Handling
\item F  -  Interprocess Communication Flags
\item G  -  Graphics Overlay Plane
\item I  -  Image Memory Planes
\item L  -  Look-Up Tables
\item S  -  Device Status
\item T  -  Text Generation in Image Memory Planes
\item X  -  Interactive IO Devices (tablets, joysticks, etc.)
\end{itemize}
The rest of the routine name describes the function of the routine.

For example, the routine name ZDLREAD is translated as follows:
\begin{tabbing}
xxxxx\=xxxxxxxxxxxx\=xxxxxxxxxxxxxx\=\kill
\>ZD\>Interface\>C Interface\\
\>L\>Category\>Look-Up Table Routine\\
\>READ\>Purpose\>Read Look-Up Table\\
\end{tabbing}
\subsection{Subroutine Parameters}
Section~\ref{routines} of this document describe the parameters to
each of the VRDI subroutines.  These descriptions include whether the
parameter is an input or output, its data type, its dimension, and a
comment on its purpose.  Since the data types for FORTRAN and C are
not necessarily alike, the descriptions include both types of data.
The FORTRAN subroutine parameters are all passed by reference.  The
C subroutine parameters are generally passed by value, except when
the parameter is a string or is an output from the subroutine.  The
description of each subroutine indicates whether the C parameters
are passed by value or by reference.
\subsubsection{C Interface}
A parameter data type may fall into one of five categories:
\begin{itemize}
\item integer:  The C default for integer (int).
\item real:  The C default for real (float).
\item byte:  An 8-bit value (unsigned char).
\item logical:  A parameter that is either TRUE (1) or FALSE (0).
The C default for integer (int).
\item string:	A null-terminated array of 8-bit characters (char),
which may be passed as an array or as a pointer to the first element
in the array.  Another parameter, usually named LENGTH, will accompany
a parameter of type string.  This parameter will specify the number of
characters in the string.  If the length parameter is zero (0), the
string should be null-terminated to indicate the length of the string.
\end{itemize}
\subsubsection{FORTRAN Interface}
A parameter data type may fall into one of five categories:
\begin{itemize}
\item integer:	The FORTRAN default for INTEGER (INTEGER*4).
\item real:	The FORTRAN default for REAL (REAL*4).
\item byte:	A single 8-bit value.  In FORTRAN it may be a BYTE,
CHARACTER or LOGICAL*1.
\item logical:	A parameter that is either TRUE (1) or FALSE (0).
In FORTRAN this may be a LOGICAL or an INTEGER.
\item string:	A string is an array of 8-bit characters and
may be passed either by descriptor (CHARACTER*n), or by
reference (BYTE, LOGICAL*1, or INTEGER array).

Another parameter, usually named LENGTH, will accompany a parameter
of type string.  This parameter will specify the number of characters
in the string.  If the length parameter is zero (0), the string should
be null terminated or the string should be passed by descriptor.

If the string is passed by descriptor and the length parameter is
not zero, the number of characters in the string will be the
smaller of the two values (the length field in the descriptor or
the length parameter).  If the length parameter is smaller, the
string will be padded with blanks up to the length of the descriptor.
If the length parameter is larger, the string will be truncated to
fit into the descriptor.
\end{itemize}
\subsection{Subroutine Returned Status Codes}
Each of the display interface routines are functions.  They may be
used as subroutines by just calling them or as functions by using
them in expressions.  When used as functions, the returned status 
is an integer value.  In most cases, the returned value is a code
signifying the success or failure of the operation.

The value returned by the routines determines the error that
occurred.  Each possible error that can occur has its own unique
value.  Most routines that complete successfully return a value of
SUCCESS (1).  Exceptions are the flag routines, XDF* (which return TRUE
or FALSE), and the status routines, XDS* (which return the requested
information).  See appendix A for a list of possible errors, their
values, and descriptions.

Each error status falls into one of three categories:  WARNING,
ERROR, or FATAL.  WARNINGs can be considered programmer/user
information and should have little or no effect on the execution of
the program.  ERRORs are really recoverable errors, i.e., things
that go wrong but can later be ``fixed''.  FATALs are non-recoverable
errors.  If one of these occurs the program should terminate
immediately.

Along with these returned error statuses are utilities routines to
help the programmer handle the errors:  XDEACTION,
XDESIGNAL, and XDELEVEL.  XDEACTION allows the programmer to set
the action to perform for each category of error codes.  The actions
that can be performed are:  1) return the status code, 2) issue a
system error message and return the status code, or 3) issue a system
error message and abort.  XDESIGNAL can be used to provide the system
error message for a given status code.  XDELEVEL can be used to
determine the error severity level for a given status code--i.e.,
FATAL, ERROR, WARNING, or NO ERROR.

The system error message returned by the VRDI includes a text code
abbreviation corresponding to the particular error.  If the VRDI is
being run interactively, you can obtain help on the error by typing
"help-message vrdi-xxxxxxxxx", where "xxxxxxxxx" is the text code
of the error in question.  This help is also available within VICAR.

In most cases, an application program need only check the returned
function value for SUCCESS (or lack thereof).  If you need to check
for a particular error, the error codes and values are listed in
appendix A.  Additionally, if you use the C interface, you may
insert the following statements at the beginning of your program:

\#include XDMAININC\\
\#include xderrors\\

and access the error codes by name.

The constant name of each error code that can be returned by a
particular function is listed under the function description in
Section~\ref{routines}.
\subsection{Text Generation}
In most cases the display devices do not have alphanumeric font
generators.  Instead, a series of routines
are supplied that will allow the user to write text directly into the
image memory planes as pixel values.  In order to not modify the image,
the text may be written into the overlay plane and displayed.

The Hershey character fonts are supplied to give the user several
fonts to choose.  Users may also design their own fonts.  See
appendix F for further details.
\subsection{Access Window}
Each image memory plane has an access window associated with it.  The
access window defines the area of an image memory plane where the
pixels may be modified.  Pixels outside the access window cannot be
modified by the user.  The size and location of the access window into
the image memory plane is application-defined.  The default access window
is the entire image memory plane.
\subsection{Display Window}
Each image memory plane has a display window associated with it.  The
display window defines the location, in image plane coordinates, of the
upper left corner of the video screen--i.e., the display window
defines the offset of the image memory plane onto the screen.  For example,
if the display window is set to be (100,100), then image memory plane
pixel (100,100) will appear at screen location (1,1).  Every other
image memory plane pixel will be offset in a similar manner.  The display
window for each image memory plane is application-defined.  The default
display window is (1,1).  Only the upper left corner of the display
window is defined because the size of the window displayed on the monitor
is determined by the hardware.
\subsection{Virtual Display Device}
The software described in this document defines and describes display devices
(frame buffers).  Many of the existing display devices do not have all
of these capabilities.  In these cases the software simulates the
desired functions to the best of its ability.  With some display
devices it is not possible to simulate a function; in this case
an appropriate error code is returned.

The following is a description of the virtual display device defined
by the software:
\begin{itemize}
\item A number of square eight (8) bit image memory planes.  The currently
allowed sizes are $512 \times 512$, $1024 \times 1024$ or
$2048 \times 2048$.  Image
memory planes of larger sizes may be configured into smaller ones.
Each image memory plane has an access window and a display window 
associated with it.  Any image memory plane can be connected to any or
all LUT/DACs including the graphics overlay LUT.
\item Each display device has 1 or more (3 for full color) LUT/DACs.  Each
LUT contains one or more pixel transformation tables (sections).
Each table has 256 entries, one for every possible pixel value.  LUTs
may be bypassed under software control, allowing pixel values to be
sent directly to the DACs.  The LUT section is also under software control.
\item The graphics overlay LUT is different from the standard LUTs in that
it has three tables (red, green, blue) in full color display
devices.  Graphics overlay works by pixel substitution.  If graphics
overlay is ``ON'', non-zero overlay pixels are substituted for regular
pixels before going to the the DACs.  In this way graphics overlay data
is written on top of the output image.  Any of the image memory
planes may be connected to the graphics overlay LUT.
\item The alphanumeric font generator works the same way as the graphics
overlay does (pixel substitution).  Font information is written on
top of graphics overlay data.  No MIPL display device has a font generator.
\item One or more cursors are available.  Cursors also work by pixel
substitution and are written on top of the graphics overlay data.
Each cursor has a number of forms and blink rates.  The cursor form
also includes the color of the cursor.  The center of the cursor
pattern may be moved over every pixel in any image memory plane.  The
location of the cursor may be read or written by software.
\item The display device has hardware which allows arithmetic and logical
operations between image memory planes, area fill, histogram
generation, and vector drawing.
\item All LUT tables are readable and writeable by software.
\item All device control registers are  readable  and  writeable  by
software. 
\item Aspect ratios of 1x1 and 4x3 are available.
\item The location of the display window may be read and written by
software.  The display window may be moved under software control so
that every pixel in an image memory plane can be seen.
\item Interactive IO devices may be connected to the display device.  The
cursor or the display window may be set to automatically track one of
the interactive IO devices.
\end{itemize}
\cleardoublepage
\section{VRDI Application Program Guidelines}
\label{guidelines}
As systems become more interactive and more user-friendly, they also
typically become more complex to program.  With an interactive display
program such as VIDS running, the user is in control and can do anything
to the display device at any time.  This has the potential for interfering
with an application program unless careful attention is paid.  For
this reason, application programs that use the VRDI should follow a few
simple rules in order to coexist peacefully with VIDS and other display
programs.  Several routines have been added to the VRDI to make these
rules as simple and painless as possible.
\subsection{Never Assume Anything}
The most basic rule is:  ``Never Assume Anything''.  You cannot assume that
because you set a zoom factor, the zoom will be the same the next time
you need to use it.  The solution to this is simple:  always call the
VRDI to read the state of the display rather than relying on a saved
local variable.  There are VRDI routines that return
information, like XDDINFO or XDLREAD.  In addition, there is a whole
class of VRDI routines, the XDS* (status) routines, which return
information.  These routines return the value as the function return
instead of a parameter.  Thus, you can do a direct substitution of the
function call any time you would normally use a local variable.

There are times when it is appropriate to save information locally.
For example, the size of the image planes will not change often.  Furthermore,
when the size does change, the XDFCONFIG flag will be set, so you can check it.
For items like these, where there is a flag available to indicate changes,
you may save the items locally and only update them when
the flag is set.  Additionally, items that are used many times in
succession, e.g., in an extended calculation or in a loop, may be saved
locally.
\subsection{Check the Flags}
There are several flags that indicate when something has changed.  These
should be checked after every XVINTRACT call to determine if the device
configuration has changed.  They may also be checked after every direct
call to VIDS by the application.  However, since the application issued
the call to VIDS, it should know the effect of the call, and checking
the flags may not be necessary.  The flags are cleared automatically
every time they are checked.

The most important flag is XDFCONFIG, which indicates that the display
device configuration has been modified, e.g., changing the size of the
image planes, changing what planes are displayed, or changing the display
mode (monochrome/pseudo-color/full color).  If this flag is set, you have
two choices:  1) reset the configuration, or 2) determine what changed
and use the new configuration.  For example, if the user changes the
monochrome image memory plane from 1 to 2, the application may reset it
to plane 1 or use plane 2.

The XDFLUT flag is not important for most applications.  It is used
primarily by VIDS.  Most applications, if they need to know the look-up
tables at all, will need it only infrequently.  Thus, they can read the
tables from the hardware every time, using XDLREAD, and not use this flag.

The XDFGLUT flag is similar in use to the XDFLUT flag.  However, if
it is critical that your graphics be displayed in some non-standard
graphics look-up table, you can monitor the XDFGLUT flag and reset the
grpahics look-up table if it changes.

The XDFIMAGE flag will be important for some applications and not for
others.  If you need to check, you should first check with a plane number
of 0, which lets you know if any planes have changed.  If they have, you
can check each plane to determine which has changed.  For each changed
image plane, the application may either refresh the screen, thereby
redrawing the image, or could just note the fact that a change has
occurred, and continue.

Note that the change may be what the user wants, i.e., the
user displayed a part of another image in a small area on the screen for
reference.  For this reason, you should not indiscriminately refresh the
image.  Many applications will not need to check this flag, as they can
assume the user knows what he is doing.
\subsection{Allow User Flexibility}
This is not a rule, but rather a suggestion.  Allow the user as much
flexibility as you can.  You should have as few restrictions as possible.

The user should be in charge of his interactive session.  If something
has changed, there was probably a reason for the change.  You
should respect the user's choice, if at all possible, and not arbitrarily
change it back.  Sometimes this is not possible, e.g., you can only
handle color images and the user changed to monochrome.  But, in
general, you should honor the choices the user makes, even if it makes
your task a little more difficult.

For example, if your application works in monochrome mode, and the
user sets pseudo-color mode, you should allow this.  If the user changes
the current monochrome plane, you can either use the new plane, or
change it back.

As another example, do not change the cursor that the user has selected.
Use the XDCSHOW and XDCOFF routines to turn the cursor on and off
without changing the user's form and blink rate selection.  In other
words, you should never call XDCON (which changes the form and blink
rate of the cursor as well as turning it on) unless the user specifically
requests that the cursor be changed.

Similarly, if the user sets the device to a different resolution, you
should use the new resolution if at all possible.  The user
changed resolutions for a reason, and you should not ignore it.

You should always provide some kind of refresh command, which redraws the
application's image and associated graphics.  This allows the user to
quickly display something else and then return to what the application
was doing with a simple refresh command.
\subsection{Graphics Plane}
Do not change the default graphics look-up table unless you must.  The
default table (set by XDGLINIT) contains most of the colors you
will need in the graphics plane.  Plus, by using the default table,
your graphics will retain their color after your application exits, and
other graphics that the user has selected will still display correctly.

As a corollary to this, you should never use XDGLCONSTANT.  It sets up
a look-up table in which everything is the same color.  You should also
avoid using XDGLWRITE to write your own table, since
it will interfere with other applications that use the default graphics
look-up table.  If you do need to change the graphics look-up table,
it would be courteous to reset it before your program exits.

Just because you use the default table does not mean you can assume you
know what the default table is.  It will be different on different devices
due to hardware differences.  The particular DN value you use for red may
not be the DN value for red on another device.  There are two
routines to assist you in finding the right DN value to use.  They are
XDGCOLOR, which accepts a string of color names and returns the DN
value that best matches, and XDRGB, which accepts an RGB triple and
returns the DN value that best matches.  One note of caution:  on a
small, limited look-up table the best match to your color value may
not be a very good match.  If you require a specific color, you may
need to use XDGLWRITE to obtain it.
\subsection{Coordinates}
\label{coordinates}
There are two different coordinate systems used by the VRDI.  They are
raw, or screen, coordinates, and image plane coordinates.  You need to
be careful to make the distinction correctly.

Screen coordinates are always the size of the video display.  The upper
left corner of the monitor is always location (1,1).  The screen
coordinates are never zoomed, either, so the bottom right corner is
always the size of the video (e.g., (512,512) or (1024,1024), etc.).
Screen coordinates are used primarily for the cursor, as the cursor
can not move off-screen.  The only routines that use screen coordinates
are XDCLOCATION, XDCSET, XDCIMP2RAW, and XDCRAW2IMP.  Everything
else uses image plane coordinates.  If you are reading the cursor location
to find a pixel in a particular image, you should use image plane
coordinates, either with XDCILOCATION or with the coordinate translation
routine XDCRAW2IMP.

Image plane coordinates are always the size of the image planes.  The
upper left corner of the image plane is always location (1,1).  However,
that location may or may not be the upper left of the screen.  If a
hardware pan is in effect, the upper left corner of the screen will not
be (1,1) in image plane coordinates.  Likewise, the number of pixels on
the screen will change with different zooms.  For example, if the video
size is $512 \times 512$, at zoom 1 there will be $512 \times 512$
image plane pixels
displayed.  At zoom 2, however, there will only be $256 \times 256$ pixels.
So, there is not a one-to-one correspondence between image plane and screen
coordinates.  Also, the coordinates for different image planes may not
line up on the screen, due to differing pans and zooms on each image
memory plane.  The VRDI routines, XDCRAW2IMP and XDCIMP2RAW, were
created to translate between raw (screen) and image memory plane
coordinates specifically to deal with the difficulties described above.

It should be noted that the screen and image memory plane coordinate
systems are exactly the ones used by VIDS.  VIDS has one extra system,
file coordinates, but the other two are identical.
\cleardoublepage
\section{VRDI Routines}
\label{routines}
This section contains the detailed description of the VRDI
routines.  The descriptions are organized in alphabetical order
by function (e.g., cursor routines, device configuration routines,
image memory plane routines, etc.) and include the following
information:
\begin{enumerate}
\item Title and Function--The title and function of each routine are
listed at the top of the page.  The title is the name of the routine
in the FORTRAN interface--i.e., the title begins with an ``X''.  To
obtain the name of the routine in the C interface, substitute a ``Z''
for the ``X''.
\item C Interface Calling Context--The calling context of the routine
in the C interface is provided, along with a list of the parameters
to the function--including parameter name and data type.
\item FORTRAN Interface Calling Context--The calling context of the
routine in the FORTRAN interface is provided, along with a list of
the parameters to the function.  A detailed description of each
parameter is also provided--including the parameter name, whether
it is input or output, parameter data type, and a brief description.
\item Function Return Values--A list of the possible values returned
by the function is included, along with a description of each.

The values returned by the function are given as the constant
name that the VRDI uses to identify the error.  To determine the
numeric value corresponding to the constant name, see Appendix A.
These constants are also defined in the XDERRORS.H include file.
If you are using the C interface to the VRDI, you may add
the following statements to the beginning of your program:

\#include XDMAININC\\
\#include xderrors\\

This will allow you to reference the errors by the appropriate
name.
\item Function Description--Detailed description of the purpose of
the function.
\end{enumerate}
\newpage
\subsection{Alphanumeric Font Generator}
\subsubsection{XDACLEAR - Clear Alphanumeric Font Generator}
\begin{tabbing}
status = \=zdaclear( unit, x, y, nchars )\\
\>int  unit, x, y, nchars;\\
\end{tabbing}
STATUS = XDACLEAR( UNIT, X, Y, NCHARS )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item X:  input, integer

Starting AFG column.
\item Y:  input, integer

Starting AFG row.
\item NCHARS:  input, integer

Number of characters to be cleared.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
AFG\_NOT\_AVAILABLE\>Alphanumeric font generator is not available.\\
AFG\_NOT\_ACTIVE\>Alphanumeric font generator is not active.\\
\end{tabbing}
\end{enumerate}
Clears the text in the AFG of display unit UNIT.  Characters starting
at location X, Y in Alphanumeric Font Generator coordinates (line and
position) are cleared.  If NCHARS is zero or negative, all of the
characters from X, Y to the end of the AFG memory are cleared.
\newpage
\subsubsection{XDAOFF - Turn Off Display of Alphanumeric Font Generator}
\begin{tabbing}
status = \=zdaoff( unit )\\
\>int  unit;\\
\end{tabbing}
STATUS = XDAOFF( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
AFG\_NOT\_AVAILABLE\>Alphanumeric font generator is not available.\\
\end{tabbing}
\end{enumerate}
Turns off the display of the characters in the AFG.
\newpage
\subsubsection{XDAON - Turn On Display of Alphanumeric Font Generator}
\begin{tabbing}
status = \=zdaon( unit )\\
\>int  unit;\\
\end{tabbing}
STATUS = XDAON( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
AFG\_NOT\_AVAILABLE\>Alphanumeric font generator is not available.\\
\end{tabbing}
\end{enumerate}
Turns on the display of characters in the AFG.
\newpage
\subsubsection{XDATEXT - Write Text to Alphanumeric Font Generator}
\begin{tabbing}
status = \=zdatext( unit, x, y, length, text, blink, reverse )\\
\>int  unit, x, y, length;\\
\>char  text[];\\
\>int  blink, reverse;\\
\end{tabbing}
STATUS = XDATEXT( UNIT, X, Y, LENGTH, TEXT, BLINK, REVERSE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item X:  input, integer

Starting AFG column.
\item Y:  input, integer

Starting AFG row.
\item LENGTH:  input, integer

Number of characters in TEXT.
\item TEXT:  input, string

String containing the characters to be written.
\item BLINK:  input, logical

If BLINK is TRUE, the text will blink; if FALSE, it will not.
\item REVERSE:  input, logical

If REVERSE is TRUE, the text will be displayed in reverse video; if FALSE, 
it will not.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
AFG\_NOT\_AVAILABLE\>Alphanumeric font generator is not available.\\
AFG\_NOT\_ACTIVE\>Alphanumeric font generator is not active.\\
INVALID\_CHAR\_COUNT\>Invalid character count.\\
\end{tabbing}
\end{enumerate}
Writes text into the AFG.  Text is displayed starting at location X, Y
in Alphanumeric Font Generator coordinates (line and position).  If
LENGTH is zero, TEXT must be either a character string descriptor
or a null terminated character array.
\newpage
\subsection{Cursor Routines}
The VRDI cursor routines operate under the following assumptions:

1.  The hardware cursor generator may generate more than one cursor.

2.  The available cursors are numbered starting with one.

3.  Cursor number one is the default cursor.

4.  The cursor may be available in several forms.

5.  Forms are numbered starting with one.

6.  Form zero is the default cursor form.

7.  The default form is implementation dependent.

8.  The size of the cursor may be adjusted on some devices.

9.  The color of the cursor may be adjusted on some devices.
\newpage
\subsubsection{XDCAUTOTRACK - Set Cursor/Device Tracking}
\begin{tabbing}
status = \=zdcautotrack( unit, cursor, device, flag )\\
\>int  unit, cursor, device, flag;\\
\end{tabbing}
STATUS = XDCAUTOTRACK( UNIT, CURSOR, DEVICE, FLAG )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Number of cursor to be ``connected to'' or ``disconnected from'' DEVICE.
\item DEVICE:  input, integer

Number of device to be ``connected to'' or ``disconnected from'' CURSOR.
\item FLAG:  input, logical

Determines if CURSOR and DEVICE are to be ``connected'' or
``disconnected''.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_AUTO\_TRACK\>Autotracking is not available.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
NO\_SUCH\_INPUT\_DEVICE\>No such input device.\\
\end{tabbing}
\end{enumerate}
Enables or disables autotracking for the specified CURSOR and
interactive IO DEVICE.  FLAG is TRUE for autotracking and FALSE for
no autotracking.  Autotracking means that the display unit
automatically moves the cursor in response the interactive IO device
without utilizing the system CPU.  In no autotracking mode the
cursor can only be moved on command from the application program.
\newpage
\subsubsection{XDCILOCATION - Get Cursor Location In Image Plane Coordinates}
\begin{tabbing}
status = \=zdcilocation( unit, cursor, x, y, imp )\\
\>int  unit, cursor, *x, *y, imp;\\
\end{tabbing}
STATUS = XDCILOCATION( UNIT, CURSOR, X, Y, IMP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Cursor to get location from.
\item X:  output, integer

Sample location of cursor.
\item Y:  output, integer

Line location of cursor.
\item IMP:  input, integer

Image memory plane.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Returns the location of the cursor in the image memory plane coordinates,
X and Y (sample and line).  Note that if you need the location for more
than one plane, you should call XDCLOCATION followed by several 
XDCRAW2IMP calls, because the cursor could move between XDCILOCATION
calls.  To obtain the location of the cursor in raw coordinates, use
XDCLOCATION or use this routine followed by XDCIMP2RAW.
\newpage
\subsubsection{XDCIMP2RAW - Translate from Image Plane Coordinates to Raw}
\begin{tabbing}
status = \=zdcimp2raw( unit, imp, ximp, yimp, xraw, yraw )\\
\>int  unit, imp, ximp, yimp, *xraw, *yraw;\\
\end{tabbing}
STATUS = XDCIMP2RAW(UNIT, IMP, XIMP, YIMP, XRAW, YRAW)
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane.
\item XIMP:  input, integer

Image memory plane X coordinate.
\item YIMP:  input, integer

Image memory plane Y coordinate.
\item XRAW:  output, integer

Raw (screen) X coordinate.
\item YRAW:  output, integer

Raw (screen) Y coordinate.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Translates a point from image plane coordinates for the given image
plane to raw (screen) coordinates.  The translation may be different
for every plane.  If the given image plane coordinates translate to
screen coordinates that exceed the screen limits, the routine will
return screen coordinates MOD screen size.  For example:  if the
screen size is $512 \times 512$ and the screen coordinates are (762,762),
the routine will return (250,250).  This routine is included with
the cursor routines because that is how it will normally be used.
\newpage
\subsubsection{XDCISET - Set Cursor Location in Image Plane Coordinates}
\begin{tabbing}
status = \=zdciset( unit, cursor, x, y, imp )\\
\>int  unit, cursor, x, y, imp;\\
\end{tabbing}
STATUS = XDCISET( UNIT, CURSOR, X, Y, IMP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Number of cursor to be moved.
\item X:  input, integer

New sample location for the cursor.
\item Y:  input, integer

New line location for the cursor.
\item IMP:  input, integer

Image memory plane.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Moves the specified cursor to the given location in image plane
coordinates.  If the given image plane coordinates translate to
screen coordinates that exceed the screen limits, the routine
will move the cursor to screen coordinates MOD screen size.  For
example:  if the screen size is $512 \times 512$ and the screen coordinates
are (762,762), the cursor will be moved to screen location (250,250).

If you immediately read the cursor back, you may not get exactly
exactly the same image plane coordinates because of the feature
described above and because of round-off problems in the zoom
calculation.  Similarly, the same coordinates in two different
image planes may translate to different screen coordinates.

If you need to set the cursor in raw (screen) coordinates, either
use the XDCSET routine or use the XDCRAW2IMP routine followed by
this routine.
\newpage
\subsubsection{XDCCOLOR - Set Cursor Color}
\begin{tabbing}
status = \=zdccolor( unit, cursor, red, green, blue )\\
\>int  unit, cursor, red, green, blue;\\
\end{tabbing}
STATUS = XDCCOLOR( UNIT, CURSOR, RED, GREEN, BLUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Number of cursor to turn on.
\item RED:  input, integer

Red intensity value for cursor.
\item GREEN:  input, integer

Green intensity value for cursor.
\item BLUE:  input, integer

Blue intensity value for cursor.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
DEVICE\_CANNOT\_DO\_IT\>Device does not support the requested function.\\
INVALID\_COLOR\>Invalid color value (accepted range is 0-255).\\
NO\_SUCH\_CURSOR\>No such cursor.\\
\end{tabbing}
\end{enumerate}
Sets the color of the specified cursor.  If the cursor has been turned
on (either by default in XDDOPEN or by use of XDCON or XDCSHOW), this
function will set the cursor to the specified color.  If the cursor
is not on, the cursor color values will be saved in shared memory and
the function will return.  The saved values will be used the next time
the cursor is active.
\newpage
\subsubsection{XDCLOCATION - Get Cursor Location in Raw Coordinates}
\begin{tabbing}
status = \=zdclocation( unit, cursor, x, y )\\
\>int  unit, cursor, *x, *y;\\
\end{tabbing}
STATUS = XDCLOCATION( UNIT, CURSOR, X, Y )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Cursor to get location from.
\item X:  output, integer

Sample location of cursor.
\item Y:  output, integer

Line location of cursor.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
\end{tabbing}
\end{enumerate}
Returns the location of the cursor in raw (screen) coordinates, X and Y
(sample and line).  To obtain the location of the cursor in image memory
plane coordinates, use XDCILOCATION or use this routine followed by
XDCRAW2IMP.
\newpage
\subsubsection{XDCOFF - Turn Cursor Off}
\begin{tabbing}
status = \=zdcoff( unit, cursor )\\
\>int  unit, cursor;\\
\end{tabbing}
STATUS = XDCOFF( UNIT, CURSOR )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Number of cursor to turn off.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
\end{tabbing}
\end{enumerate}
Turns off the display of the specified cursor.
\newpage
\subsubsection{XDCON - Turn Cursor On}
\begin{tabbing}
status = \=zdcon( unit, cursor, form, blink )\\
\>int  unit, cursor, form, blink;\\
\end{tabbing}
STATUS = XDCON( UNIT, CURSOR, FORM, BLINK )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Number of cursor to turn on.
\item FORM:  input, integer

Number of the cursor form to be used.  (Implementation defined, see
appendix C for valid values.)
\item BLINK:  input, integer

Cursor blink rate.  (Implementation defined, see appendix C for valid
values.)
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
NO\_SUCH\_CURSOR\_FORM\>No such cursor form.\\
NO\_SUCH\_CURSOR\_RATE\>No such cursor rate.\\
\end{tabbing}
\end{enumerate}
Turns on the display of the specified cursor.  The cursor's form and
blink rate are also set.  Forms and blink rates are implementation
defined (see appendix C).  XDCSHOW may also be used to turn on the
cursor without specifying the form and blink rates--i.e., the current
form and blink rate are used.
\newpage
\subsubsection{XDCRAW2IMP - Translate from Raw Coordinates to Image Plane}
\begin{tabbing}
status = \=zdcraw2imp( unit, imp, xraw, yraw, ximp, yimp )\\
\>int  unit, imp, xraw, yraw, *ximp, *yimp;\\
\end{tabbing}
STATUS = XDCRAW2IMP(UNIT, IMP, XRAW, YRAW, XIMP, YIMP)
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane.
\item XRAW:  input, integer

Raw (screen) X coordinate.
\item YRAW:  input, integer

Raw (screen) Y coordinate.
\item XIMP:  output, integer

Image memory plane X coordinate.
\item YIMP:  output, integer

Image memory plane Y coordinate.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Translates a point from raw (screen) coordinates to image plane
coordinates for the given image plane.  The translation may be
different for every plane.  This routine is included with the
cursor routines because that is how it will normally be used.
\newpage
\subsubsection{XDCSET - Set Cursor Location in Raw Coordinates}
\begin{tabbing}
status = \=zdcset( unit, cursor, x, y )\\
\>int  unit, cursor, x, y;\\
\end{tabbing}
STATUS = XDCSET( UNIT, CURSOR, X, Y )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Number of cursor to be moved.
\item X:  input, integer

New sample location for the cursor.
\item Y:  input, integer

New line location for the cursor.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
INVALID\_COORDINATES\>Invalid coordinates.\\
\end{tabbing}
\end{enumerate}
Moves the specified cursor to the raw (screen) coordinate location,
X and Y (sample and line).  To move the cursor to image plane
coordinates, either use XDCISET, or use XDCIMP2RAW followed by this
routine.
\newpage
\subsubsection{XDCSHOW - Turn Cursor On}
\begin{tabbing}
status = \=zdcshow( unit, cursor )\\
\>int  unit, cursor;\\
\end{tabbing}
STATUS = XDCSHOW( UNIT, CURSOR )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Number of cursor to turn on.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
\end{tabbing}
\end{enumerate}
Turns on the display of the specified cursor without changing the
current form and blink rate.  Forms and blink rates are implementation
defined (see appendix C).  XDCON may also be used to turn on the
cursor with a defined form and blink rate.
\newpage
\subsubsection{XDCSIZE - Set Cursor Size}
\begin{tabbing}
status = \=zdcsize( unit, cursor, xsize, ysize )\\
\>int  unit, cursor, xsize, ysize;\\
\end{tabbing}
STATUS = XDCSIZE( UNIT, CURSOR, XSIZE, YSIZE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CURSOR:  input, integer

Number of cursor to turn on.
\item XSIZE:  input, integer

Horizontal size of the cursor in pixel coordinates.
\item YSIZE:  input, integer

Vertical size of the cursor in pixel coordinates.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
DEVICE\_CANNOT\_DO\_IT\>Device does not support the requested function.\\
INVALID\_CURSOR\_SIZE\>Invalid cursor size.\\
NO\_SUCH\_CURSOR\>No such cursor.\\
\end{tabbing}
\end{enumerate}
Sets the size of the specified cursor.  If the cursor has been turned
on (either by default in XDDOPEN or by use of XDCON or XDCSHOW) and is
resizable (form = -1), this function will re-draw the cursor to the
specified size.  If the cursor is not on or is not resizable, the cursor
size will be saved in shared memory and the function will return.  The
saved values will be used the next time a resizable cursor is active.
\newpage
\subsection{Device Configuration Routines}
\subsubsection{XDDACTIVATE - Activate/deactivate a Device}
\begin{tabbing}
status = \=zddactivate( unit, flag )\\
\>int  unit, flag;\\
\end{tabbing}
STATUS = XDDACTIVATE( UNIT, FLAG )
\begin{enumerate}
\item UNIT:  input, integer

The unit number of the device to be activated or deactivated.
\item FLAG:  input, logical

If FLAG is TRUE, the device is activated; if FALSE, the device is
deactivated.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_ALREADY\_ACTIVE\>Device is already active.\\
\end{tabbing}
\end{enumerate}
Turn on or off the modification of the display unit UNIT.  If the
logical flag FLAG is TRUE, modification of display unit UNIT is
allowed.  If it is FALSE, modification is not allowed.
\newpage
\subsubsection{XDDALLOCATE - Allocate a Device}
\begin{tabbing}
status = \=zddallocate( device )\\
\>char  *device;\\
\end{tabbing}
STATUS = XDDALLOCATE( DEVICE )
\begin{enumerate}
\item DEVICE:  input, string

Name of the device to be allocated.  This may be an actual device
name (EPA0), a generic device name (EP), or DEFAULT.  
DEFAULT will try to allocate the ``default''
device that is assigned to the terminal currently in use.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
NO\_DEFAULT\_DEVICE\>No default device for this terminal.\\
NO\_AVAIL\_GENERIC\_DEV\>Unable to find available generic device.\\
NO\_SUCH\_DEVICE\>Unable to find device.\\
DEVICE\_NOT\_AVAIL\>Device is not available.\\
CREATE\_LNM\_ERROR\>Unable to create logical name.\\
GET\_PID\_ERROR\>Unable to get Process ID.\\
GET\_OWNER\_NAME\_ERROR\>Unable to get device owner username.\\
GET\_OWNER\_TERM\_ERROR\>Unable to get device owner terminal.\\
GET\_VAX\_SYMBOL\_ERROR\>Unable to get value of VAX system symbol.\\
GET\_OWNER\_PID\_ERROR\>Unable to get device owner Process ID.\\
CANNOT\_ALLOC\_DEVICE\>Unable to allocate device.\\
DEVICE\_ALREADY\_ALLOC\>Device is already allocated.\\
\end{tabbing}
\end{enumerate}
This routine allocates a device to the current
process using the VAX/VMS device allocation system services. It defines
the logical name XDDEVICE which is translated by a subsequent call to XDDUNIT.
The device will be ``owned'' by that process until it is either deallocated
(XDDFREE) or the process terminates.

A child process may try to allocate a device that is owned by its
parent, in which case XDDALLOCATE will return DEVALLOC.  The child
process will then be able to access the device as if it were its own
except that it will not be able to deallocate it (XDDFREE).

XDDALLOCATE requires CMEXEC and WORLD privilege.
\newpage
\subsubsection{XDDCLOSE - Close Device}
\begin{tabbing}
status = \=zddclose( unit )\\
\>int  unit;\\
\end{tabbing}
STATUS = XDDCLOSE( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
\end{tabbing}
\end{enumerate}
This routine closes the IO channel to the display device which was opened
by XDDOPEN.
\newpage
\subsubsection{XDDCONFIGURE - Configure a Device}
\begin{tabbing}
status = \=zddconfigure( unit, config )\\
\>int  unit, config[4];\\
\end{tabbing}
STATUS = XDDCONFIGURE( UNIT, CONFIG )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item CONFIG:  input, integer, dimensioned (4)

Array defining the desired device configuration.  (See below for more
information.)
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
INVALID\_DEVICE\_REQ\>Invalid request for display device.\\
\end{tabbing}
\end{enumerate}
This routine sets display unit UNIT to a standard configuration
defined by CONFIG.  The following define the possible standard
configurations:
\begin{tabbing}
xxxxxxxxxxxxxxxxx:\=\kill
CONFIG(1) = -1\>Leave Item Unchanged\\
CONFIG(1) =  0\>Default\\
CONFIG(1) =  1\>Full Color Display\\
CONFIG(1) =  2\>Pseudo-Color Display\\
CONFIG(1) =  3\>Monochrome Display\\
\\
CONFIG(2) = -1\>Leave Item Unchanged\\
CONFIG(2) =  0\>Default\\
CONFIG(2) =  1\>$512 \times 512$   Image Memory Planes\\
CONFIG(2) =  2\>$1024 \times 1024$ Image Memory Planes\\
CONFIG(2) =  3\>$2048 \times 2048$ Image Memory Planes\\
\\
CONFIG(3) = -1\>Leave Item Unchanged\\
CONFIG(3) =  0\>Default\\
CONFIG(3) =  1\>$512 \times 512$   Video Output\\
CONFIG(3) =  2\>$1024 \times 1024$ Video Output\\
CONFIG(3) =  3\>$480 \times 640$   Video Output\\
\\
CONFIG(4) = -1\>Leave Item Unchanged\\
CONFIG(4) =  0\>Default\\
CONFIG(4) =  1\>$1 \times 1$ Aspect Ratio\\
CONFIG(4) =  2\>$4 \times 3$ Aspect Ratio\\
\end{tabbing}
If XDDCONFIGURE is not used to change the device configuration, the
configuration of the display device is undefined.  The application
program must then set the display device configuration and internal tables.
Not all display devices can be configured in all the above ways.

There are two things that must be considered when using XDDCONFIGURE to
set the video display mode.  The first is that the routine may not
necessarily set the display mode properly.  The display modes are defined
as follows:

Monochrome--All three look-up tables are connected to the same image
memory plane, and all have been set to the same values.

Pseudo-color--All three look-up tables are connected to the same image
memory plane, but are not set to the same values.

Full Color--The look-up tables are not connected to the same image memory
plane.

The XDDCONFIGURE routine will connect the look-up tables appropriately,
but will not write data to the look-up tables.  If you choose monochrome
mode, but have different LUTs, the actual display mode will be
pseudo-color.  Similarly, if you select pseudo-color mode, but have
identical LUTs, the actual display mode will be monochrome.

The second consideration is that the video display mode can be changed
without using XDDCONFIGURE.  An application program can change to any
of the display modes by using XDLCONNECT to re-connect the LUTs and by
using XDLWRITE or XDLRAMP to write data to the LUTs.  By connecting three
identical LUTs to the same image memory plane, the application can change
the mode from full color to monochrome without using XDDCONFIGURE.
Since XDDCONFIGURE was not used, the system still believes its mode to
be full color--a query to XDDINFO will return full color rather than
monochrome.  Under these circumstances, XDSMODE should be used instead
of XDDINFO, since XDSMODE checks the look-up table connections and
contents to determine the actual video display mode.
\newpage
\subsubsection{XDDFREE - Free (Deallocate) a Device}
\begin{tabbing}
status = \=zddfree( name )\\
\>char  *name;\\
\end{tabbing}
STATUS = XDDFREE( NAME )
\begin{enumerate}
\item NAME:  input, string

Name of the device to be deallocated.  This may be an actual device
name (EPA0), a generic device name (EP), or DEFAULT.  DEFAULT will try
to allocate the ``default'' device that is assigned to the terminal
currently in use.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
NO\_DEFAULT\_DEVICE\>No default device for this terminal.\\
NO\_OWNED\_GENERIC\_DEV\>Unable to find owned generic device.\\
NO\_SUCH\_DEVICE\>Unable to find device.\\
DELETE\_LNM\_ERROR\>Unable to delete logical name.\\
GET\_PID\_ERROR\>Unable to get Process ID.\\
GET\_OWNER\_NAME\_ERROR\>Unable to get device owner username.\\
GET\_OWNER\_TERM\_ERROR\>Unable to get device owner terminal.\\
GET\_VAX\_SYMBOL\_ERROR\>Unable to get value of VAX system symbol.\\
GET\_OWNER\_PID\_ERROR\>Unable to get device owner Process ID.\\
CANNOT\_DEALL\_DEVICE\>Unable to deallocate device.\\
\end{tabbing}
\end{enumerate}
After freeing, the display unit is available for use by other
users.  See XDDALLOCATE for more information on device allocation and
deallocation.

XDDFREE requires CMEXEC and WORLD privilege.
\newpage
\subsubsection{XDDINFO - Get Device Information}
\begin{tabbing}
status = \=zddinfo( unit, start, number, info )\\
\>int  unit, start, number, info[];\\
\end{tabbing}
STATUS = XDDINFO( UNIT, START, NUMBER, INFO )
\begin{enumerate}
\item UNIT:  input

Display device unit number.
\item START:  input, integer

Starting position of requested data in internal device information
table.
\item NUMBER:  input, integer

Number of words of information to be returned.
\item INFO:  output, integer, dimensioned (NUMBER)

Array containing the returned device information.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
INVALID\_INFO\_REQUEST\>Invalid request for information.\\
\end{tabbing}
\end{enumerate}
Returns the characteristics of a display device in the array INFO.
NUMBER words of the internal device configuration data starting at
position START within the configuration data array will be returned
in array INFO.  Appendix B contains a description of the data
returned in array INFO.

An alternative to this routine is the device status routines (XDS*).
These routines are functions which return the information directly,
rather than as a parameter.  Some of the information available in
the status routines is the number of lines in the display, number of
samples in the display, video display mode, zoom factor, etc.
\newpage
\subsubsection{XDDMOVE - Move Window Device}
\begin{tabbing}
status = \=zddmove( unit, xloc, yloc )\\
\>int  unit, xloc, yloc;\\
\end{tabbing}
STATUS = XDDMOVE( UNIT, XLOC, YLOC )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item XLOC:  input, integer

X screen coordinates of the new location.
\item YLOC:  input, integer

Y screen coordinates of the new location.
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
\end{tabbing}
\end{enumerate}
This routine moves a window device to the given X and Y coordinates.  The
routine is applicable only for devices which support X-Windows.
\newpage
\subsubsection{XDDNAME - Get Device Name}
\begin{tabbing}
status = \=zddname( unit, flag, name, maxlen, retlen )\\
\>int  unit, flag, maxlen, retlen;\\
\>char  *name;\\
\end{tabbing}
STATUS = XDDNAME( UNIT, FLAG, NAME, MAXLEN, RETLEN )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item FLAG:  input, logical

Determines which device name to return.
\item NAME:  output, string

String to receive the display device name.
\item MAXLEN:  input, integer

The maximum number of characters to be returned.  NAME is either
truncated or padded with blanks to MAXLEN characters.
\item RETLEN:  output, integer

The number of characters returned, excluding trailing blanks.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
INVALID\_ARGUMENT\>Invalid argument received.\\
\end{tabbing}
\end{enumerate}
This routine returns the name of the currently allocated display
device UNIT.  FLAG determines which name is returned in the string
NAME.  MAXLEN is the maximum number of characters to be returned in
NAME.  If MAXLEN is zero (0) and NAME has been passed as a character
string descriptor, then MAXLEN will default to the length of the
string taken from the descriptor.  NAME will either be truncated
or padded with blanks to MAXLEN characters.

The following defines the possible values of FLAG:
\begin{tabbing}
xxxxxxxxxxxxxxxxx:\=\kill
FLAG = 1\>Return physical device name (EPA1).\\
FLAG = 2\>Return device make/model name (DeAnza IP8500).\\
\end{tabbing}
\newpage
\subsubsection{XDDNAMEDUNIT - Get Device Unit Number}
\begin{tabbing}
status = \=zddnamedunit( unit, name )\\
\>int  *unit;\\
\>char  name[];\\
\end{tabbing}
STATUS = XDDNAMEDUNIT( UNIT, NAME )
\begin{enumerate}
\item UNIT:  output, integer

Display device unit number.
\item NAME:  input, string

Name of device being accessed.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
DEVICE\_NOT\_ALLOC\>Device is not allocated.\\
\end{tabbing}
\end{enumerate}
If the name is empty (NULL), then this routine performs the same
function as XDDUNIT--assigns the logical unit number to use in
all subsequent calls to VRDI routines.  If the name is a valid
device name and the device is allocated, then the unit number for
that device is returned.  Otherwise, an appropriate error status
is returned.
\newpage
\subsubsection{XDDOPCLS - Open or Iconify a Window Device}
\begin{tabbing}
status = \=zddopcls( unit, open )\\
\>int  unit, open;\\
\end{tabbing}
STATUS = XDDOPCLS( UNIT, OPEN )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item OPEN:  input, integer

Flag to determine whether to open or iconify the window.
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
\end{tabbing}
\end{enumerate}
This routine opens or iconifies a window device.  If the OPEN flag is TRUE,
then the window will be opened.  If it is FALSE, then the window is
iconified.  The routine is applicable only for devices which support X-Windows.
\newpage
\subsubsection{XDDOPEN - Open a Device}
\begin{tabbing}
status = \=zddopen( unit )\\
\>int  unit;\\
\end{tabbing}
STATUS = XDDOPEN( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_ALLOC\>Device is not allocated.\\
DEVICE\_ALREADY\_OPEN\>Device is already open.\\
\end{tabbing}
\end{enumerate}
Either this routine or XDDSMARTOPEN must be executed before any IO
to the display device is performed.  On the VAX system, it opens an
IO channel to the display device.  This routine always initializes the
DCB.  XDDSMARTOPEN will initialize the DCB if it has not previously
been initialized or if it is unable to access the shared memory.
\newpage
\subsubsection{XDDRESIZE - Resize a Window Device}
\begin{tabbing}
status = \=zddresize( unit, width, height )\\
\>int  unit, width, height;\\
\end{tabbing}
STATUS = XDDRESIZE( UNIT, WIDTH, HEIGHT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item WIDTH:  input, integer

Width of the window.
\item HEIGHT:  input, integer

Height of the window.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_ALLOC\>Device is not allocated.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
\end{tabbing}
\end{enumerate}
This routine resizes a window device to the given width and height.  The
routine is applicable only for devices which support X-Windows.
\newpage
\subsubsection{XDDSMARTOPEN - Open a Device}
\begin{tabbing}
status = \=zddsmartopen( unit )\\
\>int  unit;\\
\end{tabbing}
STATUS = XDDSMARTOPEN( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_ALLOC\>Device is not allocated.\\
DEVICE\_ALREADY\_OPEN\>Device is already open.\\
\end{tabbing}
\end{enumerate}
Either this routine or XDDOPEN must be executed before any IO to
the display device is performed.  On the VAX system, it opens an IO
channel to the display device.  XDDOPEN always initializes the
DCB.  This routine will not initialize the DCB if it has already
been initialized and if the shared memory can be accessed.  If
either of these conditions is not met, then the DCB will be
initialized.
\newpage
\subsubsection{XDDUNIT - Assign Device Unit number}
\begin{tabbing}
status = \=zddunit( unit )\\
\>int  *unit;\\
\end{tabbing}
STATUS = XDDUNIT( UNIT )
\begin{enumerate}
\item UNIT:  output, integer

Display device unit number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
TRANS\_LNM\_ERROR\>Unable to translate logical name.\\
DEVICE\_NOT\_ALLOC\>Device is not allocated.\\
\end{tabbing}
\end{enumerate}
Translates the logical name XDDEVICE defined by XDDALLOCATE
and assigns the logical unit number to use in all subsequent calls
to VRDI routines.
\newpage
\subsubsection{XDDUNITNAMES - Get Device Names}
\begin{tabbing}
status = \=zddunitnames( ndev, len, devices )\\
\>int  *ndev, len;\\
\>char  *devices;\\
\end{tabbing}
STATUS = XDDUNITNAMES( NDEV, LEN, DEVICES )
\begin{enumerate}
\item NDEV:  output, integer

The number of devices allocated.
\item LEN:  input, integer

Maximum number of characters per device name to be returned.  Each
string in NAME is either truncated or padded with blanks to LEN
characters.
\item DEVICES:  output, string

String array to receive the display device names (see below for
further details).
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
INVALID\_ARGUMENT\>Invalid argument received.\\
\end{tabbing}
\end{enumerate}
This routine returns the names of all the currently allocated display
devices.  The names are returned either in an array of null-terminated
strings or a FORTRAN string array descriptor.  This is the only VRDI
routine which uses an array of strings.

If the C interface is used, the array may be passed as the parameter,
or the address of the first string in the array may be passed as the
parameter.

If the FORTRAN string array descriptor is used, the number of strings
and the length of each string is determined by the descriptor.  The
strings are either truncated or padded with blanks to the length
defined in the descriptor.
\newpage
\subsection{Error Handling Routines}
\subsubsection{XDEACTION - Set Error Action}
\begin{tabbing}
status = \=zdeaction( warning, error, fatal )\\
\>int  warning, error, fatal;\\
\end{tabbing}
STATUS = XDEACTION( WARNING, ERROR, FATAL )
\begin{enumerate}
\item WARNING:  input, integer

Action to perform for errors in the WARNING catagory.
\item ERROR:  input, integer

Action to perform for errors in the ERROR catagory.
\item FATAL:  input, integer

Action to perform for errors in the FATAL catagory.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
INVALID\_WARNING\_ACTION\>Invalid WARNING action.\\
INVALID\_ERROR\_ACTION\>Invalid ERROR action.\\
INVALID\_FATAL\_ACTION\>Invalid FATAL action.\\
\end{tabbing}
\end{enumerate}
This routine sets the action to performs for each of the error code
categories:  WARNING, ERROR and FATAL.  The actions that may be
performed are:
\begin{tabbing}
xxxxx\=xxxxxxxxx\=\kill
\>1\>Just return status code\\
\>2\>Issue system message and return status code\\
\>3\>Issue system message and abort\\
\end{tabbing}
\newpage
\subsubsection{XDELEVEL - Get Error Severity Level}
\begin{tabbing}
status = \=zdelevel( code )\\
\>int  code;\\
\end{tabbing}
STATUS = XDELEVEL( CODE )
\begin{enumerate}
\item CODE:  input, integer

A VRDI error code.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
XD\_UNKNOWN\>Unknown error status code.\\
XD\_NO\_ERROR\>Error status code is SUCCESS.\\
XD\_WARNING\>Error severity level is WARNING.\\
XD\_ERROR\>Error severity level is ERROR.\\
XD\_FATAL\>Error severity level is FATAL.\\
\end{tabbing}
\end{enumerate}
This routine displays the severity level associated with the
given error code.  See appendix A for a list of error codes and
system error messages.  If the program utilizes the C interface,
you should use the following include statements:

\#include XDMAININC\\
\#include xderrors\\

These will insure that you are using the proper values when interpreting
the returned values from this function (i.e., XD\_NO\_ERROR, XD\_WARNING,
etc.).
\newpage
\subsubsection{XDESIGNAL - Display a System Error Message}
\begin{tabbing}
status = \=zdesignal( code )\\
\>int  code;\\
\end{tabbing}
STATUS = XDESIGNAL( CODE )
\begin{enumerate}
\item CODE:  input, integer

A VRDI error code.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
\end{tabbing}
\end{enumerate}
This routine displays the system error message associated with the
given error code.  See appendix A for a list of error codes and
system error messages.
\newpage
\subsection{Flag Routines}
The inter-process communication flags are set automatically by the
VRDI routines whenever a change occurs.  For example, the device
configuration flag is set any time a VRDI routine is called that
changes the configuration of the device (e.g., XDDCONFIGURE).  The
flags are automatically cleared whenever they are checked.

There is more than one group of flags available.  Group 0 is the default,
and is reserved, by convention, for the application.  Group 1 is
reserved, by convention, for VIDS.  Other groups may be used via the
XDFREGISTER routine.

When a VRDI routine sets a flag, it sets the flag for all groups except
the current one.  For example, an application calls XDDCONFIGURE.
XDDCONFIGURE sets the ``configuration changed'' flag for all groups
except group 0, the application group.  This notifies the other groups
(e.g., VIDS) that an application has changed the device configuration.

All the flag routines return the result as the function return for
convenience.  There is no status return, as there are only a few possible
errors and no hardware errors.  If a bad unit or image plane number is
given, the result is simply returned as FALSE.
\newpage
\subsubsection{XDFCONFIG - Check Device Configuration Flag}
\begin{tabbing}
flag = \=zdfconfig( unit )\\
\>int  unit;\\
\end{tabbing}
FLAG = XDFCONFIG( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item FLAG:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
TRUE\>Device configuration has changed.\\
FALSE\>Device configuration has not changed.\\
\end{tabbing}
\end{enumerate}
Determines whether another application has changed the device configuration
since the last call to this function.  Device configuration changes include:

1.  Video display changes, e.g., full color, pseudo-color,
monochrome (via XDDCONFIGURE or XDDOPEN).

2.  Image memory plane or video display sizes, e.g., $512 \times 512$,
$1024 \times 1024$ (via XDDCONFIGURE or XDDOPEN).

3.  Aspect ratio changes, e.g., $1 \times 1$, $4 \times 3$ (via XDDCONFIGURE
or XDDOPEN).

4.  Look-Up Table connection changes (via XDDCONFIGURE or XDLCONNECT).

5.  Graphics plane connection changes (via XDGCONNECT).

This flag is not set if the display configuration is changed using XDLCONNECT
(e.g., connecting all three look-up tables to the same image memory plane
will change the display mode from full color to monochrome or pseudo-color).
Under these conditions, XDSMODE should be used to determine if the video display
mode has changed.
\newpage
\subsubsection{XDFGLUT - Check Graphics Look-Up Table Flag}
\begin{tabbing}
flag = \=zdfglut( unit )\\
\>int  unit;\\
\end{tabbing}
FLAG = XDFGLUT( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item FLAG:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
TRUE\>Graphics Look-Up Table has changed.\\
FALSE\>Graphics Look-Up Table has not changed.\\
\end{tabbing}
\end{enumerate}
Determines whether another application has changed the Graphics Look-Up
Table since the last call to this function.  Changes to the Graphics Look-Up
Table include:

1.  Changing the section of the look-up table used (via XDDOPEN or XDGCONNECT).

2.  Changing the bypass status of the look-up table (via XDDOPEN or XDGCONNECT)

3.  Modifying the table itself (via XDGLCONSTANT, XDGLINIT, or XDGLWRITE).
\newpage
\subsubsection{XDFIMAGE - Check Image Memory Plane Flag}
\begin{tabbing}
flag = \=zdfimage( unit, imp )\\
\>int  unit, imp;\\
\end{tabbing}
FLAG = XDFIMAGE( UNIT, IMP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item FLAG:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
TRUE\>Image Memory Plane has changed.\\
FALSE\>Image Memory Plane has not changed.\\
\end{tabbing}
\end{enumerate}
Determines whether another application has changed the given image memory
plane since the last call to this function.  The flag for IMP=0 is set
if any image memory plane has changed since the last IMP=0 call.  Image
memory plane changes include:

1.  Writing text to the image plane (via XDTTEXT).

2.  Rotating the image plane (via XDIROTATE).

3.  Writing data to the image plane (via XDIAREAFILL, XDIAWWRITE,
XDICIRCLE, XDIFILL, XDIIARITHMETIC, XDIICOPY, XDIILOGICAL,
XDIISHIFT, XDILINEWRITE, XDIMAWWRITE, XDIMCIRCLE, XDIMFILL,
XDIMLINEWRITE, XDIMPIXELWRITE, XDIMPOLYLINE, XDIPIXELWRITE, or
XDIPOLYLINE.

This flag is not set when the image plane zoom factor is set
(XDIZOOM), when the image plane access window is changed (XDIAWSET),
or when the image plane display window location is changed (XDIDWSET),
since these changes do not affect the values stored in image plane
memory.  To test for these changes, the application should use
XDSZOOM, XDIAWLOCATION, and XDIDWLOCATION.
\newpage
\subsubsection{XDFLUT - Check Look-Up Table Flag}
\begin{tabbing}
flag = \=zdflut( unit, lut )\\
\>int  unit, lut;\\
\end{tabbing}
FLAG = XDFLUT( UNIT, LUT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item LUT:  input, integer

Look-up table number.
\item FLAG:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
TRUE\>Look-Up Table has changed.\\
FALSE\>Look-Up Table has not changed.\\
\end{tabbing}
\end{enumerate}
Determines whether another application has changed the given look-up
table since the last call to this function.  The flag for LUT=0
is set if any look-up table has changed since the last LUT=0 call.
Changes to the look-up table can include:

1.  Changing the section of the look-up table used (via XDDCONFIGURE, XDDOPEN,
or XDLCONNECT).

2.  Changing the bypass status of the look-up table (via XDDCONFIGURE, XDDOPEN,
or XDLCONNECT).

3.  Modifying the table itself (via XDLRAMP, or XDLWRITE).
\newpage
\subsubsection{XDFREGISTER - Select Group of Flags}
\begin{tabbing}
zdfregister( group )\\
int  group;\\
\end{tabbing}
XDFREGISTER( GROUP )
\begin{enumerate}
\item GROUP:  input, integer

Group of flags.
\end{enumerate}
Selects which group of flags to use for this process.  GROUP=0 is the
default and is used by the application, so it does not need to call
this routine.  GROUP=1 is reserved, by convention, for VIDS.  Other groups
(up to 32) may be used.  If an invalid group number is input, the group
number is set to 0.  The group number is stored internally as a global
variable which is only visible to the current process.  The same group
is used for all units.  This routine only needs to be called once in the
lifetime of the program.  This routine, if called, must be called before
any devices are opened (via XDDOPEN or XDDSMARTOPEN).
\newpage
\subsection{Graphics Overlay Plane Routines}
The use of graphics overlay is logically the same as using any other
image memory plane for video output.  The pixel values output by the
graphics overlay hardware replace pixels output from the standard
outputs when graphics overlay is on.  The graphics overlay LUT
logically consists of three standard size LUT tables, one for red,
green and blue (color only).  Some devices, however, do not support
full-size overlay LUTs.  In these cases, the color choices available
on the graphics overlay plane are, naturally, limited.
\newpage
\subsubsection{XDGCOLOR - Get DN Value Corresponding to Named Color}
\begin{tabbing}
dn = \=zdgcolor( unit, name )\\
\>int  unit;\\
\>char  name[];\\
\end{tabbing}
DN = XDGCOLOR( UNIT, NAME )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item NAME:  input, string

String of one or more color names.
\item DN:  output, integer
\end{enumerate}
Returns the DN value to use on the graphics plane to get the named
color.  The NAME parameter is a string consisting of one or more
color names separated by one or more commas or spaces or both.  The
valid colors are ``red,'' ``green,'' ``blue,'' ``white,'' ``yellow,''
``magenta,'' ``cyan,'' and ``black.''  If only one name is given, that
color is returned.  If more than one name is given, the color
returned is a blend of the colors given.  Since some devices do not
support full-size overlay LUTs, the DN value returned may not yield
the exact color requested.  If an error is encountered in the string
name or any other error occurs, a 0 is returned for the DN as an
error indication (0 corresponds to ``transparent'' on all the overlay LUTs).
\newpage
\subsubsection{XDGCONNECT - Connect Image Plane to Graphics LUT}
\begin{tabbing}
status = \=zdgconnect( unit, imp, section, bypass )\\
\>int  unit, imp, section, bypass;\\
\end{tabbing}
STATUS = XDGCONNECT( UNIT, IMP, SECTION, BYPASS )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to connect to graphics LUT.
\item SECTION:  input, integer

Number of the graphics LUT section to be used.
\item BYPASS:  input, logical

Flag indicating whether or not to use the LUT.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
OVERLAY\_NOT\_AVAILABLE\>Graphics overlay is not available.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
CANNOT\_CONNECT\_LUT\>Cannot make IMP/LUT connection.\\
CANNOT\_BYPASS\_LUT\>Cannot bypass the look-up tables.\\
\end{tabbing}
\end{enumerate}
Connects the image memory plane to the graphics overlay plane LUT
section.  This has the effect of making the image memory plane the
graphics overlay plane.  If BYPASS is TRUE, pixels will not be
converted by the LUT before output.  If BYPASS is FALSE, pixels will
be converted by the LUT before output.
\newpage
\subsubsection{XDGLCONSTANT - Set Graphics Look-up Table to a Constant}
\begin{tabbing}
status = \=zdglconstant( unit, section, red, green, blue )\\
\>int  unit, section, red, green, blue;\\
\end{tabbing}
STATUS = XDGLCONSTANT(UNIT, SECTION, RED, GREEN, BLUE)
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item SECTION:  input, integer

Graphics LUT section to be written.
\item RED:  input, integer

Red intensity value.
\item GREEN:  input, integer

Green intensity value.
\item BLUE:  input, integer

Blue intensity value.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
OVERLAY\_NOT\_AVAILABLE\>Graphics overlay is not available.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
\end{tabbing}
\end{enumerate}
Set the graphics overlay LUT section to constant RED, GREEN and BLUE
values.  This routine is not recommended because it sets every pixel
in the graphics image plane to the same color.  The XDGLINIT routine,
which sets up an optimum graphics overlay LUT, is recommended instead.
\newpage
\subsubsection{XDGLINIT - Initialize Graphics Look-up Table}
\begin{tabbing}
status = \=zdglinit( unit, section )\\
\>int  unit, section;\\
\end{tabbing}
STATUS = XDGLINIT( UNIT, SECTION )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item SECTION:  input, integer

graphics LUT section to be written.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
OVERLAY\_NOT\_AVAILABLE\>Graphics overlay is not available.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
\end{tabbing}
\end{enumerate}
Initializes the graphics look-up table for the given section.
The table is set up to allow the maximum number of colors that
will easily fit on the display device.
\newpage
\subsubsection{XDGLREAD - Read Graphics Look-up Table}
\begin{tabbing}
status = \=zdglread( unit, section, red, green, blue )\\
\>int  unit, section, *red, *green, *blue;\\
\end{tabbing}
STATUS = XDGLREAD( UNIT, SECTION, RED, GREEN, BLUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item SECTION:  input, integer

Graphics LUT section to be read.
\item RED:  output, integer, dimensioned (256)

Array to receive Red LUT intensities.
\item GREEN:  output, integer, dimensioned (256)

Array to receive Green LUT intensities.
\item BLUE:  output, integer, dimensioned (256)

Array to receive Blue LUT intensities.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
OVERLAY\_NOT\_AVAILABLE\>Graphics overlay is not available.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
\end{tabbing}
\end{enumerate}
Reads the contents of the graphics overlay LUT section into the
arrays RED, GREEN and BLUE.  A zero for the section number will
mean the current section that is controlling the display.
\newpage
\subsubsection{XDGLWRITE - Write Graphics Look-up Table}
\begin{tabbing}
status = \=zdglwrite( unit, section, red, green, blue )\\
\>int  unit, section, *red, *green, *blue;\\
\end{tabbing}
STATUS = XDGLWRITE( UNIT, SECTION, RED, GREEN, BLUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item SECTION:  input, integer

graphics LUT section to be written.
\item RED:  input, integer, dimensioned (256)

Array containing Red intensity values.
\item GREEN:  input, integer, dimensioned (256)

Array containing Green intensity values.
\item BLUE:  input, integer, dimensioned (256)

Array containing Blue intensity values.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
OVERLAY\_NOT\_AVAILABLE\>Graphics overlay is not available.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
\end{tabbing}
\end{enumerate}
Writes the contents of the arrays RED, GREEN and BLUE into the
graphics overlay LUT section.  This routine is not recommended
because it overwrites the default graphics overlay LUT.  The
XDGLINIT routine, which sets up an optimum graphics overlay LUT,
is recommended instead.
\newpage
\subsubsection{XDGOFF - Turn Off the Graphics Overlay}
\begin{tabbing}
status = \=zdgoff( unit )\\
\>int  unit;\\
\end{tabbing}
STATUS = XDGOFF( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
OVERLAY\_NOT\_AVAILABLE\>Graphics overlay is not available.\\
\end{tabbing}
\end{enumerate}
Turns off the display of the graphics overlay plane.
\newpage
\subsubsection{XDGON - Turn On the Graphics Overlay}
\begin{tabbing}
status = \=zdgon( unit )\\
\>int  unit;\\
\end{tabbing}
STATUS = XDGON( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
OVERLAY\_NOT\_AVAILABLE\>Graphics overlay is not available.\\
\end{tabbing}
\end{enumerate}
Turns on the display of the graphics overlay plane.
\newpage
\subsubsection{XDGRGB - Get DN Value Corresponding to Given RGB Triplet}
\begin{tabbing}
dn = \=zdgrgb( unit, red, green, blue )\\
\>int  unit, red, green, blue;\\
\end{tabbing}
DN = XDGRGB( UNIT, RED, GREEN, BLUE)
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item RED:  input, integer

Red intensity value.
\item GREEN:  input, integer

Green intensity value.
\item BLUE:  input, integer

Blue intensity value.
\item DN:  output, integer
\end{enumerate}
Returns the DN value to use on the graphics plane to get as close as
possible to the given RGB triplet color.

The actual color displayed on the screen for the DN returned is the
color in the look-up table with the smallest Cartesian distance to
the given triplet.  The actual color may be different than the
requested one if the look-up table is not set up well or if there
are only a limited number of bits available in the overlay plane.

If an error is encountered due to a bad unit number or the RGB values
being outside the range (0,255), a 0 is returned for the DN (0
corresponds to ``transparent'' on all the overlay LUTs).
\newpage
\subsection{Image Memory Plane Routines}
\subsubsection{XDIAREAFILL - Fill an Area with a Constant Value}
\begin{tabbing}
status = \=zdiareafill( unit, imp, x, y, boundary, fill )\\
\>int  unit, imp, x, y;\\
\>unsigned char  boundary, fill;\\
\end{tabbing}
STATUS = XDIAREAFILL( UNIT, IMP, X, Y, BOUNDARY, FILL )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to write to.
\item X:  input, integer

Sample location within the area.
\item Y:  input, integer

Line location within the area.
\item BOUNDARY:  input, byte

Pixel value that defines the boundary to be filled.
\item FILL:  input, byte

Pixel value with which to fill the area.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
NOT\_IN\_ACCESS\_WINDOW\>Requested coordinates are not within the access window.\\
\end{tabbing}
\end{enumerate}
Fills a bounded closed area in the image memory plane of the display
device with the pixel value FILL.  The bounded area is determined by
the value BOUNDARY and the access window.  
\newpage
\subsubsection{XDIAWLOCATION - Get Access Window Location}
\begin{tabbing}
status = \=zdiawlocation( unit, imp, left, top, right, bottom )\\
\>int  unit, imp, *left, *top, *right, *bottom;\\
\end{tabbing}
STATUS = XDIAWLOCATION( UNIT, IMP ,LEFT, TOP, RIGHT, BOTTOM )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item LEFT:  output, integer

Starting sample location of the access window.
\item TOP:  output, integer

Starting line location of the access window.
\item RIGHT:  output, integer

Ending sample location of the access window.
\item BOTTOM:  output, integer

Ending sample location of the access window.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Returns the location of the access window associated with the image
memory plane of the display device.  The coordinates are image memory
plane coordinates.
\newpage
\subsubsection{XDIAWREAD - Read from Image Plane Access Window}
\begin{tabbing}
status = \=zdiawread( unit, imp, size, array )\\
\>int  unit, imp, size;\\
\>unsigned char  *array;\\
\end{tabbing}
STATUS = XDIAWREAD( UNIT, IMP, SIZE, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item SIZE:  input, integer

The size of the array to receive data from the access window.
\item ARRAY:  output, byte, dimensioned (SIZE)

Array to receive data from the access window.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
BAD\_PIXEL\_COUNT\>Pixel count was less than 1.\\
\end{tabbing}
\end{enumerate}
Reads SIZE pixels from the access window associated with the image
memory plane of the display device into the data array.  The read
starts in the upper left corner of the access window and continues
one line at a time from top to bottom.
\newpage
\subsubsection{XDIAWSET - Set Access Window Location}
\begin{tabbing}
status = \=zdiawset( unit, imp, left, top, right, bottom )\\
\>int  unit, imp, left, top, right, bottom;\\
\end{tabbing}
STATUS = XDIAWSET( UNIT, IMP, LEFT, TOP, RIGHT, BOTTOM )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item LEFT:  input, integer

New starting sample location for the access window.
\item TOP:  input, integer

New starting line location for the access window.
\item RIGHT:  input, integer

New ending sample location for the access window.
\item BOTTOM:  input, integer

New ending sample location for the access window.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
BAD\_ACCESS\_WINDOW\>Access window improperly defined.\\
AW\_NOT\_ON\_IMP\>Part of the access window is not on the image plane.\\
\end{tabbing}
\end{enumerate}
Sets the location of the access window associated with the image
memory plane of the display device.  The access window must be the
same as or within the image memory plane.  LEFT must be less than or
equal to RIGHT and TOP must be less than or equal to BOTTOM.  The
coordinates are image memory plane coordinates.
\newpage
\subsubsection{XDIAWWRITE - Write to Image Plane Access Window}
\begin{tabbing}
status = \=zdiawwrite( unit, imp, size, array )\\
\>int  unit, imp, size;\\
\>unsigned char  *array;\\
\end{tabbing}
STATUS = XDIAWWRITE( UNIT, IMP, SIZE, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane.
\item SIZE:  input, integer

Number of pixels to be written.
\item ARRAY:  input, byte, dimensioned (SIZE)

The array containing the data to be written to the access window.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
BAD\_PIXEL\_COUNT\>Pixel count was less than 1.\\
\end{tabbing}
\end{enumerate}
Writes SIZE pixels into the access window associated with the image
memory plane of the display device from the data array.  The write
starts in the upper left corner of the access window and continues
one line at a time from top to bottom.
\newpage
\subsubsection{XDICIRCLE - Draw a Circle}
\begin{tabbing}
status = \=zdicircle( unit, imp, x, y, radius, value )\\
\>int  unit, imp, x, y, radius, value;\\
\end{tabbing}
STATUS = XDICIRCLE( UNIT, IMP, X, Y, RADIUS, VALUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item X:  input, integer

Sample location of the center of the circle.
\item Y:  input, integer

Line location of the center of the circle.
\item RADIUS:  input, integer

The radius (in pixels) of the circle.
\item VALUE:  input, integer

The pixel value to be written into the image memory plane.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
INVALID\_RADIUS\>Invalid circle radius.\\
\end{tabbing}
\end{enumerate}
Draws a one pixel wide circle using the specified pixel value in the
image memory plane of the display device. Any part of the circle out of
the access window will not be drawn.
\newpage
\subsubsection{XDIDWLOCATION - Get Display Window Location}
\begin{tabbing}
status = \=zdidwlocation( unit, imp, left, top )\\
\>int  unit, imp, *left, *top;\\
\end{tabbing}
STATUS = XDIDWLOCATION( UNIT, IMP, LEFT, TOP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item LEFT:  output, integer

Sample location of the start of the display window.
\item TOP:  output, integer

Line location of the start of the display window.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Returns the upper left hand corner coordinates (LEFT, TOP) of the
display window associated with the image memory plane.  The
coordinates returned are raw (screen) coordinates.
\newpage
\subsubsection{XDIDWSET - Set Display Window Location}
\begin{tabbing}
status = \=zdidwset( unit, imp, left, top )\\
\>int  unit, imp, left, top;\\
\end{tabbing}
STATUS = XDIDWSET( UNIT, IMP, LEFT, TOP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item LEFT:  input, integer

New sample location of the start of the display window.
\item TOP:  input, integer

New line location of the start of the display window.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
BAD\_DISPLAY\_WINDOW\>Display window location is not allowed.\\
DEVICE\_CANNOT\_DO\_IT\>Device does not support the requested function.\\
MUST\_SET\_ALL\_DWS\>Display window of all IMPs have been set.\\
\end{tabbing}
\end{enumerate}
Sets the upper left corner of the display window associated with the
image memory plane.  If the display window cannot be set to the
requested location, no change is made and BADDW is returned.  If the
device requires that all display windows must be set at the same
time, all are set and the function returns MUST\_SET\_ALL\_DWS.  The
input coordinates must be raw (screen) coordinates.
\newpage
\subsubsection{XDIFILL - Fill Image Plane with a Constant}
\begin{tabbing}
status = \=zdifill( unit, imp, value )\\
\>int  unit, imp, value;\\
\end{tabbing}
STATUS = XDIFILL( UNIT, IMP, VALUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item VALUE:  input, integer

Pixel value to be written into the IMP.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Fills all the pixels in the access window associated with the image
memory plane with the specified pixel value.
\newpage
\subsubsection{XDIHISTOGRAM - Collect a Histogram for an Image Plane}
\begin{tabbing}
status = \=zdihistogram( unit, imp, mask, array )\\
\>int  unit, imp, mask, *array;\\
\end{tabbing}
STATUS = XDIHISTOGRAM( UNIT, IMP, MASK, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane of which to gather histogram.
\item MASK:  input, integer

Image memory plane to use as a mask.
\item ARRAY:  input, integer, dimensioned (256)

The collected histogram.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
MEMORY\_ERROR\>Memory allocation error.\\
AW\_SIZES\_DIFFERENT\>Access windows are different sizes.\\
\end{tabbing}
\end{enumerate}
Returns a histogram of the pixels in image memory plane IMP.  MASK is
a mask image memory plane number.  If MASK is zero all pixels within
the access window of IMP will be used to calculate the histogram.  If
MASK is greated than zero only pixels with a nonzero counterpart in
the MASK image memory plane will be used to calculate the histogram.
The pixel must also be within both access windows to be used in the
calculations.  If the access windows are not of the same size, the
largest rectangle that will fit within them will be used and the
function will return AW\_SIZES\_DIFFERENT.
\newpage
\subsubsection{XDIIARITHMETIC - Perform an Arithmetic Operation}
\begin{tabbing}
status = \=zdiiarithmetic( unit, op, imp1, imp2, imp3 )\\
\>int  unit, op, imp1, imp2, imp3;\\
\end{tabbing}
STATUS = XDIIARITHMETIC( UNIT, OP, IMP1, IMP2, IMP3 )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item OP:  input, integer
\begin{tabbing}
xxxxxxxxxxxxxxxxx:\=\kill
0\>Add\\
1\>Subtract\\
\end{tabbing}
\item IMP1:  input, integer

Source image memory plane.
\item IMP2:  input, integer

Source image memory plane.
\item IMP3:  input, integer

Destination image memory plane.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
UNDEFINED\_OPERATION\>Undefined arithmetic/logical operation.\\
MEMORY\_ERROR\>Memory allocation error.\\
AW\_SIZES\_DIFFERENT\>Access windows are different sizes.\\
\end{tabbing}
\end{enumerate}
Performs an arithmetic operation between image memory plane IMP1
and IMP2 of the display device.  The result is stored in IMP3.  The
operation will be performed on pixels that are within the access
windows of IMP1, IMP2 and IMP3.  That is, if the access windows are
not of the same size, the largest rectangle that will fit within all
access windows will be used and the function will return AW\_SIZES\_DIFFERENT.
\newpage
\subsubsection{XDIICOPY - Copy from One Image Plane to Another}
\begin{tabbing}
status = \=zdiicopy( unit, imp1, imp2 )\\
\>int  unit, imp1, imp2;\\
\end{tabbing}
STATUS = XDIICOPY( UNIT, IMP1, IMP2 )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP1:  input, integer

Source image memory plane.
\item IMP2:  input, integer

Destination image memory plane.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
MEMORY\_ERROR\>Memory allocation error.\\
AW\_SIZES\_DIFFERENT\>Access windows are different sizes.\\
\end{tabbing}
\end{enumerate}
Copies the contents of the access window of image memory plane IMP1
into the access window of image memory plane IMP2.  If the access
windows are not of the same size, then the largest rectangle that
will fit within both access windows will be used and the function will
return AW\_SIZES\_DIFFERENT.
\newpage
\subsubsection{XDIILOGICAL - Perform a Logical Operation}
\begin{tabbing}
status = \=zdiilogical( unit, op, imp1, imp2, imp3 )\\
\>int  unit, op, imp1, imp2, imp3;\\
\end{tabbing}
STATUS = XDIILOGICAL( UNIT, OP, IMP1, IMP2, IMP3 )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item OP:  input, integer
\begin{tabbing}
xxxxxxxxxxxxxxxxx:\=\kill
0\>AND\\
1\>OR\\
2\>Exclusive OR\\
3\>NOT AND\\
4\>NOT OR\\
5\>NOT Exclusive OR\\
\end{tabbing}
\item IMP1:  input, integer

Source image memory plane.
\item IMP2:  input, integer

Source image memory plane.
\item IMP3:  input, integer

Destination image memory plane.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
UNDEFINED\_OPERATION\>Undefined arithmetic/logical operation.\\
MEMORY\_ERROR\>Memory allocation error.\\
AW\_SIZES\_DIFFERENT\>Access windows are different sizes.\\
\end{tabbing}
\end{enumerate}
Performs a bitwise logical operation between image memory planes IMP1 and
IMP2 of the display device.  The results will be stored in IMP3.  OP
indicates the operation to be performed on pixels that are within the
access windows of IMP1, IMP2 and IMP3.  If the access windows are not of
the same size, the largest rectangle that will fit within each access
window is used and the function will return AW\_SIZES\_DIFFERENT.
\newpage
\subsubsection{XDIISHIFT - Logical Bit Shift of Image Plane}
\begin{tabbing}
status = \=zdiishift( unit, shift, imp1, imp2, wrap )\\
\>int  unit, shift, imp1, imp2, wrap;\\
\end{tabbing}
STATUS = XDIISHIFT( UNIT, SHIFT, IMP1, IMP2, WRAP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item SHIFT:  input, integer

Number of bits to shift.
\item IMP1:  input, integer

Source image memory plane.
\item IMP2:  input, integer

Destination image memory plane.
\item WRAP:  input, logical

Flag indicating whether bit wrap or zero fill will be used.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
MEMORY\_ERROR\>Memory allocation error.\\
AW\_SIZES\_DIFFERENT\>Access windows are different sizes.\\
\end{tabbing}
\end{enumerate}
Performs a logical shift operation on pixels in image memory plane
IMP1 of the display device.  The result is stored in IMP2.  If SHIFT
is positive the bits will be shifted left.  If SHIFT is negative the
bits will be shifted right.  The operation will only be performed on
pixels that are within the access windows.  If the access windows are
not of the same size, the largest rectangle that will fit within both
access windows will be used and the function will return AW\_SIZES\_DIFFERENT.
WRAP is a logical flag indicating bits will be wrapped around or zero filled.
TRUE is wrapped and FALSE is zero fill.
\newpage
\subsubsection{XDILINEREAD - Read a Line from an Image Plane}
\begin{tabbing}
status = \=zdilineread( unit, imp, x, y, size, array )\\
\>int  unit, imp, x, y, size;\\
\>unsigned char  *array;\\
\end{tabbing}
STATUS = XDILINEREAD( UNIT, IMP, X, Y, SIZE, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item X:  input, integer

Sample location to begin read.
\item Y:  input, integer

Line location to begin read.
\item SIZE:  input, integer

Number of pixels to be read.
\item ARRAY:  output, byte, dimensioned (SIZE)

Array to receive pixels.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Reads a line of pixels from the image memory plane into the array
LINE.  The read starts at location X, Y in the image plane.  SIZE
pixels are read.  Only pixels within the access window will be read.
\newpage
\subsubsection{XDILINEWRITE - Write a Line to an Image Plane }
\begin{tabbing}
status = \=zdilinewrite( unit, imp, x, y, size, array )\\
\>int  unit, imp, x, y, size;\\
\>unsigned char  *array;\\
\end{tabbing}
STATUS = XDILINEWRITE( UNIT, IMP, X, Y, SIZE, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to write to.
\item X:  input, integer

Sample location to start writing.
\item Y:  input, integer

Line location to start writing.
\item SIZE:  input, integer

Number of pixels to be written.
\item ARRAY:  input, byte, dimensioned (SIZE)

Array containing the pixels to be written.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Writes a line of pixels into the image memory plane from the array
LINE.  SIZE pixels will be written starting at location X, Y in the
image plane.  Pixels outside the access window are not
affected.
\newpage
\subsubsection{XDIMAWWRITE - XDIAWWRITE with Mask}
\begin{tabbing}
status = \=zdimawwrite( unit, imp, mask, size, array )\\
\>int  unit, imp;\\
\>unsigned char mask;\\
\>int  size;\\
\>unsigned char  *array;\\
\end{tabbing}
STATUS = XDIMAWWRITE( UNIT, IMP, MASK, SIZE, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane.
\item MASK:  input, byte

Pixel mask value.
\item SIZE:  input, integer

Nubmer of pixels to be written.
\item ARRAY:  input, byte, dimensioned (SIZE)

Array containing pixel values to be written.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
BAD\_PIXEL\_COUNT\>Pixel count was less than 1.\\
\end{tabbing}
\end{enumerate}
Performs the same operation as XDIAWWRITE except the pixel mask
determines which bits of the image plane are affected.
\newpage
\subsubsection{XDIMCIRCLE - XDICIRCLE with Mask}
\begin{tabbing}
status = \=zdimcircle( unit, imp, x, y, radius, mask, value )\\
\>int  unit, imp, x, y, radius;\\
\>unsigned char  mask;\\
\>int  value;\\
\end{tabbing}
STATUS = XDIMCIRCLE(UNIT, IMP, X, Y, RADIUS, MASK, VALUE)
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item X:  input, integer

Sample location of the center of the circle.
\item Y:  input, integer

Line location of the center of the circle.
\item RADIUS:  input, integer

The radius (in pixels) of the circle.
\item MASK:  input, byte

Pixel mask value.
\item VALUE:  input, integer

The pixel value to be written into the image memory plane.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
INVALID\_RADIUS\>Invalid circle radius.\\
\end{tabbing}
\end{enumerate}
Performs the same operation as XDICIRCLE except the pixel mask
determines which bits of the image plane are affected.
\newpage
\subsubsection{XDIMFILL - XDIFILL with Mask}
\begin{tabbing}
status = \=zdimfill( unit, imp, mask, value )\\
\>int  unit, imp;\\
\>unsigned char  mask, value;\\
\end{tabbing}
STATUS = XDIMFILL( UNIT, IMP, MASK, VALUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to be filled.
\item MASK:  input, byte

Pixel mask value.
\item VALUE:  input, byte

Pixel value to be written to the IMP.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
MEMORY\_ERROR\>Memory allocation error.\\
\end{tabbing}
\end{enumerate}
Performs the same operation as XDIFILL except the pixel mask
determines which bits of the image plane are affected.
\newpage
\subsubsection{XDIMLINEWRITE - XDILINEWRITE with Mask}
\begin{tabbing}
status = \=zdimlinewrite( unit, imp, x, y, mask, length, array )\\
\>int  unit, imp, x, y;\\
\>unsigned char  mask;\\
\>int  length;\\
\>unsigned char  *array;\\
\end{tabbing}
STATUS = XDIMLINEWRITE( UNIT, IMP, X, Y, MASK, LENGTH, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane.
\item X:  input, integer

Starting sample location of the write.
\item Y:  input, integer

Starting line location of the write.
\item MASK:  input, byte

Pixel mask value.
\item LENGTH:  input, integer

Number of pixels to be written.
\item ARRAY:  input, byte, dimensioned (LENGTH)

Array containing pixels to be written to the IMP.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
\end{tabbing}
\end{enumerate}
Performs the same operation as XDILINEWRITE except the pixel mask
determines which bits of the image plane are affected.
\newpage
\subsubsection{XDIMPIXELWRITE - Masked XDIPIXELWRITE}
\begin{tabbing}
status = \=zdimpixelwrite( unit, imp, x, y, mask, value )\\
\>int  unit, imp, x, y;\\
\>unsigned char  mask, value;\\
\end{tabbing}
STATUS = XDIMPIXELWRITE( UNIT, IMP, X, Y, MASK, VALUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to write to.
\item X:  input, integer

Sample location of the write.
\item Y:  input, integer

Line location of the write.
\item MASK:  input, byte

Pixel mask value.
\item VALUE:  input, byte

Pixel value to be written to the IMP.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
NOT\_IN\_ACCESS\_WINDOW\>Requested coordinates are not within the access window.\\
\end{tabbing}
\end{enumerate}
Performs the same operation as XDIPIXELWRITE except the pixel mask
determines which bits of the image plane are affected.
\newpage
\subsubsection{XDIMPOLYLINE - XDIPOLYLINE with Mask}
\begin{tabbing}
status = \=zdimpolyline( unit, imp, mask, value, npts, x, y )\\
\>int  unit, imp;\\
\>unsigned char  mask, value;\\
\>int  npts, *x, *y;\\
\end{tabbing}
STATUS = XDIMPOLYLINE( UNIT, IMP, MASK, VALUE, NPTS, X, Y )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane.
\item MASK:  input, byte

Pixel mask value.
\item VALUE:  input, byte

Pixel value to be written.
\item NPTS:  input, integer

Number of points in the X and Y arrays.
\item X:  input, integer, dimensioned (NPTS)

The sample coordinates of the points.
\item Y:  input, integer, dimensioned (NPTS)

The line coordinates of the points.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
BAD\_COORDINATE\_COUNT\>The number of coordinates is less than 2.\\
\end{tabbing}
\end{enumerate}
Performs the same operation as XDIPOLYLINE except the pixel mask
determines which bits of the image plane are affected.
\newpage
\subsubsection{XDIPIXELREAD - Read Pixel from Image Plane}
\begin{tabbing}
status = \=zdipixelread( unit, imp, x, y, value )\\
\>int  unit, imp, x, y;\\
\>unsigned char  *value;\\
\end{tabbing}
STATUS = XDIPIXELREAD( UNIT, IMP, X, Y, VALUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to read from.
\item X:  input, integer

Pixel sample location.
\item Y:  input, integer

Pixel line location.
\item VALUE:  output, byte

Returned value of the pixel at the point (X, Y).
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
NOT\_IN\_ACCESS\_WINDOW\>Requested coordinates are not within the access window.\\
\end{tabbing}
\end{enumerate}
Reads the pixel value at image memory coordinates X, Y in the image
memory plane.  If the pixel is within the access window the pixel
value will be returned in VALUE, otherwise VALUE will remain
unchanged.
\newpage
\subsubsection{XDIPIXELWRITE - Write a Pixel to an Image Plane}
\begin{tabbing}
status = \=zdipixelwrite( unit, imp, x, y, value )\\
\>int  unit, imp, x, y;\\
\>unsigned char  value;\\
\end{tabbing}
STATUS = XDIPIXELWRITE( UNIT, IMP, X, Y, VALUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to write to.
\item X:  input, integer

The pixel's sample location.
\item Y:  input, integer

The pixel's line location.
\item VALUE:  input, byte

Pixel value to write at (X, Y).
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
NOT\_IN\_ACCESS\_WINDOW\>Requested coordinates are not within the access window.\\
\end{tabbing}
\end{enumerate}
Sets the pixel at image coordinates X, Y (sample, line) in the image
plane to the specified value.  If the coordinates are outside the
access window the pixel will remain unchanged.
\newpage
\subsubsection{XDIPOLYLINE - Draw a Series of Vectors}
\begin{tabbing}
status = \=zdipolyline( unit, imp, value, npts, x, y )\\
\>int  unit, imp;\\
\>unsigned char  value;\\
\>int  npts, *x, *y;\\
\end{tabbing}
STATUS = XDIPOLYLINE( UNIT, IMP, VALUE, NPTS, X, Y )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane.
\item VALUE:  input, byte

Pixel value to be written.
\item NPTS:  input, integer

Number of points in the X and Y arrays.
\item X:  input, integer, dimensioned (NPTS)

The sample coordinates of the points.
\item Y:  input, integer, dimensioned (NPTS)

The line coordinates of the points.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
BAD\_COORDINATE\_COUNT\>The number of coordinates is less than 2.\\
\end{tabbing}
\end{enumerate}
Draws a series of vectors of the specified pixel value in the image
memory plane.  NPTS is the number of vector coordinate pairs in the
arrays X and Y.  NPTS must be greater than 1.  The first coordinates
are the starting position for drawing the vectors.  A vector is drawn
from this point to the second pair of coordinates; from the second to
the third; and so on.  Any part of a vector falling outside the
access window will not be drawn.  Anti-aliasing may or may not take
place.
\newpage
\subsubsection{XDIROTATE - Rotate an Image Plane}
\begin{tabbing}
status = \=zdirotate( unit, imp, angle )\\
\>int  unit, imp, angle;\\
\end{tabbing}
STATUS = XDIROTATE( UNIT, IMP, ANGLE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to be rotated.
\item ANGLE:  input, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
1\>180 degrees\\
2\>-90 degrees\\
3\>90 degrees\\
\end{tabbing}
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
INVALID\_AW\_ROTATION\>Invalid access window rotation angle.\\
MEMORY\_ERROR\>Memory allocation error.\\
AW\_NOT\_SQUARE\>Access window is not square.\\
\end{tabbing}
\end{enumerate}
Rotates the the pixels within the access window of the image memory
plane.  ANGLE is a flag indicating a rotation angle of 90, -90 or 180
degrees.  The access window must be square for this operation, if it
is not, the the largest square that fits within the access window will
be used and AWNOTSQ will be returned.
\newpage
\subsubsection{XDIZOOM - Set Zoom for an Image Plane}
\begin{tabbing}
status = \=zdizoom( unit, imp, zoom )\\
\>int  unit, imp, zoom;\\
\end{tabbing}
STATUS = XDIZOOM( UNIT, IMP, ZOOM )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane.
\item ZOOM:  input, integer

Zoom factor.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
CANNOT\_ZOOM\>Cannot zoom by the specified factor.\\
DEVICE\_CANNOT\_DO\_IT\>Device does not support the requested function.\\
MUST\_ZOOM\_ALL\>All images have been zoomed.\\
\end{tabbing}
\end{enumerate}
Sets the zoom factor of the 
specified IMP of the display device to ZOOM.  If the device does not
support hardware zoom by the requested factor, the current zoom
factor will not be changed.  If a device requires that all IMPs
must be zoomed together, all IMPs will be zoomed and
MUSTZOOM will be returned.
\newpage
\subsection{LUT Routines}
\subsubsection{XDLCONNECT - Connect Image Plane to Look-up Table}
\begin{tabbing}
status = \=zdlconnect( unit, imp, lut, section, bypass )\\
\>int  unit, imp, lut, section, bypass;\\
\end{tabbing}
STATUS = XDLCONNECT( UNIT, IMP, LUT, SECTION, BYPASS )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item LUT:  input, integer

Look-up table number.
\item SECTION:  input, integer

LUT section number.
\item BYPASS:  input, logical

Flag determining whether or not the LUT should be BYPASSED.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
NO\_SUCH\_LUT\>No such look-up table.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
CANNOT\_CONNECT\_LUT\>Cannot make IMP/LUT connection.\\
CANNOT\_BYPASS\_LUT\>Cannot bypass the look-up tables.\\
\end{tabbing}
\end{enumerate}
Connects the image memory plane to the output LUT section of the
display device.  If BYPASS is TRUE, pixels will not be converted by
the LUT before output.  If BYPASS is FALSE, pixels will be converted
by the LUT before output.
\newpage
\subsubsection{XDLRAMP - Set Look-up Table to a Linear Ramp}
\begin{tabbing}
status = \=zdlramp( unit, lut, section )\\
\>int  unit, lut, section;\\
\end{tabbing}
STATUS = XDLRAMP( UNIT, LUT, SECTION )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item LUT:  input, integer

Look-up table number.
\item SECTION:  input, integer

LUT section number.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_LUT\>No such look-up table.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
\end{tabbing}
\end{enumerate}
Sets the LUT section in the display device to a linear ramp.  Eight-bit
LUTs will be set to values 0 to 255.  LUTs with larger outputs
will be set to a ramp that has the largest possible value in the last
position and zero in the first.
\newpage
\subsubsection{XDLREAD - Read Look-up Table}
\begin{tabbing}
status = \=zdlread( unit, lut, section, array )\\
\>int  unit, lut, section, array[256];\\
\end{tabbing}
STATUS = XDLREAD( UNIT, LUT, SECTION, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item LUT:  input, integer

Look-up table number.
\item SECTION:  input, integer

LUT section number.
\item ARRAY:  output, integer, dimensioned (256)

The array to receive the data from the specified LUT section.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_LUT\>No such look-up table.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
\end{tabbing}
\end{enumerate}
Reads back the LUT section from the display device and places the
result in ARRAY.  If 0 is used for the section number, the routine
will use the current section, taking into account the bypass flag.
If the bypass flag is TRUE, a ramp is returned in ARRAY.  If the
bypass flag is FALSE, the LUT for the current section is returned
in ARRAY.
\newpage
\subsubsection{XDLWRITE - Write Look-up Table}
\begin{tabbing}
status = \=zdlwrite( unit, lut, section, array )\\
\>int  unit, lut, section, array[256];\\
\end{tabbing}
STATUS = XDLWRITE( UNIT, LUT, SECTION, ARRAY )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item LUT:  input, integer

Look-up table number.
\item SECTION:  input, integer

LUT section number.
\item ARRAY:  input, integer, dimensioned (256)

The array to be written to the specified LUT section.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_LUT\>No such look-up table.\\
NO\_SUCH\_LUT\_SECTION\>No such look-up table section.\\
\end{tabbing}
\end{enumerate}
Writes ARRAY to the LUT section of the display device.
\newpage
\subsection{Device Status Routines}
These routines all return information about the state of the display device.
Much of the information returned by these routines is also available through
other means, notably XDDINFO.  XDDINFO is still needed for many of the more
esoteric items.  Only the most commonly needed items are included in these
routines.

These routines do not return an error status, as the only possible errors
are an invalid unit number, an invalid look-up table number, or an invalid
image memory plane number.  Since the routines do not interface with the
hardware, no hardware error can occur.  If an error does occur, the
routines return a default value which should avoid crashing most calculations
(e.g., non-zero on a value that might be in the denominator).
\newpage
\subsubsection{XDSBYPASS - Get Look-Up Table Bypass Status}
\begin{tabbing}
bypass = \=zdsbypass( unit, lut )\\
\>int  unit, lut;\\
\end{tabbing}
BYPASS = XDSBYPASS( UNIT, LUT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item LUT:  input, integer

Look-up table number.
\item BYPASS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
TRUE\>Bypass is on; look-up table is not in use.\\
FALSE\>Bypass is off; look-up table is in use.\\
\end{tabbing}
\end{enumerate}
Given a look-up table number, returns TRUE (1) if the bypass is on (i.e.,
LUT not in use), and FALSE (0) if bypass is off (LUT in use).  Returns
FALSE (0) on error.  Not duplicated by any other routine.
\newpage
\subsubsection{XDSDWLINE - Get Upper Left Corner Line Number For Image Plane}
\begin{tabbing}
pantop = \=zdsdwline( unit, imp )\\
\>int  unit, imp;\\
\end{tabbing}
PANTOP = XDSDWLINE( UNIT, IMP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item PANTOP:  output, integer

Line number of the upper left corner of the display window.
\end{enumerate}
Returns the line number of the upper left corner of the display window
(pan) for the given image memory plane.  Returns 1 on error.  Duplicates
half of XDIDWLOCATION.
\newpage
\subsubsection{XDSDWSAMP - Get Upper Left Corner Sample Number For Image Plane}
\begin{tabbing}
panleft = \=zdsdwsamp( unit, imp )\\
\>int  unit, imp;\\
\end{tabbing}
PANLEFT = XDSDWSAMP( UNIT, IMP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item PANLEFT:  output, integer

Sample number of the upper left corner of the display window.
\end{enumerate}
Returns the sample number of the upper left corner of the display window
(pan) for the given image memory plane.  Returns 1 on error.  Duplicates
half of XDIDWLOCATION.
\newpage
\subsubsection{XDSGBYPASS - Get Graphics Look-Up Table Bypass Status}
\begin{tabbing}
bypass = \=zdsgbypass( unit )\\
\>int  unit;\\
\end{tabbing}
BYPASS = XDSGBYPASS( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item BYPASS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
TRUE\>Bypass is on; graphics look-up table is not in use.\\
FALSE\>Bypass is off; graphics look-up table is in use.\\
\end{tabbing}
\end{enumerate}
Returns TRUE if the graphics look-up table bypass is on (i.e.,
LUT not in use), and FALSE if the graphics look-up table bypass is
off (LUT in use).  Returns FALSE on error.  Not duplicated by any 
other routine.  Note that it is not clear just what bypassing the 
graphics look-up table means, since no devices currently support it.
\newpage
\subsubsection{XDSGRAPH - Get Image Plane Connected to the Graphics Plane}
\begin{tabbing}
imp = \=zdsgraph( unit )\\
\>int  unit;\\
\end{tabbing}
IMP = XDSGRAPH( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  output, integer

Image memory plane currently connected to the graphics plane.
\end{enumerate}
Returns the image memory plane that is currently connected to the graphics
plane.  Returns 1 on error.  Duplicates XDDINFO( 34 ).
\newpage
\subsubsection{XDSGSECTION - Get Section Number of the Graphics LUT in Use.}
\begin{tabbing}
sect = \=zdsgsection( unit )\\
\>int  unit;\\
\end{tabbing}
SECT = XDSGSECTION( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item SECT:  output, integer

Section of the graphics look-up table in use.
\end{enumerate}
Returns the section number of the graphics look-up table currently in use.
Returns 1 on error.  Duplicates XDDINFO( 35 ).
\newpage
\subsubsection{XDSIMP - Get Image Plane Number}
\begin{tabbing}
imp = \=zdsimp( unit, lut )\\
\>int  unit, lut;\\
\end{tabbing}
IMP = XDSIMP( UNIT, LUT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item LUT:  input, integer

Look-up table number.
\item IMP:  output, integer

Image memory plane number connected to the look-up table.
\end{enumerate}
Returns the image memory plane connected to the given look-up table.
Returns 1 on error.  Not duplicated by any other routine.
\newpage
\subsubsection{XDSMODE - Get Video Display Mode}
\begin{tabbing}
mode = \=zdsmode( unit )\\
\>int  unit;\\
\end{tabbing}
MODE = XDSMODE( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item MODE:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
1\>Full color.\\
2\>Pseudo-color.\\
3\>Monochrome.\\
\end{tabbing}
\end{enumerate}
Returns the video display mode of the device (monochrome,
pseudo-color, or full color).  Returns monochrome on error.
The values are the same as for
XDDINFO(10) or the first element in the XDDCONFIGURE array, but
this routine does not duplicate XDDINFO(10).  XDDINFO checks the
value set by the XDDCONFIGURE routine to determine the screen mode.
This value, however, may be incorrect if the application did not
use the XDDCONFIGURE routine to change the mode.  For example, if
an application uses the XDLCONNECT routine to connect all three
look-up tables to the same image plane, the mode becomes pseudo-color
or monochrome instead of full color.  The screen configuration
value is not updated, however, because XDDCONFIGURE was not used.

XDSMODE looks directly at the image plane/look-up table connections
to determine the screen mode.  If all three look-up tables are
connected to one image plane, and all the tables are identical,
the mode is monochrome.  If all three look-up tables are connected
to one image plane, but the tables are not identical, the mode is
pseudo-color.  If the look-up tables are connected to different
planes (in any combination), the mode is full color.

If the video display mode determined by XDSMODE does not match the
value set by XDDCONFIGURE, then the value is updated and the XDFCONFIG
flag is set to indicate that the display mode was changed.
\newpage
\subsubsection{XDSNL - Get Number of Lines in the Image Planes}
\begin{tabbing}
nl = \=zdsnl( unit )\\
\>int  unit;\\
\end{tabbing}
NL = XDSNL( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item NL:  output, integer

Number of lines in the image memory planes.
\end{enumerate}
Returns the number of lines in the image memory planes.  Returns -1 on
error.  Duplicates XDDINFO( 5 ).
\newpage
\subsubsection{XDSNS - Get Number Of Samples In The Image Planes}
\begin{tabbing}
ns = \=zdsns( unit )\\
\>int  unit;\\
\end{tabbing}
NS = XDSNS( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item NS:  output, integer

Number of samples in the image memory planes.
\end{enumerate}
Returns the number of samples in the image memory planes.  Returns -1 on
error.  Duplicates XDDINFO( 6 ).
\newpage
\subsubsection{XDSSECTION - Get Look-Up Table Section Number}
\begin{tabbing}
sect = \=zdssection( unit, lut )\\
\>int  unit, lut;\\
\end{tabbing}
SECT = XDSSECTION( UNIT, LUT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item LUT:  input, integer

Look-up table number.
\item SECT:  output, integer

Section number in use.
\end{enumerate}
Returns the section number in use for the given look-up table number.
Returns 1 on error.  Not duplicated by any other routine.
\newpage
\subsubsection{XDSVNL - Get Number Of Lines On Video Screen}
\begin{tabbing}
vnl = \=zdsvnl( unit )\\
\>int  unit;\\
\end{tabbing}
VNL = XDSVNL( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item VNL:  output, integer

Number of lines on the video screen.
\end{enumerate}
Returns the number of lines on the video screen.  Returns -1 on error.
Duplicates XDDINFO( 14 ).
\newpage
\subsubsection{XDSVNS - Get Number Of Samples On Video Screen}

Number of samples on the video screen.
\begin{tabbing}
vns = \=zdsvns( unit )\\
\>int  unit;\\
\end{tabbing}
VNS = XDSVNS( UNIT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item VNS:  output, integer
\end{enumerate}
Returns the number of samples on the video screen.  Returns -1 on error.
Duplicates XDDINFO( 15 ).
\newpage
\subsubsection{XDSZOOM - Get Hardware Zoom Factor For Image Plane}
\begin{tabbing}
zoom = \=zdszoom( unit, imp )\\
\>int  unit, imp;\\
\end{tabbing}
ZOOM = XDSZOOM( UNIT, IMP )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane number.
\item ZOOM:  output, integer

Zoom factor for the given image memory plane.
\end{enumerate}
Returns the hardware zoom factor for the given image memory plane.
Returns 1 on error.  Not duplicated by any other routine.
\newpage
\subsection{Text Generation Routines}
\subsubsection{XDTCOLOR - Set Font Color and Precision}
\begin{tabbing}
status = \=zdtcolor( color, prec )\\
\>unsigned char  color;\\
\>int  prec;\\
\end{tabbing}
STATUS = XDTCOLOR( COLOR, PREC )
\begin{enumerate}
\item COLOR:  input, byte

Pixel value to be used when drawing text.
\item PREC:  input, integer

The precision to be used when drawing text.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
INVALID\_TEXT\_PREC\>Invalid text precision.\\
\end{tabbing}
\end{enumerate}
Sets the pixel color value and the precision used to write text
strings.  The precision is an implementation-defined value indicating
how text is to be written (i.e. anti-aliasing).  The default
value, zero, for the precision should generally be used.
\newpage
\subsubsection{XDTFONT - Set Font Style}
\begin{tabbing}
status = \=zdtfont( font )\\
\>int  font;\\
\end{tabbing}
STATUS = XDTFONT( FONT )
\begin{enumerate}
\item FONT:  input, integer

Number of the font to be used when drawing text.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
NO\_SUCH\_FONT\>Unable to locate font description file.\\
FONT\_FILE\_READ\_ERROR\>Error reading font definition file.\\
BAD\_ASCII\_CODE\>Invalid ASCII character code encountered in font file.\\
BAD\_VECTOR\_COUNT\>Invalid vector count encountered in font file.\\
FONT\_TABLE\_OVERFLOW\>Internal font table overflow.\\
\end{tabbing}
\end{enumerate}
Reads a text font description file into an internal font table.  FONT
indicates which font type to read.  Zero (0) is the default font
type.  See appendices E and F for more information on font
description files.
\newpage
\subsubsection{XDTLENGTH - Get Length of a String}
\begin{tabbing}
status = \=zdtlength( length, nchars, text )\\
\>int  *length, nchars;\\
\>char  text[];\\
\end{tabbing}
STATUS = XDTLENGTH( LENGTH, NCHARS, TEXT )
\begin{enumerate}
\item LENGTH:  output, integer

The returned length, in pixels, of the string in TEXT as it would be
drawn.
\item NCHARS:  input, integer

The number of characters in TEXT.
\item TEXT:  input, string

The string of characters.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
INVALID\_CHAR\_COUNT\>Invalid character count.\\
\end{tabbing}
\end{enumerate}
Returns the length (in pixel coordinates) of the specified text
string.  If NCHARS is zero (0), TEXT must be either a character
string descriptor or a null terminated character array.
\newpage
\subsubsection{XDTMASK - Set Text Mask}
\begin{tabbing}
status = \=zdtmask( mask )\\
\>int  mask;\\
\end{tabbing}
STATUS = XDTMASK( MASK )
\begin{enumerate}
\item MASK:  input, byte

Pixel mask value.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
\end{tabbing}
\end{enumerate}
Sets the pixel mask value determining which bits of the image plane are
affected when text is written.
\newpage
\subsubsection{XDTROTATE - Set Font Rotation}
\begin{tabbing}
status = \=zdtrotate( angle )\\
\>float  angle;\\
\end{tabbing}
STATUS = XDTROTATE( ANGLE )
\begin{enumerate}
\item ANGLE:  input, real

Angle of rotation to be used when drawing text.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
\end{tabbing}
\end{enumerate}
Sets the angle above or below the X (horizontal) axis that text is to
be written.  The angle is measured in degrees with a positive angle
causing a rotation in the counter-clockwise direction.
\newpage
\subsubsection{XDTSIZE - Set Font Height and Scaling}
\begin{tabbing}
status = \=zdtsize( height, scale )\\
\>int  height;\\
\>float  scale;\\
\end{tabbing}
STATUS = XDTSIZE( HEIGHT, SCALE )
\begin{enumerate}
\item HEIGHT:  input, integer

The height in pixels to be used when drawing text.
\item SCALE:  input, real

The horizontal scaling factor (width/height) to be used when drawing
text.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
INVALID\_FONT\_HEIGHT\>Invalid font height.\\
INVALID\_FONT\_SCALE\>Invalid font horizontal scale factor.\\
\end{tabbing}
\end{enumerate}
Sets the height of the text in pixel coordinates (how many lines tall
is the text to be).  Also sets the horizontal scale factor (width to
height ratio) to be applied to the text.  The fonts are defined in a
machine independent coordinate system that must be scaled to fit the
display.
\newpage
\subsubsection{XDTTEXT - Write Text}
\begin{tabbing}
status = \=zdttext( unit, imp, x, y, loc, nchars, text )\\
\>int  unit, imp, x, y, loc, nchars;\\
\>char  text[];\\
\end{tabbing}
STATUS = XDTTEXT( UNIT, IMP, X, Y, LOC, NCHARS, TEXT )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item IMP:  input, integer

Image memory plane to write text.
\item X:  input, integer

Sample position of the text string ``origin''.
\item Y:  input, integer

Line position of the text string ``origin''.
\item LOC:  input, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
Indicates how the text is drawn relative to the ``origin''.\\
1\>X,Y is lower left corner of text string\\
2\>X,Y is bottom center of text string\\
3\>X,Y is lower right corner of text string\\
\end{tabbing}
\item NCHARS:  input, integer

The number of characters in the TEXT string.
\item TEXT:  input, string

The string containing the text to be drawn.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_IMP\>No such image memory plane.\\
INVALID\_FONT\_LOCATION\>Invalid font location.\\
INVALID\_CHAR\_COUNT\>Invalid character count.\\
\end{tabbing}
\end{enumerate}
Writes the text string into the image memory plane of the display
device.  LOC is a flag indicating how the text string is to be
written relative to the location X, Y (sample, line) in the image
memory plane.  NCHARS is the number of characters in the string TEXT
to be written; if NCHARS is zero, TEXT must be either a character
string descriptor or a null terminated character string.  The
coordinates X, Y must be inside the access window.  Any part of
the text string that falls outside the access window will not be
written into the image memory plane.
\newpage
\subsection{Interactive IO Device Routines}
In order to generalize the interface to interactive IO devices the
interface accesses generic devices such as knobs, tablets and
switches.  All interactive IO devices are made to fall under one or
more of these generic descriptions.  For example, a joystick may
appear to the system as a tablet with the pen always in proximity to
the tablet and the pen down.

Devices that return coordinates fall into 2 categories.  One returns
absolute coordinates such as a tablet.  The second returns relative
coordinates such as a joystick.  (Relative indicate a delta value
from the last value.) To determine what type of devices are available
and if it returns absolute or relative coordinates use XDDINFO.

Some 2D devices do not have a pen.  For example, joysticks,
pucks, etc.  In many cases these devices have switches which could be
substituted for a pen.  If a switch is used to simulate a pen the
number of the switch used can be obtained with XDDINFO.
If a switch is used to simulate the pen the switch value may
also be obtained from XDXSWITCH.  The switch number used to simulate
the pen is made available to the application programmer (through
XDDINFO) so that the user may be informed of which switch to use.

Many interactive IO devices return coordinates as well as switch
values.  In this case the device may be accessed by more that one
interface routine.  For example XDX2D and XDXSWITCH.

The following is a description of the information that may be
obtained about each device with XDDINFO (see appendices B and C for more
information):
\begin{tabbing}
xxxxxxxxxxxxxx:\=xxx\=xxxx\=\kill
Array
Position\>Description\\
\\
1\>Device Type\\
\>\>0 - no device available\\
\>\>2 - 2D device (tablet and pen)\\
\>\>4 - Switch device\\
\pagebreak 
2\>Type of Coordinates Returned\\
\>\>0 - device does not return coordinates\\
\>\>1 - returns absolute coordinates\\
\>\>2 - returns relative coordinates\\
\\ 
3\>Switch Simulating Pen\\
\>\>0 - Not a 2D device or no pen\\
\>\>\>used to simulate pen\\
\>\>N - Number of switch used to simulate pen\\
\\ 
4\>Switches Available\\
\>\>Number of switches available on device\\
\end{tabbing}
\newpage
\subsubsection{XDX2D - Get Two-Dimensional User Input}
\begin{tabbing}
status = \=zdx2d( unit, device, x, y, prox, pen )\\
\>int  unit, device, *x, *y, *prox, *pen;\\
\end{tabbing}
STATUS = XDX2D( UNIT, DEVICE, X, Y, PROX, PEN )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item DEVICE:  input, integer

Input device number.
\item X:  output, real

Returned X (sample) location normalized to between -1.0 and +1.0.
\item Y:  output, real

Returned Y (line) location normalized to between -1.0 and +1.0.
\item PROX:  output, logical

Flag indicating whether or not the ``pen'' is ``close'' to the ``tablet''.
\item PEN:  output, logical

Flag indicating whether or not the ``pen'' is depressed.
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_INPUT\_DEVICE\>No such input device.\\
INVALID\_DEVICE\_TYPE\>Invalid device type.\\
DEVICE\_CANNOT\_DO\_IT\>Device does not support the requested function.\\
\end{tabbing}
\end{enumerate}
Returns values from the interactive IO device connected to the
display device.  The DEVICE returns a 2 dimensional coordinate (X,
Y).  The model for this type of device is a tablet and pen.  The
returned values X and Y have been normalized to -1.0 to +1.0.  PROX
is a flag that indicates proximity (FALSE-out of proximity, TRUE-in
proximity).  If the device has no proximity detection the returned
value is always TRUE.  PEN is a flag indicating if the pen is up or
down (FALSE-up, TRUE-down).  If the device has no pen, or switch to
simulate a pen, the value returned is always TRUE.
\newpage
\subsubsection{XDXSWITCH - Get User Input from Switch Box}
\begin{tabbing}
status = \=zdxswitch( unit, device, switch, value )\\
\>int  unit device, switch, *value;\\
\end{tabbing}
STATUS = XDXSWITCH( UNIT, DEVICE, SWITCH, VALUE )
\begin{enumerate}
\item UNIT:  input, integer

Display device unit number.
\item DEVICE:  input, integer

Input device number.
\item SWITCH:  input, integer

Number of the switch on DEVICE to be read.
\item VALUE:  output, logical

Returned value of SWITCH (on or off).
\item STATUS:  output, integer
\begin{tabbing}
XXXXXXXXXXXXXXXXXXXXXX\=\kill
SUCCESS\\
UNIT\_OUT\_OF\_RANGE\>Unit number is out of range.\\
DEVICE\_NOT\_OPEN\>Device is not open.\\
DEVICE\_NOT\_ACTIVE\>Device is not active.\\
NO\_SUCH\_INPUT\_DEVICE\>No such input device.\\
NO\_SUCH\_SWITCH\>No such input switch.\\
DEVICE\_CANNOT\_DO\_IT\>Device does not support the requested function.\\
\end{tabbing}
\end{enumerate}
Returns a value from the interactive IO device connected to the
display device.  The model for this type of device is a switch box.
The returned values V indicate if the switch is off (FALSE) or on
(TRUE).  SWITCH indicates which switch to test.  SWITCH is one or
greater.
\cleardoublepage
\appendix
\section{VRDI Error Messages}
\subsection{Warning Messages}
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{Key}
&\multicolumn{1}{|c|}{Description}\\ \hline
AWDIFF & Access windows are different sizes\\
AWNOTSQ & Access window is not square\\
AWOFFIMP & Part of the access window is not\\
& on the image plane\\
CANTCNCT & Cannot make IMP/LUT connection\\
CANTPOSCUR & Unable to position cursor\\
CANTZOOM & Cannot zoom by the specified factor\\
DEVACTIVE & Device is already active\\
DEVALLOC & Device is already allocated\\
DEVCANTDO & Device does not support the\\
& requested function\\
DEVOPEN & Device is already open\\
FNCNOTIMP & Function not implemented\\
INVERRACT & Invalid ERROR action\\
INVFLTACT & Invalid FATAL action\\
INVWRNACT & Invalid WARNING action\\
MUSTSETDW & Display window of all images\\
& have been set\\
MUSTZOOM & All images have been zoomed\\
NOAUTO & Autotracking is not available\\
NOBYPASS & Cannot bypass the look-up tables\\
NOCURSFRM & No such cursor form\\
NOCURSRAT & No such cursor rate\\ 
\hline
\end{tabular}
\subsection{Error Messages}
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{Key}
&\multicolumn{1}{|c|}{Description}\\ \hline
AFGNOTACT & Alphanumeric font generator is not active\\
BADAW & Access window improperly defined\\
BADCOORCT & The number of coordinates is less than 2\\
BADDW & Display window location is not allowed\\
BADPIXCNT & Pixel count was less than 1\\
CANTALLSHM & Cannot allocate shared memory\\
CANTDETSHM & Cannot detach shared memory\\
CANTREMSHM & Cannot remove shared memory\\
DEVNOTACT & Device is not active\\
DEVNOTOPN & Device is not open\\
IMPSMALL & Image plane must be as large as output\\
INVARG & Invalid arguement received\\
INVAWROT & Invalid access window rotation angle\\
INVCHCNT & Invalid character count\\
INVCLR & Invalid color\\
INVCOORD & Invalid coordinates\\
INVCURSIZ & Invalid cursor size\\
INVDEVREQ & Invalid request for display device\\
INVDEVTYP & Invalid device type\\
INVFNTHGT & Invalid font height\\
INVFNTLOC & Invalid font location\\
INVFNTSC & Invalid font horizontal scale factor\\
INVIMPSIZ & Invalid image memory plane size\\
INVINFO & Invalid request for information\\
INVOUTSIZ & Invalid video output size\\
INVRADIUS & Invalid circle radius\\
INVTXTPRC & Invalid text precision\\
NOAFG & Alphanumeric font generator is not available\\
NOCURS & No such cursor\\
NOFONT & Unable to locate font description file\\
NOIMP & No such image memory plane\\
NOINPDEV & No such input device\\
NOKNOB & No such input `knob'\\
\hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{Key}
&\multicolumn{1}{|c|}{Description}\\ \hline
NOLUT & No such look-up table\\
NOLUTSECT & No such look-up table section\\
NOOVRLY & Graphics overlay is not available\\
NOSWITCH & No such input 'switch'\\
NOTINAW & Requested coordinates are not within\\
& the access window\\
NOTOWNER & Unable to deallocate device; this\\
& process does not own it\\
PRESETERR & Unable to reset peripheral controller\\
SHMACCVIOL & Shared memory id exists but operation\\
& permission denied\\
SHMINVLDSIZ & Shared memory size is not within\\
& system limits\\
SHMNOID & Shared memory identifier does not exist\\
SHMNOMEM & Shared memory exceeds available physical\\
& memory\\
SHMNOMOREIDS & Shared memory identifiers exceed system\\
& limit\\
UNDEFOP & Undefined arithmetic/logical operation\\
UNOUTRNG & Unit number is out of range\\
\hline
\end{tabular}
\subsection{Fatal Messages}
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{Key}
&\multicolumn{1}{|c|}{Description}\\ \hline
BADASCII & Invalid ASCII character code\\
& encountered in font file\\
BADVECCNT & Invalid vector count encountered\\
& in font file\\
CANTALLDEV & Unable to allocate device\\
CANTALLHI & Unable to allocate high resolution Deanza\\
CANTALLOW & Unable to allocate low resolution Deanza\\
CANTDALLDEV & Unable to deallocate device\\
CRELNMERR & Unable to create logical name\\
DEVFLERR & Unable to open device status file\\
DELNMERR & Unable to delete logical name\\
DEVNOTALL & Device is not allocated\\
DEVNOTAVL & Device is not available\\
DIBERROR & Error found in Device Information File,\\
& contact system manager\\
DIBOPEN & Device Information File open error\\
FNTEOF & Unexpected end-of-file in font definition\\
& file\\
FNTOPNERR & Error reading font definition file\\
FNTRDERR & Error reading font definition file\\
FNTTBLOVR & Internal font table overflow\\ 
GETERMERR & Unable to get device owner terminal\\
GETNAMERR & Unable to get device owner username\\
GETOPIDERR & Unable to get device owner Process ID\\
GETPIDERR & Unable to get Process ID\\
GETVAXERR & Unable to get value of VAX system symbol\\
MEMERR & Memory allocation error\\
NOAVLGDEV & Unable to find available generic device\\
NODEFDEV & No default device for this terminal\\
NOOWNGDEV & Unable to find owned generic device\\
NOSUCHDEV & Unable to find device\\
SRVNOTAVL & Server is not available for requested device\\
TRANLNMERR & Unable to translate logical name\\
\hline
\end{tabular}
\newpage
\subsection{VRDI Error Codes}
\begin{tabular}{|l|l|c|}
\hline
\multicolumn{1}{|c|}{Error Code}
&\multicolumn{1}{|c|}{Text Code}
&\multicolumn{1}{|c|}{Value}\\
\hline
SUCCESS & SUCCESS & 1\\
AFG\_NOT\_ACTIVE & AFGNOTACT & -65537\\
AFG\_NOT\_AVAILABLE & NOAFG & -65538\\
AW\_NOT\_ON\_IMP & AWOFFIMP & -65539\\
AW\_NOT\_SQUARE & AWNOTSQ & -65540\\
AW\_SIZES\_DIFFERENT & AWDIFF & -65541\\
BAD\_ACCESS\_WINDOW & BADAW & -65542\\
BAD\_ASCII\_CODE & BADASCII & -65543\\
BAD\_COORDINATE\_COUNT & BADCOORCT & -65544\\
BAD\_DISPLAY\_WINDOW & BADDW & -65545\\
BAD\_PIXEL\_COUNT & BADPIXCNT & -65546\\
BAD\_VECTOR\_COUNT & BADVECCNT & -65547\\
CANNOT\_ALLOC\_DEVICE & CANTALLDEV & -65604\\
CANNOT\_ALLOC\_HIRES & CANTALLHI & -65605\\
CANNOT\_ALLOC\_LORES & CANTALLOW & -65606\\
CANNOT\_BYPASS\_LUT & NOBYPASS & -65548\\
CANNOT\_CONNECT\_LUT & CANTCNCT & -65549\\
CANNOT\_DEALLOCATE & NOTOWNER & -65550\\
CANNOT\_DEALL\_DEVICE & CANTDALLDEV & -65614\\
CANNOT\_POS\_CURSOR & CANTPOSCUR & -65620\\
CANNOT\_RESET\_MPC & PRESETERR & -65619\\
CANNOT\_ZOOM & CANTZOOM & -65551\\
CREATE\_LNM\_ERROR & CRELNMERR & -65607\\
DELETE\_LNM\_ERROR & DELNMERR & -65608\\
DEVICE\_ALREADY\_ACTIVE & DEVACTIVE & -65552\\
DEVICE\_ALREADY\_ALLOC & DEVALLOC & -65553\\
DEVICE\_ALREADY\_OPEN & DEVOPEN & -65554\\
DEVICE\_CANNOT\_DO\_IT & DEVCANTDO & -65555\\
DEVICE\_FILE\_OPEN\_ERROR & DEVFLERR & -65621\\
DEVICE\_NOT\_ACTIVE & DEVNOTACT & -65556\\
DEVICE\_NOT\_ALLOC & DEVNOTALL & -65557\\
DEVICE\_NOT\_AVAIL & DEVNOTAVL & -65558\\
DEVICE\_NOT\_OPEN & DEVNOTOPN & -65559\\
DIB\_OPEN\_ERROR & DIBOPEN & -65598\\
\hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|l|l|c|}
\hline
\multicolumn{1}{|c|}{Error Code}
&\multicolumn{1}{|c|}{Text Code}
&\multicolumn{1}{|c|}{Value}\\
\hline
DIB\_FILE\_ERROR & DIBERROR & -65599\\
FONT\_FILE\_EOF & FNTEOF & -65560\\
FONT\_FILE\_OPEN\_ERROR & FNTOPNERR & -65561\\
FONT\_FILE\_READ\_ERROR & FNTRDERR & -65562\\
FONT\_TABLE\_OVERFLOW & FNTTBLOVR & -65563\\
FUNC\_NOT\_IMPLEMENTED & FNCNOTIMP & -65564\\
GET\_OWNER\_NAME\_ERROR & GETNAMERR & -65610\\
GET\_OWNER\_PID\_ERROR & GETOPIDERR & -65613\\
GET\_OWNER\_TERM\_ERROR & GETERMERR & -65611\\
GET\_PID\_ERROR & GETPIDERR & -65609\\
GET\_VAX\_SYMBOL\_ERROR & GETVAXERR & -65612\\
IMP\_TOO\_SMALL & IMPSMALL & -65565\\
INVALID\_ARGUMENT & INVARG & -65566\\
INVALID\_AW\_ROTATION & INVAWROT & -65567\\
INVALID\_CHAR\_COUNT & INVCHCNT & -65568\\
INVALID\_COLOR & INVCLR & -65632\\
INVALID\_COORDINATES & INVCOORD & -65569\\
INVALID\_CURSOR\_SIZE & INVCURSIZ & -65631\\
INVALID\_DEVICE\_REQ & INVDEVREQ & -65570\\
INVALID\_DEVICE\_TYPE & INVDEVTYP & -65571\\
INVALID\_ERROR\_ACTION & INVERRACT & -65616\\
INVALID\_FATAL\_ACTION & INVFTLACT & -65617\\
INVALID\_FONT\_HEIGHT & INVFNTHGT & -65572\\
INVALID\_FONT\_LOCATION & INVFNTLOC & -65573\\
INVALID\_FONT\_SCALE & INVFNTSC & -65578\\
INVALID\_IMP\_SIZE & INVIMPSIZ & -65574\\
INVALID\_INFO\_REQUEST & INVINFO & -65575\\
INVALID\_OUTPUT\_SIZE & INVOUTSIZ & -65576\\
INVALID\_RADIUS & INVRADIUS & -65577\\
INVALID\_TEXT\_PREC & INVTXTPRC & -65579\\
INVALID\_WARNING\_ACTION & INVWRNACT & -65615\\
MEMORY\_ERROR & MEMERR & -65580\\
MUST\_SET\_ALL\_DWS & MUSTSETDW & -65581\\
MUST\_ZOOM\_ALL & MUSTZOOM & -65582\\
\hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|l|l|c|}
\hline
\multicolumn{1}{|c|}{Error Code}
&\multicolumn{1}{|c|}{Text Code}
&\multicolumn{1}{|c|}{Value}\\
\hline
NOT\_IN\_ACCESS\_WINDOW & NOTINAW & -65583\\
NO\_AUTO\_TRACK & NOAUTO & -65584\\
NO\_AVAIL\_GENERIC\_DEV & NOAVLGDEV & -65601\\
NO\_DEFAULT\_DEVICE & NODEFDEV & -65602\\
NO\_OWNED\_GENERIC\_DEV & NOOWNGDEV & -65600\\
NO\_SUCH\_CURSOR & NOCURS & -65585\\
NO\_SUCH\_CURSOR\_FORM & NOCURSFRM & -65586\\
NO\_SUCH\_CURSOR\_RATE & NOCURSRAT & -65587\\
NO\_SUCH\_DEVICE & NOSUCHDEV & -65603\\
NO\_SUCH\_FONT & NOFONT & -65588\\
NO\_SUCH\_IMP & NOIMP & -65589\\
NO\_SUCH\_INPUT\_DEVICE & NOINPDEV & -65590\\
NO\_SUCH\_KNOB & NOKNOB & -65591\\
NO\_SUCH\_LUT & NOLUT & -65592\\
NO\_SUCH\_LUT\_SECTION & NOLUTSECT & -65593\\
NO\_SUCH\_SWITCH & NOSWITCH & -65594\\
OVERLAY\_NOT\_AVAILABLE & NOOVRLY & -65595\\
SERVER\_NOT\_AVAILABLE & SRVNOTAVL & -65622\\
SHMEM\_INVALID\_SIZE & SHMINVLDSIZ & -65623\\
SHMEM\_ACCESS\_VIOLATION & SHMACCVIOL & -65624\\
SHMEM\_NO\_SUCH\_ID & SHMNOID & -65625\\
SHMEM\_NO\_MORE\_IDS & SHMNOMOREIDS & -65626\\
SHMEM\_OUT\_OF\_MEMORY & SHMNOMEM & -65627\\
SHMEM\_CANNOT\_ALLOC & CANTALLSHM & -65628\\
SHMEM\_CANNOT\_REMOVE & CANTREMSHM & -65629\\
SHMEM\_CANNOT\_DETACH & CANTDETSHM & -65630\\
TRANS\_LNM\_ERROR & TRANLNMERR & -65618\\
UNDEFINED\_OPERATION & UNDEFOP & -65596\\
UNIT\_OUT\_OF\_RANGE & UNOUTRNG & -65597\\
XD\_UNKNOWN & & 0\\
XD\_NO\_ERROR & & 1\\
XD\_WARNING & & 2\\
XD\_ERROR & & 3\\
XD\_FATAL & & 4\\
\hline
\end{tabular}
\cleardoublepage
\section{XDDINFO Configuration Information}
\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Start}
&\multicolumn{1}{|c|}{Description}\\ \hline
1 & Device Type\\
2 & Reserved\\
3 & Number of video outputs  (LUT/DACs)\\
4 & Number of image memory planes\\
5 & Number of lines in image memory plane (IMP)\\
6 & Number of samples per line\\
7 & Hardware configurations available\\
& bit  0 -  $512 \times 512$  image memory planes available\\
& bit  1 - $1024 \times 1024$ image memory planes available\\
& bit  2 - $2048 \times 2048$ image memory planes available\\
& bit  3 - 7 reserved\\
& bit  8 -  $512 \times 512$  video output  (low res)\\
& bit  9 - $1024 \times 1024$ video output  (high res)\\
& bit 10 - 11 reserved\\
& bit 12 - $1 \times 1$ aspect ratio available\\
& bit 13 - $3 \times 4$ aspect ratio available\\
& bit 14 - 15 reserved\\
8 & Device Unit Number\\
9 & Display Mode Variable Valid (0-no,1-yes)\\
10 & Current D(1) configuration value\\
& 1 - full color\\
& 2 - pseudo-color\\
& 3 - monochrome\\
11 & Current D(2) configuration value\\
 & 1 - $512 \times 512$ IMPs\\
 & 2 - $1024 \times 1024$ IMPs\\
 & 3 - $2048 \times 2048$ IMPs\\ \hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Start}
&\multicolumn{1}{|c|}{Description}\\ \hline
12 & Current D(3) configuration value\\
 & 1 - $512 \times 512$ video output  (low res)\\
 & 2 - $1024 \times 1024$ video output  (high res)\\
 & 3 - $480 \times 640$ video output\\
13 & Current D(4) configuration value\\
 & 1 - $1 \times 1$ aspect ratio\\
 & 2 - $4 \times 3$ aspect ratio\\
14 & Video Lines\\
15 & Video Samples\\
16 & Reserved\\
17 & Reserved\\
18 & Reserved\\
19 & Reserved\\
20 & Each IMP has a separate display window (0-no,1-yes)\\
21 & Reserved\\
22 & Reserved\\
23 & Reserved\\
24 & Number of sections in image LUTs\\
25 & LUT may be bypassed  (0-no,1-yes)\\
26 & Largest value in LUT (8-bit DACs output 255)\\
27 & Each IMP has a separate zoom (0-no,1-yes)\\
28 & May connect IMP to LUT (0-no,1-yes)\\
29 & May zoom IMPs (0-no,1-yes)\\
30 & Display device has graphics overlay  (0-no,1-yes)\\
31 & Display graphics overlay on/off (0-off,1-on)\\
32 & IMPs can be connected to overlay LUT  (0-no,1-yes)\\
33 & Graphics overlay LUT may be bypassed (0-no,1-yes)\\
34 & IMP currently connected to graphics overlay LUT\\
35 & Graphics LUT section used (0-bypass,0-LUT section)\\
36 & Graphics overlay LUT characteristics code\\
 & 1 - has a separate graphics overlay LUT\\
 & 2 - graphics overlay LUT is the same as image LUTs\\
37 & Number of sections in graphics LUT\\ \hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Start}
&\multicolumn{1}{|c|}{Description}\\ \hline
38 & Maximum zoom factor\\
39 & Number of bits in overlay\\
40 & Overlay LUT bypassed (0-no,1-yes)\\
41 & Display device has an AFG  (0-no,1-yes)\\
42 & AFG on/off  (0-off,1-on)\\
43 & Number of lines of text in AFG\\
44 & Number of characters per line in AFG\\
45 & Number of AFG display types\\
46 & Default Overlay LUT Active (0-no,1-yes)\\
47 & Reserved\\
48 & Number of cursors\\
49 & Number of cursor types\\
50 & Number of cursor blink rates\\
51 & Autotrack available (0-no,1-yes)\\
52 & Autotrack device\\
53 & Autotrack cursor\\
54 & May color cursor\\
55 & Device has Processor (0-no,1-yes)\\
56 & Maximum cursor X size\\
57 & Maximum cursor Y size\\
58 & Reserved\\
59 & May Resize Cursor\\
60 & Number of interactive IO devices\\
61 & IO device 1 - device type\\
62 & IO device 1 - coordinates returned\\
63 & IO device 1 - pen simulation\\
64 & IO device 1 - number of switches\\ \hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Start}
&\multicolumn{1}{|c|}{Description}\\
\hline
65 & Reserved\\
66 & Reserved\\
67 & Reserved\\
68 & Reserved\\
69 & Reserved\\
70 & IO device 2 - device type\\
71 & IO device 2 - coordinates returned\\
72 & IO device 2 - pen simulation\\
73 & IO device 2 - number of switches\\ \hline
\end{tabular}
\cleardoublepage
\section{Notes on Supported Display Devices}
\subsection{Gould DeAnza IP-8500, Low Resolution}
\begin{tabular}{|l l|}
\hline
\multicolumn{2}{|c|}{Hardware Configurations}\\
\hline
Full color/Pseudo-color/Monochrome & \\
$512 \times 512$ Image Memory Planes & \\
Extended memory hardware allows $1024 \times 1024$ Image & \\
     Memory Planes on some devices & \\
$512 \times 512$ Video Output & \\
$1 \times 1$ Aspect Ratio & \\ 
\hline \hline 
\multicolumn{2}{|c|}{Image Planes}\\ \hline
Number of 8-bit IMPs & 4 \\
Number of lines in IMP & 512 or 1024\\
Number of samples per line & 512 or 1024\\
Each IMP has a separate display window & yes\\
May connect IMP to LUT & yes\\
May Zoom IMPs & yes\\
Each IMP has a separate zoom & yes\\
Maximum Zoom factor & 8\\
\hline \hline 
\multicolumn{2}{|c|}{Look-up Tables}\\ 
\hline
Number of LUTs & 3\\
Number of sections in image LUTs & 4\\
LUT may be bypassed & yes\\
Largest value in LUT & 255 (8-bit)\\
\hline \hline 
\multicolumn{2}{|c|}{Graphics Overlay}\\ 
\hline
Display device has graphics overlay & yes\\
IMPs can be connected to overlay LUT & yes\\
Graphics overlay LUT may be bypassed & no\\
Number of sections in graphics LUT & 1\\
Graphics overlay LUT characteristics & separate lut\\
& 8-bit\\
\hline \hline 
\multicolumn{2}{|c|}{Miscellaneous}\\ 
\hline
Display device has an AFG & no \\
Device has Processor & yes\\ \hline
\end{tabular}
\newpage
Gould DeAnza IP-8500 Low Resolution continued...

\begin{tabular}{|l l|}
\hline 
\multicolumn{2}{|c|}{Interactive IO Devices}\\ 
\hline
Number of interactive IO devices & 1\\
device type & 2d\\
coordinates returned & absolute\\
pen simulation & 1\\
number of switches & 6\\
\hline \hline 
\multicolumn{2}{|c|}{Cursors}\\ 
\hline
Number of cursors & 2\\
Number of cursor types & 8\\
Number of cursor blink rates & 16\\
Autotrack available & yes\\
Resizable cursor available & no\\
Cursor color may be changed & no\\
\hline \hline 
\multicolumn{2}{|c|}{Cursor Forms}\\
\hline
0 = default (same as 1) & \\
1 = 5 dots in a + shape & \\
2 = + shape & \\
3 = box with dot in center & \\
4 = + with three pixels at center missing & \\
(blinks to 5) & \\
5 = + formed with double lines and center missing & \\
(blink alternates with 4) & \\
6 = X shape & \\
7 = Very large box with large + inside & \\
8 = Full-screen two-pixel-wide crosshairs & \\ 
\hline \hline 
\multicolumn{2}{|c|}{Cursor Blink Rates}\\
\hline
0 = no blink & \\
1 = .26 sec (fastest) & \\
16 = 4.2 sec (slowest) & \\ \hline
\end{tabular}
\newpage
\subsection{Gould DeAnza IP-8500, High Resolution}
\begin{tabular}{|l l|}
\hline
\multicolumn{2}{|c|}{Hardware Configurations}\\
\hline
Full color/Pseudo-color/Monochrome & \\
$1024 \times 1024$, $2048 \times 2048$ Image Memory Planes & \\
$1024 \times 1024$ Video Output & \\
$1 \times 1$ Aspect Ratio & \\ 
\hline \hline 
\multicolumn{2}{|c|}{Image Planes}\\ \hline
Number of 8-bit IMPs & 4 \\
Number of lines in IMP & 1024,2048\\
Number of samples per line & 1024,2048\\
Each IMP has a separate display window & yes\\
May connect IMP to LUT & no\\
May Zoom IMPs & yes\\
Each IMP has a separate zoom & yes\\
Maximum Zoom factor & 8\\
\hline \hline 
\multicolumn{2}{|c|}{Look-up Tables}\\ 
\hline
Number of LUTs & 3\\
Number of sections in image LUTs & 4\\
LUT may be bypassed & yes\\
Largest value in LUT & 255 (8-bit)\\
\hline \hline 
\multicolumn{2}{|c|}{Graphics Overlay}\\ 
\hline
Display device has graphics overlay & yes\\
IMPs can be connected to overlay LUT & no\\
Graphics overlay LUT may be bypassed & no\\
Number of sections in graphics LUT & 1\\
Graphics overlay LUT characteristics & separate lut\\
& 8-bit\\
\hline \hline 
\multicolumn{2}{|c|}{Miscellaneous}\\ 
\hline
Display device has an AFG & no \\
Device has Processor & no\\ \hline
\end{tabular}
\newpage
Gould DeAnza IP-8500 High Resolution continued...\\
\begin{tabular}{|l l|}
\hline 
\multicolumn{2}{|c|}{Interactive IO Devices}\\ 
\hline
Number of interactive IO devices & 1\\
device type & 2d\\
coordinates returned & absolute\\
pen simulation & 1\\
number of switches & 6\\
\hline \hline 
\multicolumn{2}{|c|}{Cursors}\\ 
\hline
Number of cursors & 2\\
Number of cursor types & 6\\
Number of cursor blink rates & 16\\
Autotrack available & yes\\
Resizable cursor available & no\\
Cursor color may be changed & no\\
\hline \hline 
\multicolumn{2}{|c|}{Cursor Forms}\\
\hline
0 = small crosshairs & \\
1 = full-screen crosshairs & \\
2 = lightpen box (cursor 1) & \\
small crosshairs (cursor 2) & \\
3 = dashed small crosshairs & \\
4 = dashed full-screen crosshairs & \\
5 = dashed lightpen box (cursor 1) & \\
dashed small crosshairs (cursor 2) & \\
\hline \hline 
\multicolumn{2}{|c|}{Cursor Blink Rates}\\
\hline
0 = no blink & \\
1 = .26 sec (fastest) & \\
16 = 4.2 sec (slowest) & \\ \hline
\end{tabular}
\\
\\
\\
NOTE:  This device is not officially supported, as MIPL currently
does not have a device with which to test the routines.  However,
the code is available and should work.
\newpage
\subsection{Gould DeAnza IP-9000}
\begin{tabular}{|l l|}
\hline
\multicolumn{2}{|c|}{Hardware Configurations}\\
\hline
Full color/Pseudo-color/Monochrome & \\
$512 \times 512$,$1024 \times 1024$,$2048 \times 2048$ Image Memory Planes & \\
$512 \times 512$,$1024 \times 1024$ Video Output & \\

$1 \times 1$ Aspect Ratio & \\ 
\hline \hline 
\multicolumn{2}{|c|}{Image Planes}\\ \hline
Number of 8-bit IMPs & 4 \\
Number of lines in IMP & 512,1024,2048\\
Number of samples per line & 512,1024,2048\\
Each IMP has a separate display window & yes\\
May connect IMP to LUT & yes\\
May Zoom IMPs & yes\\
Each IMP has a separate zoom & yes\\
Maximum Zoom factor & 16\\
\hline \hline 
\multicolumn{2}{|c|}{Look-up Tables}\\ 
\hline
Number of LUTs & 3\\
Number of sections in image LUTs & 4\\
LUT may be bypassed & yes\\
Largest value in LUT & 255 (8-bit)\\
\hline \hline 
\multicolumn{2}{|c|}{Graphics Overlay}\\ 
\hline
Display device has graphics overlay & yes\\
IMPs can be connected to overlay LUT & yes\\
Graphics overlay LUT may be bypassed & no\\
Number of sections in graphics LUT & 1\\
Graphics overlay LUT characteristics & separate lut\\
& 8-bit\\
\hline \hline 
\multicolumn{2}{|c|}{Miscellaneous}\\ 
\hline
Display device has an AFG & no \\
Device has Processor & yes\\ \hline
\end{tabular}
\newpage
Gould DeAnza IP-9000 continued...

\begin{tabular}{|l l|}
\hline 
\multicolumn{2}{|c|}{Interactive IO Devices}\\ 
\hline
Number of interactive IO devices & 1\\
device type & 2d\\
coordinates returned & absolute\\
pen simulation & 1\\
number of switches & 6\\
\hline \hline 
\multicolumn{2}{|c|}{Cursors}\\ 
\hline
Number of cursors & 2\\
Number of cursor types & 8\\
Number of cursor blink rates & 16\\
Autotrack available & yes\\
Resizable cursor available & no\\
Cursor color may be changed & no\\
\hline \hline 
\multicolumn{2}{|c|}{Cursor Forms}\\
\hline
0 = default (same as 1) & \\
1 = 5 dots in a + shape & \\
2 = + shape & \\
3 = box with dot in center & \\
4 = + with three pixels at center missing & \\
(blinks to 5) & \\
5 = + formed with double lines and center missing & \\
(blink alternates with 4) & \\
6 = X shape & \\
7 = Very large box with large + inside & \\
8 = Full-screen two-pixel-wide crosshairs & \\ 
\hline \hline 
\multicolumn{2}{|c|}{Cursor Blink Rates}\\
\hline
0 = no blink & \\
1 = .26 sec (fastest) & \\
16 = 4.2 sec (slowest) & \\ \hline
\end{tabular}
\newpage
\subsection{International Imaging Systems IVAS}
\begin{tabular}{|l l|}
\hline
\multicolumn{2}{|c|}{Hardware Configurations}\\
\hline
Full color/Pseudo-color/Monochrome & \\
$1024 \times 1024$ Image Memory Planes & \\
$1024 \times 1024$ Video Output & \\
$1 \times 1$ Aspect Ratio & \\ 
\hline \hline 
\multicolumn{2}{|c|}{Image Planes}\\ \hline
Number of IMPs & 4 \\
Number of lines in IMP & 1024\\
Number of samples per line & 1024\\
Each IMP has a separate display window & no\\
May connect IMP to LUT & yes\\
May Zoom IMPs & yes\\
Each IMP has a separate zoom & no\\
Maximum Zoom factor & 16\\
\hline \hline 
\multicolumn{2}{|c|}{Look-up Tables}\\ 
\hline
Number of LUTs & 3\\
Number of sections in image LUTs & 1\\
LUT may be bypassed & no\\
Largest value in LUT & 255 (8-bit)\\
\hline \hline 
\multicolumn{2}{|c|}{Graphics Overlay}\\ 
\hline
Display device has graphics overlay & yes\\
IMPs can be connected to overlay LUT & no\\
Graphics overlay LUT may be bypassed & no\\
Number of sections in graphics LUT & 1\\
Graphics overlay LUT characteristics & separate lut\\
& 4 bit\\
\hline \hline 
\multicolumn{2}{|c|}{Miscellaneous}\\ 
\hline
Display device has an AFG & no \\
Device has Processor & no\\ \hline
\end{tabular}
\newpage
IIS IVAS continued...

\begin{tabular}{|l l|}
\hline 
\multicolumn{2}{|c|}{Interactive IO Devices}\\ 
\hline
Number of interactive IO devices & 2\\
device 1 type & 2d\\
coordinates returned & absolute\\
pen simulation & 1\\
number of switches & 3\\
device 2 type & switch\\
coordinates returned & none\\
pen simulation & 0\\
number of switches & 3\\
\hline \hline 
\multicolumn{2}{|c|}{Cursors}\\ 
\hline
Number of cursors & 1\\
Number of cursor types & 8\\
Number of cursor blink rates & 8\\
Autotrack available & yes\\
Resizable cursor available & yes\\
Maximum cursor size & $128 \times 128$\\
Cursor color may be changed & yes*\\
\hline \hline 
\multicolumn{2}{|c|}{Cursor Forms}\\
\hline
-1 = resizable box & \\
0 = default (same as 1) & \\
1 = + shape & \\
2 = formee cross & \\
3 = X shape & \\
4 = formeed X shape & \\
5 = box & \\
6 = diamond & \\
7 = arrow & \\
\hline \hline 
\multicolumn{2}{|c|}{Cursor Blink Rates}\\
\hline
0 = no blink & \\
1 = .13 sec &\\
2 = .20 sec &\\
3 = .26 sec &\\
4 = .33 sec &\\
5 = .40 sec &\\
6 = .46 sec &\\
7 = .53 sec &\\
\hline
\end{tabular}
\\
\\
*The IVAS only uses 12-bit values when selecting a cursor color, 4 bits
each for red, green, and blue values.
\newpage
\subsection{Ramtek RM-9460}
\begin{tabular}{|l l|}
\hline
\multicolumn{2}{|c|}{Hardware Configurations}\\
\hline
Pseudo-color/Monochrome & \\
$512 \times 512$ Image Memory Planes & \\
$640 \times 480$ Video Output & \\
$1 \times 1$ Aspect Ratio & \\ 
\hline \hline 
\multicolumn{2}{|c|}{Image Planes}\\ \hline
Number of 8-bit IMPs & 1 \\
Number of lines in IMP & 512\\
Number of samples per line & 640\\
May connect IMP to LUT & yes\\
May Zoom IMPs & yes\\
Maximum Zoom factor & 16\\
\hline \hline 
\multicolumn{2}{|c|}{Look-up Tables}\\ 
\hline
Number of LUTs & 3\\
Number of sections in image LUTs & 4\\
LUT may be bypassed & no\\
Largest value in LUT & 255 (8-bit)\\
\hline \hline 
\multicolumn{2}{|c|}{Miscellaneous}\\ 
\hline
Display device has an AFG & yes* \\
Number of lines in AFG & 24 \\
Number of characters per line in AFG & 80 \\
Device has Processor & no\\ 
Display device has graphics overlay & no\\
Number of interactive IO devices & 1**\\
Number of cursors & 2*\\
\hline
\end{tabular}
\\
\\
\\
* RMA2s are AFGs only and do not have imps, luts, cursors, etc

** The trackball is assignable in the DIB.  Autotracking cannot
be turned off, but which cursor is being controlled is switchable
between the two.

\newpage
\subsection{ADAGE Graphics System}
\begin{tabular}{|l l|}
\hline
\multicolumn{2}{|c|}{Hardware Configurations}\\
\hline
Full color, Pseudo-color, Monochrome & \\
$512 \times 512$, $1024 \times 1024$, $2048 \times 2048$ Image Memory Planes & \\
$512 \times 512$, $640 \times 480$, $1024 \times 1024$ Video Output & \\
$1 \times 1$, $4 \times 3$ Aspect Ratio & \\ 
\hline \hline
\multicolumn{2}{|c|}{Image Planes}\\ \hline
Each IMP has a separate display window & no\\
May connect IMP to LUT & yes\\
May Zoom IMPs & yes\\
Each IMP has a separate zoom & no\\
Maximum Zoom factor & 16\\
\hline \hline 
\multicolumn{2}{|c|}{Look-up Tables}\\ 
\hline
Number of LUTs & 3\\
Number of sections in image LUTs & 1\\
LUT may be bypassed & no\\
Largest value in LUT & 255 (8-bit)\\
\hline \hline 
\multicolumn{2}{|c|}{Miscellaneous}\\ 
\hline
Display device has an AFG & no \\
Device has Processor & no\\ 
\hline \hline 
\multicolumn{2}{|c|}{Graphics Overlay}\\ 
\hline
IMPs can be connected to overlay LUT & no\\
Graphics overlay LUT may be bypassed & no\\
Number of sections in graphics LUT & 1\\
Graphics overlay LUT characteristics & separate lut\\
\hline 
\hline
\multicolumn{2}{|c|}{Interactive IO Devices}\\ 
\hline
Number of interactive IO devices & 1\\
device 1 type & 2d\\
coordinates returned & absolute\\
pen simulation & 1\\
number of switches & 1\\
\hline 
\end{tabular}
\newpage
Adage continued...

\begin{tabular}{|l l|}
\hline
\multicolumn{2}{|c|}{Cursors}\\ 
\hline
Number of cursors & 1\\
Number of cursor types & 4\\
Number of cursor blink rates & 0\\
Autotrack available & see below\\
Resizable cursor available & no\\
Cursor color may be changed & no\\
\hline \hline 
\multicolumn{2}{|c|}{Cursor Forms}\\
\hline
0 = default (same as 1) & \\
1 =  + shape & \\
2 = X shape & \\
3 = 5 dots in a + shape & \\
4 = MIPL in a box & \\
\hline
\end{tabular}

\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
\multicolumn{7}{|c|}{ }\\
\multicolumn{7}{|c|}{Configurations by Video Output}\\
\multicolumn{7}{|c|}{ }\\
\hline
\multicolumn{1}{|c|}{ }
&\multicolumn{2}{|c|}{$512 \times 512$}
&\multicolumn{2}{|c|}{$640 \times 480$}
&\multicolumn{2}{|c|}{$1024 \times 1024$}\\
\hline
& & & & & & \\
Lines per IMP & 512 & 1024 & 512 & 1024 & 1024 & 2048 \\
& & & & & & \\
Samples per Line & 512 & 1024 & 512 & 1024 & 1024 & 2048 \\
& & & & & & \\
Number of IMPs & 32 & 8 & 16 & 8 & 12 & 3 \\
& & & & & & \\
Overlay Available & yes & yes & yes & yes & no & no \\
& & & & & & \\
Autotracking Available & yes & yes & no & no & no & no \\
& & & & & & \\
\hline
\end{tabular}
\\
\\
\\
Note: The cursor position cannot be modified using XDCSET while
autotracking is enabled.
\cleardoublepage
\section{Hardware Selection Criteria}
The following is a list of display hardware characteristics.
All of the listed items may or may not be important to your
application.  However, all are required to fully implement the MIPL
machine-independent interface.

When selecting a display device, a definition of the minimum
hardware required to do the job is necessary.  Some hardware
characteristics may be simulated in software to save cost.
\subsection{Control Registers}
All device control registers should be readable and writeable
by software, i.e. cursor control and location, display window,
aspect ratio, etc.  This is necessary if several programs are to
access an image sequentially.  Many devices have write-only
registers.
\subsection{LUT/DACs}
There is a LUT (Look-Up Table) for each DAC (Digital to
Analog Converter).  The LUT is used to modify the pixel values from
an image memory plane before they are output by the DAC.

All LUT tables are readable and writeable by software.  This
is necessary if several programs are to access an image
sequentially.  Many devices have write-only LUT tables.

Each image memory plane may be connected to any or all
LUT/DACs (video outputs).  This is necessary if the device is
configurable under software control.

LUTs may be bypassed under software control.  In this mode
pixel values are sent directly to the DACs.  In some systems, the LUTs
may not be bypassed.

Each LUT/DAC has a zoom factor associated with it.

LUT/DACs contain one or more pixel transformation tables (LUT
sections).  Each section consists of 256 entries, one for each pixel
value.  LUTs and DACs should have a minimum of 8 bits of output.  More
bits are needed if accurate gamma correction is desired.
\subsection{Graphics Overlay}
Each device should have graphics overlay capability.

Graphics overlay works by pixel substitution.  Any non-zero
graphics overlay pixel is substituted for regular pixels before going
to the DACs.  In this way, graphics overlay data is written on top of the
output image.

The graphics overlay LUT is different from the other LUTs in
that it has three tables (red,green,blue) in full color displays.

Any image memory plane may be used as a graphics overlay
plane by connecting it to the graphics overlay LUT.  This is
necessary if the device is configurable under software control.  Some
devices have fixed or no graphics overlay plane.  In many devices the
graphics overlay plane has fewer bits than the image memory planes.

The video output should support 30hz interlaced and 60hz
non-interlaced in low resoluton ($512 \times 512$).  It should also support
60hz interlaced in high resolution ($1024 \times 1024$).  $1 \times 1$
and $4 \times 3$ aspect ratios should be supported for low and
high resolution.
\subsection{Image Memory Planes}
Image memory planes are eight (8) bits deep.

Each plane has a display window and an access window associated
with it.

Physical image memory planes are configurable into several
logical image memory plane sizes--i.e. $512 \times 512$,
$1024 \times 1024$, etc.

Read and write with mask into any image memory plane should
be available.  Only non-zero bits in the mask may be read or written
in the image memory plane.
\subsection{Cursor}
One or more cursors should be available.  Each cursor should
have several forms and blink rates.  The cursor can be displayed in
several colors.  The cursors work by pixel substitution similar to
the graphics overlay.

Cursors should have one or more shapes.  However, user-defined
cursor patterns are preferred.

The center of the cursor pattern should be locatable over every
pixel in an image memory plane.  Many display devices use the upper
left corner as the (0,0) location of the cursor pattern and restrict
the cursor to the display window.  Useful cursor shapes such as X or
cross cannot be moved over all of the image memory plane pixels in
this case.
\subsection{Alphanumeric Font Generator}
Alphanumeric font generators are not very useful.  They make
an expensive display device act as a $24 \times 80$ terminal.  
However, font generators are supported by the VRDI routines.
\subsection{Interactive IO Devices}
One or more interactive IO devices should be available.  A
tablet, mouse or puck is preferred.  The IO devices should be a byte
stream data device using an RS232 interface.  This allows the device
to be located a distance from the display device itself.
\subsection{Special Hardware}
Hardware should be available to perform logical and
arithmetic operations between image memory planes.  Hardware
should also be available to fill areas, draw
vectors, compute histograms, etc.  This may be simulated in software
to reduce hardware costs.

Logical and arithmetic operations between two
planes should be able to deposit the results in a third plane.

Hardware should be available to have the display window or
cursor automatically track an interactive IO device.  No CPU cycles
should be used for this task.
\subsection{Other Considerations}
Application programs should be able to read or write single
pixels into any image memory plane at any location.  Application
programs should be able to read or write a line of pixels of any
length into any location in an image memory plane.  

The graphics overlay and the cursor should use different LUTs
if both are to be used at the same time.  Without this,
the cursor will disappear into the overlay as it is moved.  Many
display devices use the same LUT for both.

Simplicity of control registers can make the writing of
programs easier.  Some devices perform many functions with a single
control register.  For example, the cursor
location and blink rate may use the same register.  When you want to
change one, you must change both.  Many applications are written in
high level languages, such as FORTRAN, that do not have bit
manipulation facilities.  Devices that have multi-purpose registers usually
do not put values on easily used bit boundaries.  For example, they
might use bits 2-9 for one thing and 11-17 for another.

The location of control registers can also be a problem.  If
the cursor control uses two registers, they should be next to each
other.  This would require one write instead of two.  

Many devices allow the display window to move only in pre-defined
increments (e.g., 4 pixels at a time).  This may cause problems,
depending on your application.  This can be important if the cursor
location is relative to this window and not the image memory plane.

Interface software provided by the vendor can make
programming easier if it is full and complete.  Unfortunately, some
vendors only supply software that requires a deep knowledge of the
machine.  For example, there should be a raster line write routine,
not a need to load three registers with values to write the line.
\cleardoublepage
\section{Fonts Available on MIPL System}
\subsection{Standard Fonts}
\begin{tabular}{|c|l|l|}
\hline
&\multicolumn{1}{|c|}{Font}
&\multicolumn{1}{|c|}{Font}\\
\multicolumn{1}{|c|}{Number}
&\multicolumn{1}{|c|}{File Name}
&\multicolumn{1}{|c|}{Description}\\
\hline
0 & 000.FON & Default Font\\
1 & 001.FON & Simplex\\
2 & 002.FON & Duplex\\
3 & 003.FON & Roman\\
4 & 004.FON & Standard\\
5 & 005.FON & Standard 2\\
6 & 006.FON & Standard Italics\\
7 & 007.FON & Script\\
8 & 008.FON & Hollow\\
9 & 009.FON & Cartographic\\
10 & 010.FON & Greek\\
11 & 011.FON & English Geothic\\
12 & 012.FON & German Gothic\\
13 & 013.FON & Italian Gothic\\
14 & 014.FON & Cyrillic\\
30 & 030.FON & CCSI Font (from CC plot package)\\ \hline
\end{tabular}
\newpage
\subsection{Special and Combination Fonts}
\begin{tabular}{|c|l|l|}
\hline
\multicolumn{1}{|c|}{Number}
&\multicolumn{1}{|c|}{File Name}
&\multicolumn{1}{|c|}{Description}\\
\hline
102 & 102.FON & Cartographic Special Characters\\
103 & 103.FON & Simplex Roman, Greek and Script\\
& & (Upper Case)\\
104 & 104.FON & Simplex Roman, Greek and Script\\
& & (Lower Case)\\
105 & 105.FON & Simplex Roman Special Characters,\\
& & Geometry, Cards and Weather Symbols\\
106 & 106.FON & Circuit and Map Symbols\\
107 & 107.FON & Circles and Highway Symbols\\
111 & 111.FON & Math Symbols (normal size)\\
112 & 112.FON & Complex Roman, Greek and Italic\\
& & (Upper Case)\\
113 & 113.FON & Complex Roman, Greek and Italic\\
& & (Lower Case)\\
114 & 114.FON & Complex Roman Special Characters\\
& & and Astrology\\
115 & 115.FON & Zodiac and Music Symbols\\
116 & 116.FON & Math Symbols (large size)\\
117 & 117.FON & Duplex Roman and Complex Script\\
& & (Upper Case)\\
118 & 118.FON & Duplex Roman and Complex Script\\
& & (Lower Case)\\
119 & 119.FON & Duplex Roman and Complex Script\\
& & Special Characters\\
120 & 120.FON & Complex Cyrillic (Upper Case)\\
121 & 121.FON & Complex Cyrillic (Lower Case)\\
122 & 122.FON & Triplex Roman and Italic\\
& & (Upper Case)\\
123 & 123.FON & Triplex Roman and Italic\\
& & (Lower Case)\\
124 & 124.FON & Triplex Roman and Italic\\
& & Special Characters\\ \hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|c|l|l|}
\hline
\multicolumn{1}{|c|}{Number}
&\multicolumn{1}{|c|}{File Name}
&\multicolumn{1}{|c|}{Description}\\ \hline
125 & 125.FON & German Gothic (Upper Case)\\
126 & 126.FON & German Gothic (Lower Case)\\
127 & 127.FON & English Gothic (Upper Case)\\
128 & 128.FON & English Gothic (Lower Case)\\
129 & 129.FON & Gothic Special Characters\\
130 & 130.FON & Italian Gothic (Upper Case)\\
131 & 131.FON & Italian Gothic (Lower Case)\\ \hline
\end{tabular}
\newpage
\subsection{Description of Some Special Fonts}
\subsubsection{Font 102: Cartographic Special Characters}
\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
0 - 9 & Numerals\\
10 & Period\\
11 & Comma\\
12 & Colon\\
13 & Explamation\\
14 & Prime\\
15 & Interrogation\\
16 & Prime\\
17 & Second,Quote\\
18 & Degree\\
19 & Dollar\\
20 & Solidus\\
21 & Left Parenthesis\\
22 & Right Parenthesis\\
23 & Bar\\
24 & Minus\\
25 & Sum\\
26 & Equality\\
27 & Cross\\
28 & Asterisk\\
29 & Dot\\
30 & Left Quotation\\
31 & Right Quotation\\
32 & Arrow\\
33 & Number\\
34 & Ampersand\\
35 & Lozenge\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 105: Simplex Roman Special Character, 
Geometry, Cards and Weather Symbols}
\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
0 - 9 & Numerals 
&\multicolumn{2}{|c|}{Card Symbols}\\
\cline{3-4}
10 & Period & 41 & Spade\\
11 & Comma & 42 & Heart\\
12 & Colon & 43 & Diamond\\
13 & Exclamation & 44 & Club\\
\cline{3-4}
14 & Prime 
&\multicolumn{2}{|c|}{Misc Symbols}\\
\cline{3-4}
15 & Interrogation & 45 & Shamrock\\
16 & Prime & 46 & Fleur De Lis\\
\cline{3-4}
17 & Second,Quote
&\multicolumn{2}{|c|}{Weather Symbols}\\
\cline{3-4}
18 & Degree & 50 & Drizzle\\
19 & Dollar & 51 & Rain\\
20 & Solidus & 52 & Snow\\
21 & Left Parenthesis & 53 & Surface Cold Front\\
22 & Right Parenthesis & 54 & Surface Warm Front\\
23 & Bar & 55 & 50 Knot Flag\\
24 & Minus & 56 & Upper Cold Front\\
25 & Sum & 57 & Upper Warm Front\\
26 & Equality & 58 & Cumulo\\
27 & Cross & 59 & Alto\\
28 & Asterisk & 60 & Alto\\
29 & Dot & 61 & Cirro\\
30 & Left Quotation & 62 & Left Cirrostrato\\
31 & Right Quotation & 63 & Right Cirrostrato\\
32 & Arrow & 64 & Sand\\
33 & Number & 65 & Glaze\\
34 & Ampersand & 66 & Haze\\
35 & Lozenge & 67 & Thunderstorm\\
& & 68 & Hurricane\\
\hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
\multicolumn{2}{|c|}{Geometry Symbols} 
&\multicolumn{2}{|c|}{Circuit Symbols}\\
\hline
37 & Parallel & 96 & Horizontal\\
38 & Perpendicular & 97 & 45-Oblique\\
39 & Angle & 99 & Space (blank)\\ 
40 & Conclusion & & \\ \hline
\end{tabular}
\newpage
\subsubsection{Font 106: Circuit and Map Symbols}
\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
\multicolumn{2}{|c|}{Circuit Symbols}
&\multicolumn{2}{|c|}{Map Symbols}\\
\hline
00 & Horizontal & 40 & Circle\\
01 & 30-Oblique & 41 & Square\\
02 & 60-Oblique & 42 & Triangle\\
03 & Verticle & 43 & Diamond\\
04 & 120-Oblique & 44 & Star\\
05 & 150-Oblique & 45 & Mark\\
06 & Horizontal & 46 & Cross (line)\\
07 & 45-Oblique & 47 & Asterisk\\
08 & Vertical & 50 & Circle (solid)\\
09 & 135-Oblique & 51 & Square (solid)\\
10 & Upper Left Quadrant & 52 & Up Vertex (solid)\\
11 & Lower Left Quadrant & 53 & Left Vertex (solid)\\
12 & Lower Right Quadrant & 54 & Down Vertex (solid)\\
13 & Upper Right Quadrant & 55 & Right Vertex (solid)\\
14 & Lower Quadrant & 56 & Star (solid)\\
15 & Left Quadrant & 57 & Flag (solid)\\
16 & Right Quadrant & 60 & Anchorage\\
17 & Upper Quadrant & 61 & Aerodrome\\
18 & Verticle Zigzag & 62 & Mine\\
19 & Horizontal Zigzag & 63 & Derrick\\
20 & 30-Zigzag & 64 & Lightship\\
21 & 45-Zigzag & 65 & Wreck\\
22 & Upper Loop & 66 & Cross (hollow)\\
23 & Left Loop & 67 & Crescent\\
24 & Lower Loop & 68 & Star (hollow)\\
25 & Right Loop & 69 & Bell\\ \hline
\end{tabular}
\newpage
cont.

\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
\multicolumn{2}{|c|}{Circuit Symbols}
&\multicolumn{2}{|c|}{Map Symbols}\\
\hline
26 & 30-Loop & 70 & Palm\\
27 & 45-Loop & 71 & Pine\\
28 & Junction & 72 & Oak\\
29 & Jumper & 73 & Willow\\
30 & Grid & 74 & Grass\\
31 & Shield&&\\
32 & Filament & 99 & Space (blank)\\
33 & Ground&&\\
34 & Antenna&&\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 107: Circles and Highway Signs}
\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
00 & 2-Circle\\
01 & 4-Circle\\
02 & 5-Circle\\
03 & 7-Circle\\
04 & 11-Circle\\
05 & 17-Circle\\
06 & 22-Circle\\
07 & 41-Circle\\
08 & US Highway Sign\\
09 & IS Highway Sign\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 111: Math Symbols (Normal Size)}
\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
01 & PI\\
02 & Sigma\\
03 & Left Parenthesis\\
04 & Right Parenthesis\\
05 & Left Bracket\\
06 & Right Bracket\\
07 & Left Brace\\
08 & Right Brace\\
09 & Upper Half Brace\\
10 & Lower Half Brace\\
11 & Radical\\
12 & Integral\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 114: Complex Roman Special Characters and Astrology}
\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
\multicolumn{4}{|c|}{Roman Special Characters}\\
\hline
0 - 9 & Numerals & 37 & Quotient\\
10 & Period & 38 & Equality\\
11 & Comma & 39 & Inequality\\
12 & Colon & 40 & Idenity\\
13 & Semicolon & 41 & Less\\
14 & Exclamation & 42 & More\\
15 & Interrogation & 43 & Equal or Less\\
16 & Prime & 44 & Equal or More\\
17 & Second & 45 & Variation\\
18 & Degree & 46 & Approximation\\
19 & Asterisk & 47 & Caret\\
20 & Solidus & 48 & Acute Angle \\
21 & Left Parenthesis & 49 & Grave Accent\\
22 & Right Parenthesis & 50 & Breve\\
23 & Left Bracket & 51 & Right Quotation\\
24 & Right Bracket & 52 & Left Quotation\\
25 & Left Brace & 53 & Normal Aspirate\\
26 & Right Brace & 54 & Inverted Aspirate\\
27 & Left Elbow & 55 & Radical\\
28 & Right Elbow & 56 & Right Hook\\
29 & Bar & 57 & Up Hook\\
30 & Double Bar & 58 & Left Hook\\
31 & Minus & 59 & Down Hook\\
32 & Plus & 60 & Element\\
33 & Plus or Minus & 61 & Right Arrow\\
34 & Minus or Plus & 62 & Up Arrow\\
35 & Cross Product & 63 & Left Arrow\\
36 & Dot Product & 64 & Down Arrow\\ \hline
\end{tabular}
\newpage
\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
\multicolumn{2}{|c|}{Roman Special cont.}
&\multicolumn{2}{|c|}{Astrology Symbols}\\
\hline
65 & Delta & 81 & Sun\\
66 & Nabla & 82 & Mercury\\
67 & Radical & 83 & Venus\\
68 & Integral & 84 & Earth\\
69 & Circuit Integral & 85 & Mars\\
70 & Infinity & 86 & Jupiter\\
71 & Percent & 87 & Saturn\\
72 & Ampersand & 88 & Uranus\\
73 & At & 89 & Neptune\\
74 & Dollar & 90 & Pluto\\
75 & Number & 91 & Moon\\
76 & Paragraph & 92 & Comet\\
77 & Daggar & 93 & Star\\
78 & Double Daggar & 94 & Ascending Node\\
79 & Existence & 95 & Descending Node\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 115: Zodiac and Music Symbols}
\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
\multicolumn{2}{|c|}{Zodiac Symbols}
&\multicolumn{2}{|c|}{Music (heavy) Symbols}\\
\hline
01 & Aries & 67 & Dot\\
02 & Aturus & 68 & Upper Flag\\
03 & Gemni & 69 & Lower Flag\\
04 & Cancer & 70 & Whole Note\\
05 & Leo & 71 & Half Note\\
06 & Virgo & 72 & Quarter Note\\
07 & Libra & 73 & Sharp\\
08 & Scoripo & 74 & Natural\\
09 & Sagittarius & 75 & Flat\\
10 & Capricorn & 76 & Whole Rest\\
11 & Aquarius & 77 & Half Rest\\
12 & Pisces & 78 & Quarter Rest\\
\cline{1-2}
\multicolumn{2}{|c|}{Music (light) Symbols} & 79 & Eighth Rest\\
\cline{1-2}
17 & Dot & 80 & G Cleft\\
18 & Upper Flag & 81 & F Cleft\\
19 & Lower Flag & 82 & C Cleft\\
20 & Whole Note&&\\
21 & Half Note&&\\
22 & Quarter Note&&\\
23 & Sharp&&\\
24 & Natural&&\\
25 & Flat&&\\
26 & Whole Rest&&\\
27 & Half Rest&&\\
28 & Quarter Rest&&\\
29 & Eighth Rest&&\\
30 & G Cleft&&\\
31 & F Cleft&&\\
32 & C Cleft&&\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 116: Math Symbols (Large Size)}
\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
01 & PI\\
02 & Sigma\\
03 & Left Parenthesis\\
04 & Right Parenthesis\\
05 & Left Bracket\\
06 & Right Bracket\\
07 & Left Brace\\
08 & Right Brace\\
09 & Upper Half Brace\\
10 & Lower Half Brace\\
11 & Radical\\
12 & Integral\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 119: Duplex Roman and Complex Script
Special Characters}
\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
\multicolumn{2}{|c|}{Duplex Roman}
&\multicolumn{2}{|c|}{Complex Script}\\
\hline
0 - 9 & Numerals & 50 - 59 & Numerals\\
10 & Period & 60 & Period\\
11 & Comma & 61 & Comma\\
12 & Colon & 62 & Colon\\
13 & Semicolon & 63 & Semicolon\\
14 & Exclamation & 64 & Exclamation\\
15 & Interrogration & 65 & Interrogration\\
16 & Left Quote & 66 & Left Quote\\
17 & Right quote & 67 & Right Quote\\
18 & Ampersand & 68 & Ampersand\\
19 & Dollar & 69 & Dollar\\
20 & Solidus & 70 & Solidus\\
21 & Left Parenthesis & 71 & Left Parenthesis\\
22 & Right Parenthesis & 72 & Right Parenthesis\\
23 & Asterisk & 73 & Asterisk\\
24 & Subtraction & 74 & Subtraction\\
25 & Addition & 75 & Addition\\
26 & Equality & 76 & Equality\\
27 & Prime & 77 & Prime\\
28 & Second & 78 & Second\\
29 & Degree & 79 & Degree\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 124: Triplex Roman and Italic Special Characters}
\begin{tabular}{|c|l|c|l|}
\hline
\multicolumn{1}{|c|}{Character}
& & \multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}
&\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
\multicolumn{2}{|c|}{Triplex Roman}
&\multicolumn{2}{|c|}{Triplex Italic}\\
\hline
0 - 9 & Numerals & 50 - 59 & Numerals\\
10 & Period & 60 & Period\\
11 & Comma & 61 & Comma\\
12 & Colon & 62 & Colon\\
13 & Semicolon & 63 & Semicolon\\
14 & Exclamation & 64 & Exclamation\\
15 & Interrogration & 65 & Interrogration\\
16 & Left Quote & 66 & Left Quote\\
17 & Right quote & 67 & Right Quote\\
18 & Ampersand & 68 & Ampersand\\
19 & Dollar & 69 & Dollar\\
20 & Solidus & 70 & Solidus\\
21 & Left Parenthesis & 71 & Left Parenthesis\\
22 & Right Parenthesis & 72 & Right Parenthesis\\
23 & Asterisk & 73 & Asterisk\\
24 & Subtraction & 74 & Subtraction\\
25 & Addition & 75 & Addition\\
26 & Equality & 76 & Equality\\
27 & Prime & 77 & Prime\\
28 & Second & 78 & Second\\
29 & Degree & 79 & Degree\\ \hline
\end{tabular}
\newpage
\subsubsection{Font 129: Gothic Special Characters}
\begin{tabular}{|c|l|}
\hline
\multicolumn{1}{|c|}{Character}&\\
\multicolumn{1}{|c|}{Value}
&\multicolumn{1}{|c|}{Description}\\
\hline
0 - 9 & Numerals\\
10 & Period\\
11 & Comma\\
12 & Colon\\
13 & Semicolon\\
14 & Exclamation\\
15 & Interrogration\\
16 & Left Quote\\
17 & Right Quote\\
18 & Ampersand\\
19 & Dollar\\
20 & Solidus\\
21 & Left Parenthesis\\
22 & Right Parenthesis\\
23 & Asterisk\\
24 & Subtraction\\
25 & Addition\\
26 & Equality\\
27 & Prime\\
28 & Second\\
29 & Degree\\ \hline
\end{tabular}
\cleardoublepage
\section{Creating User Defined Text Fonts}
\subsection{History}
The Hershey character fonts are the basis for the character
fonts provided by the XDT* subroutines.  The Hershey fonts were
originally obtained in a complicated bit saving format.  This format
was changed and expanded to an ASCII text file for ease of use and
modification.  The Hershey character fonts are widely used and
provide a large number of standard and special character fonts.
\subsection{User Defined Fonts}
The XDT* subroutines are written so that users may define
their own text fonts.  Font files are named XXX.FON where XXX is a
three dight number between 000 and 999.  Font files are ASCII text
files and may be created using a text editor or a program.  XDFONT
is a symbol pointing to the directory containing the converted
Hershey font files.  Users may redirect this symbol to any directory
they wish.
\subsection{Defining Characters}
Characters within a font are defined by a series of vectors
drawn on an image memory plane.  The time needed to draw a character
is directly related to the number of vectors making up the character.
Very simple to very complex fonts have been provided.  Special
characters and symbols have also been provided.  (See appendix E for
more information.)

Vectors making up a character have an origin in the lower
left hand corner of a box which defines the nominal size of a
character.  Vectors making up a character are
not required to stay within this box, however (e.g., lower case
letters with descenders).

The height of this box has been normalized to 1.0 (this is
usually the size of capital letters).  The width of the box is
font-dependent.  Users may define fonts with fixed or variable width
characters.  Users may also define fonts with white space included on
either side of a character or on top and bottom.  The Hershey
character fonts have variable-width characters and usually have white
space on either side of the character.  They do not have
white space on the top or bottom of capitol letters.

The width of the characters is used to determine the length
of character strings.  When a string is written, characters are drawn
with no space between them.  That is why white space is usually
included in the width of each character.

Characters may have an ASCII value of 0 to 127.  Characters
not defined in a font file have a width of zero (0).  A character
that has a width but no vectors defines a blank or space.
\subsection{Font File Description}
The basic file format is a record containing the number of
characters described in the font file followed by descriptions of each
character.

A character description starts with a record containing the
ASCII code value for the character, the number of coordinate pairs,
and the nominal width of the character.  This record is
followed by zero or more coordinate pair records.  Each coordinate
pair record contains a move/draw flag and X,Y coordinates.  The
move/draw flag is a zero (0) for move and one (1) for draw.

Character descriptions do not need to be in numerical order
in the font file.  If the file contains duplicate descriptions (i.e.,
the same ASCII code value) the last one encountered will be used and
the others lost.
\cleardoublepage
\section{Sample Application Programs}
\subsection{Non-Interactive Sample Program}
This program sample does not interact with VIDS or other applications
and does not allow the operator to interact with the display device.
It is assumed the display device has been allocated prior to the 
execution of this program.  Error checking is not performed in this
sample because the error actions specified call for a program abort on
errors and fatal errors.
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\#define IMG\_SIZE 512*512\\
main()\\
\\
\{\\
\>int status, unit\_no;\\
\>int config[4] = \{0, 0, 0, 0\};\\
\>int red\_lut = 1;\\
\>int green\_lut = 2;\\
\>int blue\_lut = 3;\\
\>int imp\_1 = 1;\\
\>int imp\_2 = 2;\\
\>int imp\_3 = 3;\\
\>unsigned char buf1[IMG\_SIZE],buf2[IMG\_SIZE],buf3[IMG\_SIZE];\\
\\
/*  Set up actions to take on warning, error, and fatal status returns */\\
\\
\>status = zdeaction( 1, 3, 3 );\\
\\
/*  Get unit number to use in subsequent VRDI calls */\\
\\
\>status = zddunit( unit\_no );\\
\\
/*  Open the Device */\\
\\
\>status = zddopen( unit\_no );\\
\\
/*  Activate the device */\\
\\
\>status = zddactivate( unit\_no, 1 );\\
\\
/*  Setup default configuration */\\
\\
\>status = zddconfigure( unit\_no, config );\\
\\
/*  Load LUTs with linear ramps */\\
\\
\>status = zdlramp( unit\_no, red\_lut, section\_1 );\\
\>status = zdlramp( unit\_no, green\_lut, section\_1 );\\
\>status = zdlramp( unit\_no, blue\_lut, section\_1 );\\
\\
/*  Connect for color */\\
\\
\>status = zdlconnect( unit\_no, imp\_1, red\_lut,\\
\>\>\>\>\> section\_1, nobypass);\\
\>status = zdlconnect( unit\_no, imp\_2, green\_lut,\\
\>\>\>\>\> section\_1, nobypass);\\
\>status = zdlconnect( unit\_no, imp\_3, blue\_lut,\\
\>\>\>\>\> section\_1, nobypass);\\
\\
/*  The images are read into buf1, buf2, buf3 */\\
\\
\>read\_in\_image();\\
\\
/*  Display them */\\
\\
\>status = zdiawwrite( unit\_no, imp\_1, IMG\_SIZE, buf1 );\\
\>status = zdiawwrite( unit\_no, imp\_2, IMG\_SIZE, buf2 );\\
\>status = zdiawwrite( unit\_no, imp\_3, IMG\_SIZE, buf3 );\\
\\
/*  Close the Device */\\
\\
\>status = zddclose( unit\_no );\\
\>return( status );\\
\}\\
\end{tabbing}
\newpage
\subsection{Simple Interactive Sample Program}
This sample program allows the operator to interact with the display
device through use of the VIDS XVINTRACT routine.  This simple sample
shows the minimum you can get away with when creating
an interactive application involving the VRDI.  It is not
a very good program, because when the configuration changes, it simply
changes it back.  Note that this program fragment is in pseudo-code and
is not intended to be typed and run.
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\>zddunit()\\
\>zddopen()\\
\>zddactivate()\\
\\
\>/*  sets mode, connects planes, etc.  */\\
\>initialize()\\
\>loop\\
\>\>xvintract()\\
\>\>/*  config changed?  */\\
\>\>if (zdfconfig())\\
\>\>\>initialize()\\
\>\>process\_command()\\
\>end-loop\\
\>zddclose()\\
\end{tabbing}
If it is critical that you know exactly what is displayed, then the
following could be added to the above after the ZDFCONFIG check:
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\>if (zdfimage(..., 0))\\
\>\>for each plane used\\
\>\>\>if (zdfimage(..., plane)\\
\>\>\>\>refresh\_imp(plane)\\
\>\>end-for\\
\end{tabbing}
\newpage
\subsection{Better Interactive Sample Program}
This sample is more sophisticated than the previous example, because
it looks at exactly what has changed in the configuration, and adapts
to it.  As an example, this application can only run in color mode,
so it makes sure that it is in color mode, but it adapts to everything
else.  This is much better from the user's point of view, because the
user is more in control of the session.

An application that only used monochrome mode would be quite similar,
except there would be only one image plane to deal with, making some of
the loops unnecessary.

This sample also shows some examples of how certain things would be
handled--like reading the stretch or the cursor position.  Note that,
in general, the numbers 1, 2, or 3 are passed for the red, green, and
blue planes.  These numbers are actually look-up table numbers, and
have to be translated to actual image plane numbers by ZDSIMP.  You
could instead pass around the actual image plane numbers, of course,
as long as you know which look-up table they are connected to.  You
could call ZDSIMP for each plane each time the configuration changes,
then use the saved value.
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=\kill
\>zddunit()\\
\>zddopen()\\
\>zddactivate()\\
\>/*  initialize graphics LUT  */\\
\>zdglinit()\\
\>size = zdsnl, zdsns (or zdsvnl, zdsvns)\\
\>check\_device()\\
\>new\_size\_routine()\\
\>loop\\
\>\>xvintract()\\
\>\>if (zdfconfig())\\
\>\>check\_device()\\
\>\#if optional\\
\>\>/*  any image plane change?  */\\
\>\>if (zdfimage(...,0))\\
\>\>\>for i=1 to 3  (red, green, blue)\\
\>\>\>\>if (zdfimage(..., zdsimp(i)))\\
\>\>\>\>\>refresh\_plane(i)\\
\>\>\>end-for\\
\>\#endif optional\\
  \\
\>\>/*  process xvintract commands  */\\
  \\
\>\>...\\
  \\
\>\>if (command == ``REFRESH'')\\
\>\>\>for i=1 to 3 (red, green, blue)\\
\>\>\>\>if (zdfimage(...,zdsimp(i)))\\
\>\>\>\>\>refresh\_plane(i)\\
\>\>\>end-for\\
  \\
\>\>if (command == ``PLOT STRETCH TABLE'')\\
\>\>\>for i=1 to 3 (red, green, blue )\\
\>\>\>\>/*  read it--don't assume it.  */\\
\>\>\>\>/*  section 0 means current section.  */\\
\>\>\>\>zdlread(...,zdsimp(i),0,lut)\\
\>\>\>\>\>plot\_lut(i, lut)\\
\>\>\>end-for\\
  \\
\>\>if (command == ``GET POSITION INTERACTIVELY'')\\
\>\>\>/*  use user's choice for cursor form and blink  */\\
\>\>\>zdcshow()\\
\>\>\>zdcautotrack()\\
\>\>\>wait\_button()\\
\>\>\>zdclocation(..., raw\_x, raw\_y)\\
\end{tabbing}
NOTE:  You may use the raw coordinates for some things.  If you need
the image plane coordinates, you must translate.  The image plane
location may be different for each plane.  You could always assume one
plane, like red, if you want (VIDS tends to use the graphics
plane).  You could use ZDCILOCATION, but if you're doing more
than one plane, it is best to use ZDCLOCATION and the
coordinate translation routines so the user doesn't move the
cursor in between ZDCILOCATION calls.  Also, note the use
of ZDSIMP to get the plane number currently in use for each
color.
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=\kill
\>\>\>zdcraw2imp(...,zdsimp(...,1), raw\_x, raw\_y, red\_x, red\_y)\\
\>\>\>zdcraw2imp(...,zdsimp(...,2), raw\_x, raw\_y, grn\_x, grn\_y)\\
\>\>\>zdcraw2imp(...,zdsimp(...,3), raw\_x, raw\_y, blu\_x, blu\_y)\\
\>\>\>do\_something(red\_x, red\_y)\\
\>\>\>...\\
\\
\>\>if (command == ``DRAW GRAPHICS'')\\
\>\>\>zdgon()\\
\>\>\>/*  Don't assume you know the plane  */\\
\>\>\>plane = zdsgraph()\\
\>\>\>/*  Don't assume you know the DN  */\\
\>\>\>color = zdgcolor(..., ``RED'')\\
\>\>\>/*  Plot using the DN returned  */\\
\>\>\>plot\_graphics(plane, color)\\
\>\>\>/*  Ask for something close to this color  */\\
\>\>\>color = zdgrgb(..., 100,150,50)\\
\>\>\>/*  (most likely won't get exact color)  */\\
\>\>\>plot\_more\_graphics(plane,color)\\
\\
\>\>if (command == ``STRETCH'')\\
\>\>\>/*  Instead of section 1 below, you could use the\=*/\\
\>\>\>/*  current section (gotten via zdssection), but\>*/\\
\>\>\>/*  there's no real need to.\>*/\\
xx\=xx\=xx\=xx\=xx\=xx\=\kill
\\
\>\>\>/*  Set up LUT arrays  */\\
\>\>\>zdlwrite(..., 1, 1, lut)\\
\>\>\>zdlwrite(..., 2, 1, lut)\\
\>\>\>zdlwrite(..., 3, 1, lut)\\
\>\>\>/*  Use section 1, no bypass  */\\
\>\>\>zdlconnect(..., zdsimp(1), 1, 1, 0)\\
\>\>\>zdlconnect(..., zdsimp(2), 2, 1, 0)\\
\>\>\>zdlconnect(..., zdsimp(3), 3, 1, 0)\\
\>\>\>...\\
  \\
\>end-loop\\
  \\
\>check\_device:\\
  \\
\>/*  can only handle full color  */\\
\>if (zdsmode() != FULL\_COLOR)\\
\>\>/*  -1 config code == don't change  */\\
\>\>zddconfigure(..., [FULL\_COLOR,-1,-1,-1])\\
\>\>if (size != zdsnl(), zdsns(), ...)\\
\>\>\>size = zdsnl, zdsns (or zdsvnl, zdsvns)\\
\>\>\>new\_size\_routine()\\
\>\#if optional\\
\>\>\>for i=1 to 3 (red, green, blue)\\
\>\>\>\>refresh\_planes(i)\\
\>\>\>\>/* clear flag so won't refresh again */\\
\>\>\>\>zdfimage(..., zdsimp(i))\\
\>\>\>end-for\\
\>\#end-if optional\\
\end{tabbing}
\end{document}
